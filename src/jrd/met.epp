/*
 *	PROGRAM:	JRD Access Method
 *	MODULE:		met.epp
 *	DESCRIPTION:	Meta data handler
 *
 * The contents of this file are subject to the Interbase Public
 * License Version 1.0 (the "License"); you may not use this file
 * except in compliance with the License. You may obtain a copy
 * of the License at http://www.Inprise.com/IPL.html
 *
 * Software distributed under the License is distributed on an
 * "AS IS" basis, WITHOUT WARRANTY OF ANY KIND, either express
 * or implied. See the License for the specific language governing
 * rights and limitations under the License.
 *
 * The Original Code was created by Inprise Corporation
 * and its predecessors. Portions created by Inprise Corporation are
 * Copyright (C) Inprise Corporation.
 *
 * All Rights Reserved.
 * Contributor(s): ______________________________________.
 *
 * 2001.6.25 Claudio Valderrama: Finish MET_lookup_generator_id() by
 *	assigning it a number in the compiled requests table.
 *
 * 2001.07.06 Sean Leyne - Code Cleanup, removed "#ifdef READONLY_DATABASE"
 *                         conditionals, as the engine now fully supports
 *                         readonly databases.
 * 2001.10.03 Claudio Valderrama: MET_relation_owns_trigger() determines if
 *   there's a row in rdb$triggers with the given relation's and trigger's names.
 * 2001.10.04 Claudio Valderrama: MET_relation_default_class() determines if the
 *   given security class name is the default security class for a relation.
 *   Modify MET_lookup_field() so it can verify the field's security class, too.
 * 2002-02-24 Sean Leyne - Code Cleanup of old Win 3.1 port (WINDOWS_ONLY)
 * 2002-09-16 Nickolay Samofatov - Deferred trigger compilation changes
 * 2002.10.29 Sean Leyne - Removed obsolete "Netware" port
 * 2004.01.16 Vlad Horsun: added support for default parameters 
 */
// This MUST be at the top of the file
#ifdef DARWIN
#define _STLP_CCTYPE
#endif


#include "firebird.h"
#include <stdio.h>
#include <string.h>
#include "../jrd/common.h"
#include <stdarg.h>

#include "../jrd/ibase.h"
#include "../jrd/jrd.h"
#include "../jrd/sym.h"
#include "../jrd/val.h"
#include "../jrd/irq.h"
#include "../jrd/tra.h"
#include "../jrd/lck.h"
#include "../jrd/ods.h"
#include "../jrd/btr.h"
#include "../jrd/req.h"
#include "../jrd/exe.h"
#include "../jrd/scl.h"
#include "../jrd/blb.h"
#include "../jrd/met.h"
#include "../jrd/os/pio.h"
#include "../jrd/sdw.h"
#include "../jrd/flags.h"
#include "../jrd/all.h"
#include "../jrd/lls.h"
#include "../jrd/intl.h"
#include "../jrd/align.h"
#include "../jrd/flu.h"
#include "../jrd/blob_filter.h"
#include "../intl/charsets.h"
#include "../jrd/gdsassert.h"
#include "../jrd/all_proto.h"
#include "../jrd/blb_proto.h"
#include "../jrd/cmp_proto.h"
#include "../jrd/dfw_proto.h"
#include "../jrd/dsc_proto.h"
#include "../jrd/err_proto.h"
#include "../jrd/exe_proto.h"
#include "../jrd/ext_proto.h"
#include "../jrd/flu_proto.h"
#include "../jrd/gds_proto.h"
#include "../jrd/idx_proto.h"
#include "../jrd/ini_proto.h"

#include "../jrd/lck_proto.h"
#include "../jrd/met_proto.h"
#include "../jrd/mov_proto.h"
#include "../jrd/par_proto.h"
#include "../jrd/pcmet_proto.h"
#include "../jrd/os/pio_proto.h"
#include "../jrd/scl_proto.h"
#include "../jrd/sdw_proto.h"
#include "../jrd/thd.h"
#include "../jrd/sch_proto.h"
#include "../jrd/thread_proto.h"
#include "../jrd/iberr.h"
#include "../common/utils_proto.h"


#ifdef HAVE_CTYPE_H
#include <ctype.h>
#endif

/* Pick up relation ids */
#include "../jrd/ini.h"

#define BLR_BYTE        *(csb->csb_running)++
const char BLANK	= '\040';

DATABASE DB = FILENAME "ODS.RDB";

using namespace Jrd;

static int blocking_ast_procedure(void*);
static int blocking_ast_relation(void*);
static void get_trigger(thread_db*, jrd_rel*, bid*, trig_vec**, const TEXT*, bool, USHORT);
static bool get_type(thread_db*, SSHORT*, const UCHAR*, const TEXT*);
static void lookup_view_contexts(thread_db*, jrd_rel*);
static void name_copy(TEXT*, const TEXT*);
static jrd_nod* parse_param_blr(thread_db*, jrd_prc*, bid*, CompilerScratch*);
static jrd_nod* parse_procedure_blr(thread_db*, jrd_prc*, bid*, CompilerScratch*);
static bool par_messages(thread_db*, const UCHAR*, USHORT, jrd_prc*, CompilerScratch*);
static bool resolve_charset_and_collation(thread_db*, SSHORT*, const UCHAR*,
											 const UCHAR*);
static str* save_name(thread_db*, const TEXT*);
static void save_trigger_data(thread_db*, trig_vec**, jrd_rel*, jrd_req*, blb*,
	const TEXT*, bool, USHORT);
static void store_dependencies(thread_db*, CompilerScratch*, const TEXT*, USHORT);
static bool verify_TRG_ignore_perm(thread_db*, const TEXT*);



// Decompile all triggers from vector
static void release_cached_triggers(thread_db* tdbb, trig_vec* vector)
{
	if (!vector) 
	{
		return;
	}
			
	for (size_t i = 0; i < vector->getCount(); i++) 
	{
		(*vector)[i].release(tdbb);
	}
}


static void inc_int_use_count(jrd_req* req)
{
	// Increment int_use_count for all procedures in resource list of request
	ResourceList& list = req->req_resources;
	size_t i;
	for (list.find(Resource(Resource::rsc_procedure, 0, NULL, NULL), i);
	    i < list.getCount(); i++) 
	{
		Resource& resource = list[i];
		if (resource.rsc_type != Resource::rsc_procedure) 
			break;
		fb_assert(resource.rsc_prc->prc_int_use_count >= 0);
		++resource.rsc_prc->prc_int_use_count;
	}
}


// Increment int_use_count for all procedures used by triggers
static void post_used_procedures(trig_vec* vector)
{
	if (!vector) 
	{
		return;
	}
			
	for (size_t i = 0; i < vector->getCount(); i++) 
	{
		jrd_req* r = (*vector)[i].request;
		if (r && !CMP_clone_is_active(r))
		{
			inc_int_use_count(r);
		}
	}
}


void MET_update_partners(thread_db* tdbb)
{
/**************************************
 *
 *      M E T _ u p d a t e _ p a r t n e r s
 *
 **************************************
 *
 * Functional description
 *      Mark all relations to update their links to FK partners
 *      Called when any index is deleted because engine don't know
 *      was it used in any FK or not
 *
 **************************************/
	SET_TDBB(tdbb);
	Database* dbb = tdbb->tdbb_database;

	vec* relations = dbb->dbb_relations;

	vec::iterator ptr = relations->begin();
	for (const vec::const_iterator end = relations->end(); ptr < end; ptr++)
	{
		jrd_rel* relation = static_cast<jrd_rel*>(*ptr);
		if (!relation) {
			continue;
		}
		relation->rel_flags |= REL_check_partners;
	}
}


void adjust_dependencies(jrd_prc* procedure)
{
	if (procedure->prc_int_use_count == -1) {
	// Already processed
		return;
	}
	procedure->prc_int_use_count = -1; // Mark as undeletable
	if (procedure->prc_request) {
		// Loop over procedures from resource list of prc_request
		ResourceList& list = procedure->prc_request->req_resources;
		size_t i;
		for (list.find(Resource(Resource::rsc_procedure, 0, NULL, NULL), i);
			 i < list.getCount(); i++) 
		{
			Resource& resource = list[i];
			if (resource.rsc_type != Resource::rsc_procedure) 
				break;
			procedure = resource.rsc_prc;
			if (procedure->prc_int_use_count == procedure->prc_use_count) {
				// Mark it and all dependent procedures as undeletable
				adjust_dependencies(procedure); 
			}
		}
	}
}


#ifdef DEV_BUILD
void MET_verify_cache(thread_db* tdbb)
{
/**************************************
 *
 *      M E T _ v e r i f y _ c a c h e
 *
 **************************************
 *
 * Functional description
 *      Check if all links between procedures are properly counted
 *
 **************************************/
	SET_TDBB(tdbb);
	Database* dbb = tdbb->tdbb_database;
	
	vec* procedures = dbb->dbb_procedures;
	if (procedures) {
		jrd_prc* procedure;
		vec::iterator	ptr, end;
		
		for (ptr = procedures->begin(), end = procedures->end();
			ptr < end; ptr++) 
		{
			if ( (procedure = (jrd_prc*)(*ptr)) && procedure->prc_request /*&&
				 !(procedure->prc_flags & PRC_obsolete)*/ ) 
			{
				fb_assert(procedure->prc_int_use_count == 0);
			}
		}
		
		/* Walk procedures and calculate internal dependencies */
		for (ptr = procedures->begin(), end = procedures->end();
			ptr < end; ptr++) 
		{
			if ( (procedure = (jrd_prc*)(*ptr)) && procedure->prc_request /*&&
				 !(procedure->prc_flags & PRC_obsolete)*/ ) 
			{
				inc_int_use_count(procedure->prc_request);
			}
		}
		
		/* Walk procedures again and check dependencies */
		for (ptr = procedures->begin(), end = procedures->end();
			ptr < end; ptr++) 
		{
			if ( (procedure = (jrd_prc*)(*ptr)) && procedure->prc_request && /*
				 !(procedure->prc_flags & PRC_obsolete) && */
				 procedure->prc_use_count < procedure->prc_int_use_count)
			{
				char buffer[1024], *buf = buffer;
				buf += sprintf(buf, "Procedure %d:%s is not properly counted (use count=%d, prc use=%d). Used by: \n", 
					procedure->prc_id, procedure->prc_name.c_str(), procedure->prc_use_count, procedure->prc_int_use_count);
				vec::const_iterator ptr2 = procedures->begin();
				for (const vec::const_iterator end2 = procedures->end();
					ptr2 < end2; ptr2++)
				{
					const jrd_prc* prc = (jrd_prc*)(*ptr2);
					if (prc && prc->prc_request /*&&
						!(prc->prc_flags & PRC_obsolete)*/ )
					{
						// Loop over procedures from resource list of prc_request
						const ResourceList& list = prc->prc_request->req_resources;
						size_t i;
						for (list.find(Resource(Resource::rsc_procedure, 0, NULL, NULL), i);
						     i < list.getCount(); i++) 
						{
							const Resource& resource = list[i];
							if (resource.rsc_type != Resource::rsc_procedure) 
								break;
							if (resource.rsc_prc == procedure) {
								buf += sprintf(buf, "%d:%s\n", prc->prc_id, prc->prc_name.c_str());
							}
						}
					}
				}
				gds__log(buffer);
				fb_assert(false);
			}
		}
		
		/* Fix back int_use_count */		
		for (ptr = procedures->begin(), end = procedures->end();
				ptr < end; ptr++) 
		{
			if ( (procedure = (jrd_prc*)(*ptr)) )
			{				
				procedure->prc_int_use_count = 0;
			}
		}		
	}
}
#endif


void MET_clear_cache(thread_db* tdbb)
{
/**************************************
 *
 *      M E T _ c l e a r _ c a c h e
 *
 **************************************
 *
 * Functional description
 *      Remove all unused objects from metadata cache to 
 *      release resources they use
 *
 **************************************/
	SET_TDBB(tdbb);
#ifdef DEV_BUILD
	MET_verify_cache(tdbb);
#endif
	vec::iterator	ptr, end;

	Database* dbb = tdbb->tdbb_database;

	vec* relations = dbb->dbb_relations;
	for (ptr = relations->begin(), end = relations->end(); ptr < end; ptr++)
	{
		jrd_rel* relation = static_cast<jrd_rel*>(*ptr);
		if (!relation)
			continue;
		release_cached_triggers(tdbb, relation->rel_pre_store);
		release_cached_triggers(tdbb, relation->rel_post_store);
		release_cached_triggers(tdbb, relation->rel_pre_erase);
		release_cached_triggers(tdbb, relation->rel_post_erase);
		release_cached_triggers(tdbb, relation->rel_pre_modify);
		release_cached_triggers(tdbb, relation->rel_post_modify);
	}
 
	vec* procedures = dbb->dbb_procedures;
	if (procedures) {
		jrd_prc* procedure;
		/* Walk procedures and calculate internal dependencies */
		for (ptr = procedures->begin(), end = procedures->end();
			ptr < end; ptr++) 
		{
			if ( (procedure = (jrd_prc*)(*ptr)) && procedure->prc_request &&
				 !(procedure->prc_flags & PRC_obsolete) ) 
			{
				inc_int_use_count(procedure->prc_request);
			}
		}
		
		// Walk procedures again and adjust dependencies for procedures
		// which will not be removed.
		for (ptr = procedures->begin(), end = procedures->end();
			ptr < end; ptr++) 
		{
			if ( (procedure = (jrd_prc*)(*ptr)) && procedure->prc_request &&
				 !(procedure->prc_flags & PRC_obsolete) && 
				 procedure->prc_use_count != procedure->prc_int_use_count )
			{
				adjust_dependencies(procedure);
			}
		}
		
		/* Deallocate all used requests */		
		for (ptr = procedures->begin(), end = procedures->end();
				ptr < end; ptr++) 
		{
			if ( (procedure = (jrd_prc*)(*ptr))  )
			{
				
				if ( procedure->prc_request && 
					 !(procedure->prc_flags & PRC_obsolete) && 
					 procedure->prc_int_use_count >= 0 &&  
					 procedure->prc_use_count == procedure->prc_int_use_count ) 
				{
					CMP_release(tdbb, procedure->prc_request);
					procedure->prc_request = NULL;
					LCK_release(tdbb, procedure->prc_existence_lock);
					procedure->prc_existence_lock = NULL;
					procedure->prc_flags |= PRC_obsolete;
				}
				// Leave it in state 0 to avoid extra pass next time to clear it
				// Note: we need to adjust prc_int_use_count for all procedures
				// in cache because any of them may have been affected from
				// dependencies earlier. Even procedures that were not scanned yet !
				procedure->prc_int_use_count = 0;
			}
		}
		
		/* Remove deallocated procedures from cache */
		for (ptr = procedures->begin(), end = procedures->end();
				ptr < end; ptr++) 
		{
			if ( (procedure = (jrd_prc*)(*ptr)) &&
				 (procedure->prc_flags & PRC_obsolete) ) 
			{
				MET_remove_procedure(tdbb, procedure->prc_id, procedure);			  
			}
		}
		
	}
#ifdef DEV_BUILD
	MET_verify_cache(tdbb);
#endif
}


bool MET_procedure_in_use(thread_db* tdbb, jrd_prc* proc)
{
/**************************************
 *
 *      M E T _ p r o c e d u r e _ i n _ u s e
 *
 **************************************
 *
 * Functional description
 *      Determine if procedure is used by any user requests or transactions. 
 *      Return false if procedure is used only inside cache or not used at all.
 *
 **************************************/
	SET_TDBB(tdbb);
#ifdef DEV_BUILD
	MET_verify_cache(tdbb);
#endif
	Database* dbb = tdbb->tdbb_database;
	
	// This should not really happen
	vec* procedures = dbb->dbb_procedures;
	if (!procedures) {
		return false;
	}

	vec* relations = dbb->dbb_relations;

	vec::iterator	ptr, end;
	for (ptr = relations->begin(), end = relations->end(); ptr < end; ptr++)
	{
		jrd_rel* relation = static_cast<jrd_rel*>(*ptr);
		if (!relation) {
			continue;
		}
		post_used_procedures(relation->rel_pre_store);
		post_used_procedures(relation->rel_post_store);
		post_used_procedures(relation->rel_pre_erase);
		post_used_procedures(relation->rel_post_erase);
		post_used_procedures(relation->rel_pre_modify);
		post_used_procedures(relation->rel_post_modify);
	}

	jrd_prc* procedure;
	/* Walk procedures and calculate internal dependencies */
	for (ptr = procedures->begin(), end = procedures->end();
		ptr < end; ptr++) 
	{
		if ( (procedure = (jrd_prc*)(*ptr)) && procedure->prc_request &&
			 !(procedure->prc_flags & PRC_obsolete) ) 
		{
			inc_int_use_count(procedure->prc_request);
		}
	}
		
	// Walk procedures again and adjust dependencies for procedures
	// which will not be removed.
	for (ptr = procedures->begin(), end = procedures->end();
		ptr < end; ptr++) 
	{
		if ( (procedure = (jrd_prc*)(*ptr)) && procedure->prc_request &&
			 !(procedure->prc_flags & PRC_obsolete) && 
			 procedure->prc_use_count != procedure->prc_int_use_count &&
			 procedure != proc )
		{
			adjust_dependencies(procedure);
		}
	}
		
	const bool result = proc->prc_use_count != proc->prc_int_use_count;
		
	/* Fix back int_use_count */
	for (ptr = procedures->begin(), end = procedures->end();
			ptr < end; ptr++) 
	{
		if ( (procedure = (jrd_prc*)(*ptr)) )
		{				
			procedure->prc_int_use_count = 0;
		}
	}
#ifdef DEV_BUILD
	MET_verify_cache(tdbb);
#endif
	return result;
}


void MET_activate_shadow( thread_db* tdbb)
{
/**************************************
 *
 *      M E T _ a c t i v a t e _ s h a d o w
 *
 **************************************
 *
 * Functional description
 *      Activate the current database, which presumably
 *      was formerly a shadow, by deleting all records
 *      corresponding to the shadow that this database
 *      represents.
 *      Get rid of write ahead log for the activated shadow.
 *
 **************************************/
	SET_TDBB(tdbb);
	Database* dbb = tdbb->tdbb_database;

/* Erase any secondary files of the primary database of the
   shadow being activated. */

	jrd_req* handle = NULL;
	FOR(REQUEST_HANDLE handle) X IN RDB$FILES
		WITH X.RDB$SHADOW_NUMBER NOT MISSING
			AND X.RDB$SHADOW_NUMBER EQ 0 
        ERASE X;
	END_FOR;

	CMP_release(tdbb, handle);

	const char* dbb_file_name = dbb->dbb_file->fil_string;

/* go through files looking for any that expand to the current database name */
	SCHAR expanded_name[MAXPATHLEN];
	jrd_req* handle2 = handle = NULL;
	FOR(REQUEST_HANDLE handle) X IN RDB$FILES
		WITH X.RDB$SHADOW_NUMBER NOT MISSING
			AND X.RDB$SHADOW_NUMBER NE 0

        PIO_expand(X.RDB$FILE_NAME, (USHORT)strlen(X.RDB$FILE_NAME),
                   expanded_name, sizeof(expanded_name));

		if (!strcmp(expanded_name, dbb_file_name)) {
			FOR(REQUEST_HANDLE handle2) Y IN RDB$FILES
				WITH X.RDB$SHADOW_NUMBER EQ Y.RDB$SHADOW_NUMBER
				MODIFY Y
					Y.RDB$SHADOW_NUMBER = 0;
				END_MODIFY;
			END_FOR;
			ERASE X;
		}
	END_FOR;

	if (handle2)
	{
		CMP_release(tdbb, handle2);
	}
	CMP_release(tdbb, handle);
}


ULONG MET_align(Database* dbb, const dsc* desc, ULONG value)
{
/**************************************
 *
 *      M E T _ a l i g n
 *
 **************************************
 *
 * Functional description
 *      Align value (presumed offset) on appropriate border
 *      and return.
 *
 **************************************/
	USHORT alignment = desc->dsc_length;
	switch (desc->dsc_dtype) {
	case dtype_text:
	case dtype_cstring:
		return value;

	case dtype_varying:
		alignment = sizeof(USHORT);
		break;
	}

	alignment = MIN(alignment, 
	  dbb->dbb_ods_version >= ODS_VERSION11 ?
	  FORMAT_ALIGNMENT : ALIGNMENT);

	return FB_ALIGN(value, alignment);
}


void MET_change_fields( thread_db* tdbb, jrd_tra* transaction, const dsc* field_source)
{
/**************************************
 *
 *      M E T _ c h a n g e _ f i e l d s
 *
 **************************************
 *
 * Functional description
 *      Somebody is modifying RDB$FIELDS.  Find all relations affected
 *      and schedule a format update.
 *
 **************************************/
	SET_TDBB(tdbb);
	Database* dbb = tdbb->tdbb_database;

    dsc relation_name;
	jrd_req* request = CMP_find_request(tdbb, irq_m_fields, IRQ_REQUESTS);

	FOR(REQUEST_HANDLE request)
		X IN RDB$RELATION_FIELDS WITH
			X.RDB$FIELD_SOURCE EQ field_source->dsc_address

        if (!REQUEST(irq_m_fields))
			REQUEST(irq_m_fields) = request;

		relation_name.dsc_dtype = dtype_text;
		INTL_ASSIGN_DSC(&relation_name, CS_METADATA, COLLATE_NONE);
		relation_name.dsc_length = sizeof(X.RDB$RELATION_NAME);
		relation_name.dsc_address = (UCHAR *) X.RDB$RELATION_NAME;
		SCL_check_relation(&relation_name, SCL_control);
		DFW_post_work(transaction, dfw_update_format, &relation_name, 0);
	END_FOR;

	if (!REQUEST(irq_m_fields))
		REQUEST(irq_m_fields) = request;
}


Format* MET_current(thread_db* tdbb, jrd_rel* relation)
{
/**************************************
 *
 *      M E T _ c u r r e n t
 *
 **************************************
 *
 * Functional description
 *      Get the current format for a relation.  The current format is the
 *      format in which new records are to be stored.
 *
 **************************************/

	if (relation->rel_current_format)
		return relation->rel_current_format;

	SET_TDBB(tdbb);

	return relation->rel_current_format =
		MET_format(tdbb, relation, relation->rel_current_fmt);
}


void MET_delete_dependencies(thread_db*	tdbb,
							 const TEXT*	object_name,
							 USHORT	dependency_type)
{
/**************************************
 *
 *      M E T _ d e l e t e _ d e p e n d e n c i e s
 *
 **************************************
 *
 * Functional description
 *      Delete all dependencies for the specified 
 *      object of given type.
 *
 **************************************/
	SET_TDBB(tdbb);
	Database* dbb = tdbb->tdbb_database;

	if (!object_name)
		return;

	jrd_req* request = CMP_find_request(tdbb, irq_d_deps, IRQ_REQUESTS);

	FOR(REQUEST_HANDLE request)
		DEP IN RDB$DEPENDENCIES
			WITH DEP.RDB$DEPENDENT_NAME = object_name
			AND DEP.RDB$DEPENDENT_TYPE = dependency_type

        if (!REQUEST(irq_d_deps))
			REQUEST(irq_d_deps) = request;

		ERASE DEP;
	END_FOR;

	if (!REQUEST(irq_d_deps))
		REQUEST(irq_d_deps) = request;
}


void MET_delete_shadow( thread_db* tdbb, USHORT shadow_number)
{
/**************************************
 *
 *      M E T _ d e l e t e _ s h a d o w
 *
 **************************************
 *
 * Functional description 
 *      When any of the shadows in RDB$FILES for a particular
 *      shadow are deleted, stop shadowing to that file and
 *      remove all other files from the same shadow.
 *
 **************************************/
	SET_TDBB(tdbb);
	Database* dbb = tdbb->tdbb_database;

	jrd_req* handle = NULL;

	FOR(REQUEST_HANDLE handle)
		X IN RDB$FILES WITH X.RDB$SHADOW_NUMBER EQ shadow_number 
        ERASE X;
	END_FOR;

	CMP_release(tdbb, handle);

	for (Shadow* shadow = dbb->dbb_shadow; shadow; shadow = shadow->sdw_next) {
		if (shadow->sdw_number == shadow_number) {
			shadow->sdw_flags |= SDW_shutdown;
		}
	}

/* notify other processes to check for shadow deletion */
	if (SDW_lck_update((SLONG) 0)) {
		SDW_notify();
	}
}


void MET_error(const TEXT* string, ...)
{
/**************************************
 *
 *      M E T _ e r r o r
 *
 **************************************
 *
 * Functional description
 *      Post an error in a metadata update
 *      Oh, wow.
 *
 **************************************/
	TEXT s[128];
	va_list ptr;

	va_start(ptr, string);
	VSNPRINTF(s, sizeof(s), string, ptr);
	va_end(ptr);

	ERR_post(isc_no_meta_update, isc_arg_gds, isc_random, isc_arg_string,
			 ERR_cstring(s), 0);
}

Format* MET_format(thread_db* tdbb, jrd_rel* relation, USHORT number)
{
/**************************************
 *
 *      M E T _ f o r m a t
 *
 **************************************
 *
 * Functional description
 *      Lookup a format for given relation.
 *
 **************************************/
	SET_TDBB(tdbb);
	Database* dbb = tdbb->tdbb_database;

	Format* format;
	vec* formats = relation->rel_formats;
	if (formats &&
		(number < formats->count()) &&
		(format = (Format*) (*formats)[number]))
	{
		return format;
	}

	format = NULL;
	jrd_req* request = CMP_find_request(tdbb, irq_r_format, IRQ_REQUESTS);

	FOR(REQUEST_HANDLE request)
		X IN RDB$FORMATS WITH X.RDB$RELATION_ID EQ relation->rel_id AND
			X.RDB$FORMAT EQ number 

        if (!REQUEST(irq_r_format))
		{
            REQUEST(irq_r_format) = request;
		}
		blb* blob = BLB_open(tdbb, dbb->dbb_sys_trans, &X.RDB$DESCRIPTOR);
		
		if (sizeof(OdsDesc) == sizeof(struct dsc) || dbb->dbb_ods_version < ODS_VERSION11) {
			// For ODS10 and earlier read descriptors in their in-memory representation
			// This makes 64-bit and 32-bit ODS10 different for the same architecture.
			
			const USHORT count = blob->blb_length / sizeof(struct dsc);
			format = Format::newFormat(*dbb->dbb_permanent, count);
			format->fmt_count = count;
			BLB_get_data(tdbb, blob, (UCHAR*) &(format->fmt_desc[0]), blob->blb_length);

			for (Format::fmt_desc_const_iterator desc = format->fmt_desc.end() - 1;
				 desc >= format->fmt_desc.begin();
				 --desc)
			{
	 			if (desc->dsc_address)
				{
					format->fmt_length =
						(IPTR) desc->dsc_address + desc->dsc_length;
					break;
				}
			}
		} else {
			// Use generic representation of formats with 32-bit offsets
			
			const USHORT count = blob->blb_length / sizeof(OdsDesc);
			format = Format::newFormat(*dbb->dbb_permanent, count);
			format->fmt_count = count;
			Firebird::Array<OdsDesc> odsDescs;
			OdsDesc *odsDesc = odsDescs.getBuffer(count);
			BLB_get_data(tdbb, blob, (UCHAR*) odsDesc, blob->blb_length);
		
			for (Format::fmt_desc_iterator desc = format->fmt_desc.begin();
				 desc < format->fmt_desc.end(); ++desc, ++odsDesc)
			{
				desc->dsc_dtype = odsDesc->dsc_dtype;
				desc->dsc_scale = odsDesc->dsc_scale;
				desc->dsc_length = odsDesc->dsc_length;
				desc->dsc_sub_type = odsDesc->dsc_sub_type;
				desc->dsc_flags = odsDesc->dsc_flags;
				desc->dsc_address = (UCHAR*)(IPTR) odsDesc->dsc_offset;
				if (desc->dsc_address)
					format->fmt_length = (IPTR) desc->dsc_address + desc->dsc_length;
			}
		}
	END_FOR;

	if (!REQUEST(irq_r_format)) {
		REQUEST(irq_r_format) = request;
	}

	if (!format) {
		format = Format::newFormat(*dbb->dbb_permanent);
	}

	format->fmt_version = number;

/* Link the format block into the world */

	formats = relation->rel_formats =
		vec::newVector(*dbb->dbb_permanent, relation->rel_formats, number + 1);
	(*formats)[number] = (BLK) format;

	return format;
}


bool MET_get_char_subtype(thread_db* tdbb,
							 SSHORT* id, const UCHAR* name, USHORT length)
{
/**************************************
 *
 *      M E T _ g e t _ c h a r _ s u b t y p e 
 *
 **************************************
 *
 * Functional description
 *      Character types can be specified as either:
 *         a) A POSIX style locale name "<collation>.<characterset>"
 *         or
 *         b) A simple <characterset> name (using default collation)
 *         c) A simple <collation> name    (use charset for collation)
 *
 *      Given an ASCII7 string which could be any of the above, try to
 *      resolve the name in the order a, b, c
 *      a) is only tried iff the name contains a period.
 *      (in which case b) and c) are not tried).
 *
 * Return:
 *      1 if no errors (and *id is set).
 *      0 if the name could not be resolved.
 *
 **************************************/
	SET_TDBB(tdbb);

	fb_assert(id != NULL);
	fb_assert(name != NULL);

	const UCHAR* const end_name = name + length;

/* Force key to uppercase, following C locale rules for uppercasing */
/* At the same time, search for the first period in the string (if any) */
	UCHAR buffer[32];			/* BASED ON RDB$COLLATION_NAME */
	UCHAR* p = buffer;
	UCHAR* period = NULL;
	for (; name < end_name && p < buffer + sizeof(buffer) - 1; p++, name++) {
		*p = UPPER7(*name);
		if ((*p == '.') && !period) {
			period = p;
		}
	}
	*p = 0;

/* Is there a period, separating collation name from character set? */
	if (period) {
		*period = 0;
		return resolve_charset_and_collation(tdbb, id, period + 1, buffer);
	}
	else {
		/* Is it a character set name (implying charset default collation sequence) */

		bool res = resolve_charset_and_collation(tdbb, id, buffer, NULL);
		if (!res) {
			/* Is it a collation name (implying implementation-default character set) */
			res = resolve_charset_and_collation(tdbb, id, NULL, buffer);
		}
		return res;
	}
}


jrd_nod* MET_get_dependencies(thread_db*	tdbb,
						 jrd_rel*			relation,
						 const TEXT*		blob,
						 CompilerScratch*	view_csb,
						 bid*				blob_id,
						 jrd_req**			request,
						 CompilerScratch**	csb_ptr,
						 const TEXT*		object_name,
						 USHORT				type)
{
/**************************************
 *
 *      M E T _ g e t _ d e p e n d e n c i e s
 *
 **************************************
 *
 * Functional description
 *      Get dependencies for an object by parsing 
 *      the blr used in its definition.
 *
 **************************************/
	SET_TDBB(tdbb);
	Database* dbb = tdbb->tdbb_database;

	CompilerScratch* csb = CompilerScratch::newCsb(*tdbb->getDefaultPool(), 5);
	csb->csb_g_flags |= csb_get_dependencies;

	jrd_nod* node;
	if (blob)
	{
		node = PAR_blr(	tdbb,
						relation,
						reinterpret_cast<const UCHAR*>(blob),
						view_csb,
						&csb,
						request,
						(type == obj_trigger),
						0);
	}
	else
	{
		node =
			MET_parse_blob(	tdbb,
							relation,
							blob_id,
							&csb,
							request,
							(type == obj_trigger),
							false);
	}

	if (type == (USHORT) obj_computed)
	{
		jrd_req* handle = NULL;
		FOR(REQUEST_HANDLE handle)
			RLF IN RDB$RELATION_FIELDS CROSS
				FLD IN RDB$FIELDS WITH
				RLF.RDB$FIELD_SOURCE EQ FLD.RDB$FIELD_NAME AND
				RLF.RDB$RELATION_NAME EQ relation->rel_name AND
				RLF.RDB$FIELD_NAME EQ object_name
            object_name = FLD.RDB$FIELD_NAME;
		END_FOR;
		CMP_release(tdbb, handle);
	}

	store_dependencies(tdbb, csb, object_name, type);

	if (csb_ptr)
	{
		*csb_ptr = csb;
	}
	else
	{
		delete csb;
	}

	return node;
}


jrd_fld* MET_get_field(jrd_rel* relation, USHORT id)
{
/**************************************
 *
 *      M E T _ g e t _ f i e l d
 *
 **************************************
 *
 * Functional description
 *      Get the field block for a field if possible.  If not,
 *      return NULL;
 *
 **************************************/
	vec* vector;

	if (!relation ||
		!(vector = relation->rel_fields) ||
		id >= vector->count())
	{
		return NULL;
	}

	return (jrd_fld*) (*vector)[id];
}


void MET_get_shadow_files( thread_db* tdbb, bool delete_files)
{
/**************************************
 *
 *      M E T _ g e t _ s h a d o w _ f i l e s
 *
 **************************************
 *
 * Functional description
 *      Check the shadows found in the database against
 *      our in-memory list: if any new shadow files have 
 *      been defined since the last time we looked, start
 *      shadowing to them; if any have been deleted, stop
 *      shadowing to them.
 *
 **************************************/
	SET_TDBB(tdbb);
	Database* dbb = tdbb->tdbb_database;

	jrd_req* handle = NULL;
	FOR(REQUEST_HANDLE handle) X IN RDB$FILES
		WITH X.RDB$SHADOW_NUMBER NOT MISSING
			AND X.RDB$SHADOW_NUMBER NE 0
			AND X.RDB$FILE_SEQUENCE EQ 0
        if ((X.RDB$FILE_FLAGS & FILE_shadow) &&
            !(X.RDB$FILE_FLAGS & FILE_inactive))
		{
			const USHORT file_flags = X.RDB$FILE_FLAGS;
			SDW_start(X.RDB$FILE_NAME, X.RDB$SHADOW_NUMBER, file_flags,
					  delete_files);

			/* if the shadow exists, mark the appropriate shadow 
			   block as found for the purposes of this routine;
			   if the shadow was conditional and is no longer, note it */

			for (Shadow* shadow = dbb->dbb_shadow; shadow; shadow = shadow->sdw_next)
			{
				if ((shadow->sdw_number == X.RDB$SHADOW_NUMBER) &&
					!(shadow->sdw_flags & SDW_IGNORE))
				{
					shadow->sdw_flags |= SDW_found;
					if (!(file_flags & FILE_conditional)) {
						shadow->sdw_flags &= ~SDW_conditional;
					}
					break;
				}
			}
		}
	END_FOR;

	CMP_release(tdbb, handle);

/* if any current shadows were not defined in database, mark 
   them to be shutdown since they don't exist anymore */

	for (Shadow* shadow = dbb->dbb_shadow; shadow; shadow = shadow->sdw_next) {
		if (!(shadow->sdw_flags & SDW_found)) {
			shadow->sdw_flags |= SDW_shutdown;
		}
		else {
			shadow->sdw_flags &= ~SDW_found;
		}
	}

	SDW_check();
}


void MET_load_trigger(
					  thread_db* tdbb,
					  jrd_rel* relation, const TEXT* trigger_name,
					  trig_vec** triggers)
{
/**************************************
 *
 *      M E T _ l o a d _ t r i g g e r
 *
 **************************************
 *
 * Functional description
 *      Load triggers from RDB$TRIGGERS.  If a requested,
 *      also load triggers from RDB$RELATIONS.
 *
 **************************************/
	TEXT errmsg[MAX_ERRMSG_LEN + 1];

	SET_TDBB(tdbb);
	Database* dbb = tdbb->tdbb_database;
	CHECK_DBB(dbb);

	if (relation->rel_flags & REL_sys_trigs_being_loaded) {
		return;
	}

/* No need to load triggers for ReadOnly databases,
   since INSERT/DELETE/UPDATE statements are not going to be allowed */
	if (dbb->dbb_flags & DBB_read_only) {
		return;
	}

/* Scan RDB$TRIGGERS next */

	jrd_req* trigger_request = CMP_find_request(tdbb, irq_s_triggers, IRQ_REQUESTS);

	FOR(REQUEST_HANDLE trigger_request)
		TRG IN RDB$TRIGGERS WITH TRG.RDB$RELATION_NAME =
			relation->rel_name AND TRG.RDB$TRIGGER_NAME EQ trigger_name
		if (!REQUEST(irq_s_triggers))
			REQUEST(irq_s_triggers) = trigger_request;

		if (TRG.RDB$TRIGGER_TYPE > 0 && TRG.RDB$TRIGGER_TYPE < TRIGGER_COMBINED_MAX)
		{
			/* check if the trigger is to be fired without any permissions
			   checks. Verify such a claim */
			USHORT trig_flags = (USHORT) TRG.RDB$FLAGS;

			/* if there is an ignore permission flag, see if it is legit */
			if ((TRG.RDB$FLAGS & TRG_ignore_perm) &&
				!verify_TRG_ignore_perm(tdbb, trigger_name))
			{
				gds__msg_format(NULL, JRD_BUGCHK, 304, sizeof(errmsg),
								errmsg, trigger_name, NULL, NULL,
								NULL, NULL);
				ERR_log(JRD_BUGCHK, 304, errmsg);

				trig_flags &= ~TRG_ignore_perm;
			}

			// dimitr: support for the universal triggers
			int trigger_action, slot_index = 0;
			while ((trigger_action = TRIGGER_ACTION_SLOT(TRG.RDB$TRIGGER_TYPE, ++slot_index)) > 0)
			{
				get_trigger(tdbb,
							relation,
							&TRG.RDB$TRIGGER_BLR,
							triggers + trigger_action,
							TRG.RDB$TRIGGER_NAME,
							(bool) TRG.RDB$SYSTEM_FLAG,
							trig_flags);
			}
		}
	END_FOR;

	if (!REQUEST(irq_s_triggers))
		REQUEST(irq_s_triggers) = trigger_request;
}



void MET_lookup_cnstrt_for_index(thread_db* tdbb,
								TEXT* constraint_name,
								const TEXT* index_name)
{
/**************************************
 *
 *      M E T _ l o o k u p _ c n s t r t _ f o r _ i n d e x
 *
 **************************************
 *
 * Functional description
 *      Lookup  constraint name from index name, if one exists.
 *      Calling routine must pass a buffer of at least 32 bytes.
 *
 **************************************/
	SET_TDBB(tdbb);
	Database* dbb = tdbb->tdbb_database;

	constraint_name[0] = 0;
	jrd_req* request = CMP_find_request(tdbb, irq_l_cnstrt, IRQ_REQUESTS);

	FOR(REQUEST_HANDLE request)
		X IN RDB$RELATION_CONSTRAINTS WITH X.RDB$INDEX_NAME EQ index_name

        if (!REQUEST(irq_l_cnstrt))
            REQUEST(irq_l_cnstrt) = request;

		fb_utils::exact_name(X.RDB$CONSTRAINT_NAME);
		strcpy(constraint_name, X.RDB$CONSTRAINT_NAME);

	END_FOR;

	if (!REQUEST(irq_l_cnstrt))
		REQUEST(irq_l_cnstrt) = request;
}


void MET_lookup_cnstrt_for_trigger(
								   thread_db* tdbb,
								   TEXT* constraint_name,
								   TEXT* relation_name,
								   const TEXT* trigger_name)
{
/**************************************
 *
 *      M E T _ l o o k u p _ c n s t r t _ f o r _ t r i g g e r 
 *
 **************************************
 *
 * Functional description
 *      Lookup  constraint name from trigger name, if one exists.
 *      Calling routine must pass a buffer of at least 32 bytes.
 *
 **************************************/
	SET_TDBB(tdbb);
	Database* dbb = tdbb->tdbb_database;

	constraint_name[0] = 0;
	relation_name[0] = 0;
	jrd_req* request = CMP_find_request(tdbb, irq_l_check, IRQ_REQUESTS);
	jrd_req* request2 = CMP_find_request(tdbb, irq_l_check2, IRQ_REQUESTS);

/* utilize two requests rather than one so that we 
   guarantee we always return the name of the relation
   that the trigger is defined on, even if we don't 
   have a check constraint defined for that trigger */

	FOR(REQUEST_HANDLE request)
		Y IN RDB$TRIGGERS WITH
			Y.RDB$TRIGGER_NAME EQ trigger_name

        if (!REQUEST(irq_l_check))
			REQUEST(irq_l_check) = request;

		FOR(REQUEST_HANDLE request2)
			X IN RDB$CHECK_CONSTRAINTS WITH
				X.RDB$TRIGGER_NAME EQ Y.RDB$TRIGGER_NAME

            if (!REQUEST(irq_l_check2))
				REQUEST(irq_l_check2) = request2;

			fb_utils::exact_name(X.RDB$CONSTRAINT_NAME);
			strcpy(constraint_name, X.RDB$CONSTRAINT_NAME);

		END_FOR;

		if (!REQUEST(irq_l_check2))
			REQUEST(irq_l_check2) = request2;

		fb_utils::exact_name(Y.RDB$RELATION_NAME);
		strcpy(relation_name, Y.RDB$RELATION_NAME);

	END_FOR;

	if (!REQUEST(irq_l_check))
		REQUEST(irq_l_check) = request;
}


void MET_lookup_exception(thread_db*	tdbb,
						  SLONG	number,
						  TEXT*	name,
						  TEXT*	message)
{
/**************************************
 *
 *      M E T _ l o o k u p _ e x c e p t i o n
 *
 **************************************
 *
 * Functional description
 *      Lookup exception by number and return its name and message.
 *
 **************************************/
	SET_TDBB(tdbb);
	Database* dbb = tdbb->tdbb_database;

/* We need to look up exception in RDB$EXCEPTIONS */

	jrd_req* request = CMP_find_request(tdbb, irq_l_exception, IRQ_REQUESTS);

	*name = 0;
	if (message)
	{
		*message = 0;
	}

	FOR(REQUEST_HANDLE request)
		X IN RDB$EXCEPTIONS WITH X.RDB$EXCEPTION_NUMBER = number

        if (!REQUEST(irq_l_exception))
		{
			REQUEST(irq_l_exception) = request;
		}

		if (!X.RDB$EXCEPTION_NAME.NULL)
		{
			name_copy(name, X.RDB$EXCEPTION_NAME);
		}
		if (!X.RDB$MESSAGE.NULL && message)
		{
			name_copy(message, X.RDB$MESSAGE);
		}
	END_FOR;

	if (!REQUEST(irq_l_exception))
	{
		REQUEST(irq_l_exception) = request;
	}
}


SLONG MET_lookup_exception_number(thread_db* tdbb, const TEXT* name)
{
/**************************************
 *
 *      M E T _ l o o k u p _ e x c e p t i o n _ n u m b e r
 *
 **************************************
 *
 * Functional description
 *      Lookup exception by name and return its number.
 *
 **************************************/
	SET_TDBB(tdbb);
	Database* dbb = tdbb->tdbb_database;

/* We need to look up exception in RDB$EXCEPTIONS */

	jrd_req* request = CMP_find_request(tdbb, irq_l_except_no, IRQ_REQUESTS);

	SLONG number = 0;

	FOR(REQUEST_HANDLE request)
		X IN RDB$EXCEPTIONS WITH X.RDB$EXCEPTION_NAME = name

        if (!REQUEST(irq_l_except_no))
			REQUEST(irq_l_except_no) = request;

		number = X.RDB$EXCEPTION_NUMBER;

	END_FOR;

	if (!REQUEST(irq_l_except_no))
		REQUEST(irq_l_except_no) = request;

	return number;
}


int MET_lookup_field(thread_db* tdbb, jrd_rel* relation, const TEXT* name,
	const TEXT* security_name)
{
/**************************************
 *
 *      M E T _ l o o k u p _ f i e l d
 *
 **************************************
 *
 * Functional description
 *      Look up a field name.
 *	Additinally, if security_name is a not null pointer,
 *	it's used to include the condition that it should match
 *	the field's security class name, too.
 *
 *	if the field is not found return -1
 *
 *****************************************/
	SET_TDBB(tdbb);
	Database* dbb = tdbb->tdbb_database;

/* Start by checking field names that we already know */
	vec* vector = relation->rel_fields;

	if (vector)
	{
		const UCHAR length = strlen(name);
		USHORT id = 0;
		vec::iterator fieldIter = vector->begin();

		for (const vec::const_iterator end = vector->end();  fieldIter < end; fieldIter++, id++)
		{
			if (*fieldIter) 
			{
				jrd_fld* field = static_cast<jrd_fld*>(*fieldIter);
				if (field->fld_length == length && strcmp (field->fld_name, name) == 0)
				{
					if (!security_name) 
						return id;
					const size_t nl2 = fb_utils::name_length(security_name);
					if (field->fld_security_name) 
					{
						const size_t nl = fb_utils::name_length(field->fld_security_name);
						if (nl == nl2 && !strncmp(field->fld_security_name, security_name, nl)) 
							return id;
					}
				}
			}
		}
	}

/* Not found.  Next, try system relations directly */

	USHORT id = (USHORT) -1;

	if (!relation->rel_name)
	{
		return id;
	}

	jrd_req* request = CMP_find_request(tdbb, irq_l_field, IRQ_REQUESTS);

	FOR(REQUEST_HANDLE request)
		X IN RDB$RELATION_FIELDS WITH
			X.RDB$RELATION_NAME EQ relation->rel_name AND
			X.RDB$FIELD_NAME EQ name 

        if (!REQUEST(irq_l_field)) {
            REQUEST(irq_l_field) = request;
		}

        if (!security_name) {
            id = X.RDB$FIELD_ID;
        }
        else {
            USHORT nl;
            const USHORT nl2 = fb_utils::name_length(security_name);
            if (!X.RDB$SECURITY_CLASS.NULL
                && (nl = fb_utils::name_length(X.RDB$SECURITY_CLASS)) == nl2
                && !strncmp (X.RDB$SECURITY_CLASS, security_name, nl))
			{
                id = X.RDB$FIELD_ID;
            }
        }

	END_FOR;

	if (!REQUEST(irq_l_field)) {
		REQUEST(irq_l_field) = request;
	}

	return id;
}


BlobFilter* MET_lookup_filter(thread_db* tdbb, SSHORT from, SSHORT to)
{
/**************************************
 *
 *      M E T _ l o o k u p _ f i l t e r
 *
 **************************************
 *
 * Functional description
 *
 **************************************/
	SET_TDBB(tdbb);
	Database* dbb = tdbb->tdbb_database;

	FPTR_BFILTER_CALLBACK filter = NULL;
	BlobFilter* blf = NULL;

	jrd_req* request = CMP_find_request(tdbb, irq_r_filters, IRQ_REQUESTS);

	FOR(REQUEST_HANDLE request)
		X IN RDB$FILTERS WITH X.RDB$INPUT_SUB_TYPE EQ from AND
        X.RDB$OUTPUT_SUB_TYPE EQ to 

        if (!REQUEST(irq_r_filters))
            REQUEST(irq_r_filters) = request;
		filter = (FPTR_BFILTER_CALLBACK)
			Module::lookup(X.RDB$MODULE_NAME, X.RDB$ENTRYPOINT, dbb->modules);
		if (filter)
		{
			blf = FB_NEW(*dbb->dbb_permanent) BlobFilter(*dbb->dbb_permanent);
			blf->blf_next = NULL;
			blf->blf_from = from;
			blf->blf_to = to;
			blf->blf_filter = filter;
			blf->blf_exception_message.printf(EXCEPTION_MESSAGE,
					X.RDB$FUNCTION_NAME, X.RDB$ENTRYPOINT, X.RDB$MODULE_NAME);
		}
	END_FOR;

	if (!REQUEST(irq_r_filters))
		REQUEST(irq_r_filters) = request;

	return blf;
}


SLONG MET_lookup_generator(thread_db* tdbb, const TEXT* name)
{
/**************************************
 *
 *      M E T _ l o o k u p _ g e n e r a t o r
 *
 **************************************
 *
 * Functional description
 *      Lookup generator (aka gen_id).  If we can't find it, make a new one.
 * CVC: I don't see how this function "makes" a new generator; it simply
 *		returns -1 if the name is not found.
 *
 **************************************/
	SET_TDBB(tdbb);
	Database* dbb = tdbb->tdbb_database;

	if (!strcmp(name, "RDB$GENERATORS"))
		return 0;

	SLONG gen_id = -1;

	jrd_req* request = CMP_find_request(tdbb, irq_r_gen_id, IRQ_REQUESTS);

	FOR(REQUEST_HANDLE request)
		X IN RDB$GENERATORS WITH X.RDB$GENERATOR_NAME EQ name

        if (!REQUEST(irq_r_gen_id))
			REQUEST(irq_r_gen_id) = request;

		gen_id = X.RDB$GENERATOR_ID;
	END_FOR;

	if (!REQUEST(irq_r_gen_id))
		REQUEST(irq_r_gen_id) = request;

	return gen_id;
}

void MET_lookup_generator_id (thread_db* tdbb, SLONG gen_id, TEXT* name)
{
/**************************************
 *
 *      M E T _ l o o k u p _ g e n e r a t o r _ i d
 *
 **************************************
 *
 * Functional description
 *      Lookup generator (aka gen_id) by ID. It will load
 *		the name in the third parameter.
 *
 **************************************/
    SET_TDBB (tdbb);
    Database* dbb  = tdbb->tdbb_database;
    
    if (!gen_id) {
        strcpy (name, "RDB$GENERATORS");
        return;
    }

    *name = 0;
    
	jrd_req* request = CMP_find_request (tdbb, irq_r_gen_id_num, IRQ_REQUESTS);
    
    FOR (REQUEST_HANDLE request)
        X IN RDB$GENERATORS WITH X.RDB$GENERATOR_ID EQ gen_id

        if (!REQUEST (irq_r_gen_id_num))
            REQUEST (irq_r_gen_id_num) = request;
	    name_copy (name, X.RDB$GENERATOR_NAME);
    END_FOR;

    if (!REQUEST (irq_r_gen_id_num))
        REQUEST (irq_r_gen_id_num) = request;
}

void MET_lookup_index(thread_db* tdbb,
						TEXT* index_name,
						const TEXT* relation_name,
						USHORT number)
{
/**************************************
 *
 *      M E T _ l o o k u p _ i n d e x
 *
 **************************************
 *
 * Functional description
 *      Lookup index name from relation and index number.
 *      Calling routine must pass a buffer of at least 32 bytes.
 *
 **************************************/
	SET_TDBB(tdbb);
	Database* dbb = tdbb->tdbb_database;

	index_name[0] = 0;

	jrd_req* request = CMP_find_request(tdbb, irq_l_index, IRQ_REQUESTS);

	FOR(REQUEST_HANDLE request)
		X IN RDB$INDICES WITH X.RDB$RELATION_NAME EQ relation_name
			AND X.RDB$INDEX_ID EQ number 

        if (!REQUEST(irq_l_index))
            REQUEST(irq_l_index) = request;

		fb_utils::exact_name(X.RDB$INDEX_NAME);
		strcpy(index_name, X.RDB$INDEX_NAME);

	END_FOR;

	if (!REQUEST(irq_l_index))
		REQUEST(irq_l_index) = request;
}


SLONG MET_lookup_index_name(thread_db* tdbb,
							const Firebird::string& index_name,
							SLONG* relation_id, SSHORT* status)
{
/**************************************
 *
 *      M E T _ l o o k u p _ i n d e x _ n a m e
 *
 **************************************
 *
 * Functional description
 *      Lookup index id from index name.
 *
 **************************************/
	SLONG id = -1;

	SET_TDBB(tdbb);
	Database* dbb = tdbb->tdbb_database;

	jrd_req* request = CMP_find_request(tdbb, irq_l_index_name, IRQ_REQUESTS);

	*status = MET_object_unknown;

	FOR(REQUEST_HANDLE request)
		X IN RDB$INDICES WITH
			X.RDB$INDEX_NAME EQ index_name.c_str()

        if (!REQUEST(irq_l_index_name))
            REQUEST(irq_l_index_name) = request;

		if (X.RDB$INDEX_INACTIVE == 0) {
			*status = MET_object_active;
		}
		else {
			*status = MET_object_inactive;
		}

		id = X.RDB$INDEX_ID - 1;
		const jrd_rel* relation = MET_lookup_relation(tdbb, X.RDB$RELATION_NAME);
		*relation_id = relation->rel_id;

	END_FOR;

	if (!REQUEST(irq_l_index_name))
		REQUEST(irq_l_index_name) = request;

	return id;
}


bool MET_lookup_partner(
					   thread_db* tdbb, jrd_rel* relation, index_desc* idx,
					   const TEXT* index_name)
{
/**************************************
 *
 *      M E T _ l o o k u p _ p a r t n e r
 *
 **************************************
 *
 * Functional description
 *      Find partner index participating in a
 *      foreign key relationship.
 *
 **************************************/

	SET_TDBB(tdbb);
	Database* dbb = tdbb->tdbb_database;

	if (relation->rel_flags & REL_check_partners)
	{
		/* Prepare for rescan of foreign references on other relations'
		   primary keys and release stale vectors. */

		jrd_req* request = CMP_find_request(tdbb, irq_foreign1, IRQ_REQUESTS);
		frgn* references = &relation->rel_foreign_refs;
		int index_number = 0;

		if (references->frgn_reference_ids) {
			delete references->frgn_reference_ids;
			references->frgn_reference_ids = NULL;
		}
		if (references->frgn_relations) {
			delete references->frgn_relations;
			references->frgn_relations = NULL;
		}
		if (references->frgn_indexes) {
			delete references->frgn_indexes;
			references->frgn_indexes = NULL;
		}

		FOR(REQUEST_HANDLE request)
			IDX IN RDB$INDICES CROSS
				RC IN RDB$RELATION_CONSTRAINTS
				OVER RDB$INDEX_NAME CROSS
				IND IN RDB$INDICES WITH
				RC.RDB$CONSTRAINT_TYPE EQ FOREIGN_KEY AND
				IDX.RDB$RELATION_NAME EQ relation->rel_name AND
				IND.RDB$INDEX_NAME EQ IDX.RDB$FOREIGN_KEY AND
				IND.RDB$UNIQUE_FLAG NOT MISSING 

            if (!REQUEST(irq_foreign1))
			{
                REQUEST(irq_foreign1) = request;
			}

			const jrd_rel* partner_relation =
				MET_lookup_relation(tdbb, IND.RDB$RELATION_NAME);

			if (partner_relation)
			{
				references->frgn_reference_ids =
					vec::newVector(*dbb->dbb_permanent, references->frgn_reference_ids,
								   index_number + 1);

				(*references->frgn_reference_ids)[index_number] =
					(BLK)(IPTR)(IDX.RDB$INDEX_ID - 1);

				references->frgn_relations =
					vec::newVector(*dbb->dbb_permanent, references->frgn_relations,
								   index_number + 1);

				(*references->frgn_relations)[index_number] =
					(BLK) (IPTR) partner_relation->rel_id;

				references->frgn_indexes = 
					vec::newVector(*dbb->dbb_permanent, references->frgn_indexes,
								   index_number + 1);

				(*references->frgn_indexes)[index_number] =
					(BLK) (IPTR) (IND.RDB$INDEX_ID - 1);

				index_number++;
			}
		END_FOR;

		if (!REQUEST(irq_foreign1))
		{
			REQUEST(irq_foreign1) = request;
		}

		/* Prepare for rescan of primary dependencies on relation's primary
		   key and stale vectors. */

		request = CMP_find_request(tdbb, irq_foreign2, IRQ_REQUESTS);
		prim* dependencies = &relation->rel_primary_dpnds;
		index_number = 0;

		if (dependencies->prim_reference_ids) {
			delete dependencies->prim_reference_ids;
			dependencies->prim_reference_ids = NULL;
		}
		if (dependencies->prim_relations) {
			delete dependencies->prim_relations;
			dependencies->prim_relations = NULL;
		}
		if (dependencies->prim_indexes) {
			delete dependencies->prim_indexes;
			dependencies->prim_indexes = NULL;
		}

/*
** ============================================================
** ==
** == since UNIQUE constraint also could be used as primary key
** == therefore we change:
** ==
** ==    IDX.RDB$INDEX_NAME STARTING WITH "RDB$PRIMARY"
** ==
** == to
** ==
** ==    IDX.RDB$UNIQUE_FLAG = 1
** ==
** ============================================================
*/

		FOR(REQUEST_HANDLE request)
			IDX IN RDB$INDICES CROSS
				IND IN RDB$INDICES WITH
				IDX.RDB$UNIQUE_FLAG = 1 AND
				IDX.RDB$RELATION_NAME EQ relation->rel_name AND
				IND.RDB$FOREIGN_KEY EQ IDX.RDB$INDEX_NAME

			if (!REQUEST(irq_foreign2)) {
				REQUEST(irq_foreign2) = request;
			}
			const jrd_rel* partner_relation =
				MET_lookup_relation(tdbb, IND.RDB$RELATION_NAME);
			if (partner_relation)
			{
				dependencies->prim_reference_ids =
					vec::newVector(*dbb->dbb_permanent, dependencies->prim_reference_ids,
								   index_number + 1);

				(*dependencies->prim_reference_ids)[index_number] =
					(BLK) (IPTR) (IDX.RDB$INDEX_ID - 1);

				dependencies->prim_relations = 
					vec::newVector(*dbb->dbb_permanent, dependencies->prim_relations,
								   index_number + 1);

				(*dependencies->prim_relations)[index_number] =
					(BLK) (IPTR) partner_relation->rel_id;

				dependencies->prim_indexes =
					vec::newVector(*dbb->dbb_permanent, dependencies->prim_indexes,
								   index_number + 1);

				(*dependencies->prim_indexes)[index_number] =
					(BLK) (IPTR) (IND.RDB$INDEX_ID - 1);

				index_number++;
			}
		END_FOR;

		if (!REQUEST(irq_foreign2))
			REQUEST(irq_foreign2) = request;

		relation->rel_flags &= ~REL_check_partners;
	}

	if (idx->idx_flags & idx_foreign)
	{
		if (*index_name)
		{
			/* Since primary key index names aren't being cached, do a long
			   hard lookup. This is only called during index create for foreign
			   keys. */

			bool found = false;
			jrd_req* request = NULL;

			FOR(REQUEST_HANDLE request)
				IDX IN RDB$INDICES CROSS
					IND IN RDB$INDICES WITH
					IDX.RDB$RELATION_NAME EQ relation->rel_name AND
					(IDX.RDB$INDEX_ID EQ idx->idx_id + 1 OR
					 IDX.RDB$INDEX_NAME EQ index_name) AND
					IND.RDB$INDEX_NAME EQ IDX.RDB$FOREIGN_KEY AND
					IND.RDB$UNIQUE_FLAG NOT MISSING

				const jrd_rel* partner_relation =
					MET_lookup_relation(tdbb, IND.RDB$RELATION_NAME);

                if (partner_relation)
				{
					idx->idx_primary_relation = partner_relation->rel_id;
					idx->idx_primary_index = IND.RDB$INDEX_ID - 1;
					found = true;
				}
			END_FOR;

			CMP_release(tdbb, request);
			return found;
		}

		frgn* references = &relation->rel_foreign_refs;
		if (references->frgn_reference_ids)
		{
			for (int index_number = 0;
				 index_number < (int) references->frgn_reference_ids->count();
				 index_number++)
			{
				if (idx->idx_id == (UCHAR)(IPTR) (*references->frgn_reference_ids)
											[index_number])
				{
					idx->idx_primary_relation =
						(USHORT)(IPTR) (*references->frgn_relations)[index_number];
					idx->idx_primary_index =
						(UCHAR)(IPTR) (*references->frgn_indexes)[index_number];
					return true;
				}
			}
		}
		return false;
	}
	else if (idx->idx_flags & (idx_primary | idx_unique))
	{
		const prim* dependencies = &relation->rel_primary_dpnds;
		if (dependencies->prim_reference_ids)
		{
			for (int index_number = 0;
				 index_number < (int) dependencies->prim_reference_ids->count();
				 index_number++)
			{
				if (idx->idx_id == (UCHAR)(IPTR) (*dependencies->prim_reference_ids)
											[index_number])
				{
					idx->idx_foreign_primaries =
						relation->rel_primary_dpnds.prim_reference_ids;
					idx->idx_foreign_relations =
						relation->rel_primary_dpnds.prim_relations;
					idx->idx_foreign_indexes =
						relation->rel_primary_dpnds.prim_indexes;
					return true;
				}
			}
		}
		return false;
	}

	return false;
}


jrd_prc* MET_lookup_procedure(thread_db* tdbb, const Firebird::string& name, bool noscan)
{
/**************************************
 *
 *      M E T _ l o o k u p _ p r o c e d u r e
 *
 **************************************
 *
 * Functional description
 *      Lookup procedure by name.  Name passed in is
 *      ASCIZ name.
 *
 **************************************/
	SET_TDBB(tdbb);
	Database* dbb = tdbb->tdbb_database;
	jrd_prc* check_procedure = NULL;

/* See if we already know the procedure by name */
	vec* procedures = dbb->dbb_procedures;
	if (procedures) {
        vec::iterator ptr = procedures->begin();
		for (const vec::const_iterator end = procedures->end();
					ptr < end; ptr++) 
		{
			jrd_prc* procedure = (jrd_prc*)(*ptr);
			if (procedure && !(procedure->prc_flags & PRC_obsolete)
				&& ((procedure->prc_flags & PRC_scanned) || noscan)
				&& !(procedure->prc_flags & PRC_being_scanned)
				&& !(procedure->prc_flags & PRC_being_altered))
			{
				if (procedure->prc_name == name) 
				{
					if (procedure->prc_flags & PRC_check_existence) 
					{
						check_procedure = procedure;
						LCK_lock(tdbb, check_procedure->prc_existence_lock,
							LCK_SR, LCK_WAIT);
						break;
					}
					else {
						return procedure;
					}
  				}
			}
		}
	}

/* We need to look up the procedure name in RDB$PROCEDURES */

	jrd_prc* procedure = NULL;

	jrd_req* request = CMP_find_request(tdbb, irq_l_procedure, IRQ_REQUESTS);

	FOR(REQUEST_HANDLE request)
		P IN RDB$PROCEDURES WITH P.RDB$PROCEDURE_NAME EQ name.c_str()

        if (!REQUEST(irq_l_procedure)) 
            REQUEST(irq_l_procedure) = request;

        procedure = MET_procedure(tdbb, P.RDB$PROCEDURE_ID, noscan, 0);

	END_FOR;

	if (!REQUEST(irq_l_procedure))
		REQUEST(irq_l_procedure) = request;

	if (check_procedure) {
		check_procedure->prc_flags &= ~PRC_check_existence;
		if (check_procedure != procedure) {
			LCK_release(tdbb, check_procedure->prc_existence_lock);
			check_procedure->prc_flags |= PRC_obsolete;
		}
	}

	return procedure;
}


jrd_prc* MET_lookup_procedure_id(thread_db* tdbb, SSHORT id,
							bool return_deleted, bool noscan, USHORT flags)
{
/**************************************
 *
 *      M E T _ l o o k u p _ p r o c e d u r e _ i d
 *
 **************************************
 *
 * Functional description
 *      Lookup procedure by id.
 *
 **************************************/
	SET_TDBB(tdbb);
	Database* dbb = tdbb->tdbb_database;
	jrd_prc* check_procedure = NULL;

	jrd_prc* procedure;
	
	vec* procedures = dbb->dbb_procedures;
	if (procedures
		&& id < (SSHORT) procedures->count()
	    && (procedure = (jrd_prc*)(*procedures)[id])
		&& procedure->prc_id == id
		&& !(procedure->prc_flags & PRC_being_scanned)
		&& ((procedure->prc_flags & PRC_scanned) || noscan)
		&& !(procedure->prc_flags & PRC_being_altered)
		&& (!(procedure->prc_flags & PRC_obsolete) || return_deleted))
	{
		if (procedure->prc_flags & PRC_check_existence) {
			check_procedure = procedure;
			LCK_lock(tdbb, check_procedure->prc_existence_lock, LCK_SR, LCK_WAIT);
		}
		else {
			return procedure;
		}
	}

/* We need to look up the procedure name in RDB$PROCEDURES */

	procedure = NULL;

	jrd_req* request = CMP_find_request(tdbb, irq_l_proc_id, IRQ_REQUESTS);

	FOR(REQUEST_HANDLE request)
		P IN RDB$PROCEDURES WITH P.RDB$PROCEDURE_ID EQ id

        if (!REQUEST(irq_l_proc_id)) 
            REQUEST(irq_l_proc_id) = request;

		procedure = MET_procedure(tdbb, P.RDB$PROCEDURE_ID, noscan, flags);

	END_FOR;

	if (!REQUEST(irq_l_proc_id))
		REQUEST(irq_l_proc_id) = request;

	if (check_procedure) {
		check_procedure->prc_flags &= ~PRC_check_existence;
		if (check_procedure != procedure) {
			LCK_release(tdbb, check_procedure->prc_existence_lock);
			check_procedure->prc_flags |= PRC_obsolete;
		}
	}

	return procedure;
}


jrd_rel* MET_lookup_relation(thread_db* tdbb, const char* name)
{
/**************************************
 *
 *      M E T _ l o o k u p _ r e l a t i o n
 *
 **************************************
 *
 * Functional description
 *      Lookup relation by name.  Name passed in is
 *      ASCIZ name.
 *
 **************************************/
	SET_TDBB(tdbb);
	Database* dbb = tdbb->tdbb_database;

/* See if we already know the relation by name */

	vec* relations = dbb->dbb_relations;
	jrd_rel* check_relation = NULL;
	const UCHAR length = strlen(name);

	vec::iterator ptr = relations->begin();
	for (const vec::const_iterator end = relations->end(); ptr < end; ptr++)
	{
		const SCHAR* p;
		jrd_rel* relation = static_cast<jrd_rel*>(*ptr);
		if (relation &&
			(relation->rel_length == length) &&
			(!(relation->rel_flags & REL_deleted)) &&
			(p = relation->rel_name))
		{
			/* dimitr: for non-system relations we should also check
					   REL_scanned and REL_being_scanned flags. Look
					   at MET_lookup_procedure for example. */
			if (!(relation->rel_flags & REL_system) &&
				(!(relation->rel_flags & REL_scanned) ||
				(relation->rel_flags & REL_being_scanned)))
			{
				continue;
			}

			for (const SCHAR* q = name; *p == *q; p++, q++)
			{
				if (*p == 0)
				{
					if (relation->rel_flags & REL_check_existence)
					{
						check_relation = relation;
						LCK_lock(tdbb, check_relation->rel_existence_lock,
								 LCK_SR, LCK_WAIT);
						break;
					}
					else
					{
						return relation;
					}
				}
			}
		}
		if (check_relation)
		{
			break;
		}
	}

/* We need to look up the relation name in RDB$RELATIONS */

	jrd_rel* relation = NULL;

	jrd_req* request = CMP_find_request(tdbb, irq_l_relation, IRQ_REQUESTS);

	FOR(REQUEST_HANDLE request)
		X IN RDB$RELATIONS WITH X.RDB$RELATION_NAME EQ name

        if (!REQUEST(irq_l_relation))
		{
			REQUEST(irq_l_relation) = request;
		}

		relation = MET_relation(tdbb, X.RDB$RELATION_ID);
		if (!relation->rel_name)
		{
			relation->rel_name = MET_save_name(tdbb, name);
			relation->rel_length = strlen(relation->rel_name);
		}
	END_FOR;

	if (!REQUEST(irq_l_relation))
	{
		REQUEST(irq_l_relation) = request;
	}

	if (check_relation) {
		check_relation->rel_flags &= ~REL_check_existence;
		if (check_relation != relation) {
			LCK_release(tdbb, check_relation->rel_existence_lock);
			check_relation->rel_flags |= REL_deleted;
		}
	}

	return relation;
}


jrd_rel* MET_lookup_relation_id(thread_db* tdbb, SLONG id, bool return_deleted)
{
/**************************************
 *
 *      M E T _ l o o k u p _ r e l a t i o n _ i d
 *
 **************************************
 *
 * Functional description
 *      Lookup relation by id. Make sure it really exists.
 *
 **************************************/
	SET_TDBB(tdbb);
	Database* dbb = tdbb->tdbb_database;

/* System relations are above suspicion */

	if (id < (int) rel_MAX)
	{
		fb_assert(id < MAX_USHORT);
		return MET_relation(tdbb, (USHORT) id);
	}

	jrd_rel* check_relation = NULL;
	jrd_rel* relation;
	vec* vector = dbb->dbb_relations;
	if (vector &&
		(id < (SLONG) vector->count()) && (relation = (jrd_rel*) (*vector)[id]))
	{
		if (relation->rel_flags & REL_deleted)
		{
			if (return_deleted)
				return relation;
			return NULL;
		}
		else if (relation->rel_flags & REL_check_existence)
		{
			check_relation = relation;
			LCK_lock(tdbb, check_relation->rel_existence_lock, LCK_SR, LCK_WAIT);
		}
		else
		{
			return relation;
		}
	}

/* We need to look up the relation id in RDB$RELATIONS */

	relation = NULL;

	jrd_req* request = CMP_find_request(tdbb, irq_l_rel_id, IRQ_REQUESTS);

	FOR(REQUEST_HANDLE request)
		X IN RDB$RELATIONS WITH X.RDB$RELATION_ID EQ id

        if (!REQUEST(irq_l_rel_id))
			REQUEST(irq_l_rel_id) = request;
		relation = MET_relation(tdbb, X.RDB$RELATION_ID);
		if (!relation->rel_name) {
			relation->rel_name = MET_save_name(tdbb, X.RDB$RELATION_NAME);
			relation->rel_length = strlen(relation->rel_name);
		}
	END_FOR;

	if (!REQUEST(irq_l_rel_id))
		REQUEST(irq_l_rel_id) = request;

	if (check_relation) {
		check_relation->rel_flags &= ~REL_check_existence;
		if (check_relation != relation) {
			LCK_release(tdbb, check_relation->rel_existence_lock);
			check_relation->rel_flags |= REL_deleted;
		}
	}

	return relation;
}


jrd_nod* MET_parse_blob(thread_db*	tdbb,
				   jrd_rel*		relation,
				   bid*			blob_id,
				   CompilerScratch**		csb_ptr,
				   jrd_req**	request_ptr,
				   const bool	trigger,
				   const bool	ignore_perm)
{
/**************************************
 *
 *      M E T _ p a r s e _ b l o b
 *
 **************************************
 *
 * Functional description
 *      Parse blr, returning a compiler scratch block with the results.
 *
 * if ignore_perm is true then, the request generated must be set to
 *   ignore all permissions checks. In this case, we call PAR_blr
 *   passing it the csb_ignore_perm flag to generate a request
 *   which must go through without checking any permissions.
 *
 **************************************/
	SET_TDBB(tdbb);
	Database* dbb = tdbb->tdbb_database;

	blb* blob = BLB_open(tdbb, dbb->dbb_sys_trans, blob_id);
	const SLONG length = blob->blb_length + 10;
	str* temp = FB_NEW_RPT(*tdbb->getDefaultPool(), length) str();
	BLB_get_data(tdbb, blob, temp->str_data, length);

	jrd_nod* node = PAR_blr(tdbb, relation, temp->str_data, NULL, csb_ptr, request_ptr,
					trigger, (USHORT)(ignore_perm ? csb_ignore_perm : 0));

	delete temp;

	return node;
}


void MET_parse_sys_trigger(thread_db* tdbb, jrd_rel* relation)
{
/**************************************
 *
 *      M E T _ p a r s e _ s y s _ t r i g g e r
 *
 **************************************
 *
 * Functional description
 *      Parse the blr for a system relation's triggers.
 *
 **************************************/
	SET_TDBB(tdbb);
	Database* dbb = tdbb->tdbb_database;

	relation->rel_flags &= ~REL_sys_triggers;

/* release any triggers in case of a rescan */

	if (relation->rel_pre_store)
		MET_release_triggers(tdbb, &relation->rel_pre_store);
	if (relation->rel_post_store)
		MET_release_triggers(tdbb, &relation->rel_post_store);
	if (relation->rel_pre_erase)
		MET_release_triggers(tdbb, &relation->rel_pre_erase);
	if (relation->rel_post_erase)
		MET_release_triggers(tdbb, &relation->rel_post_erase);
	if (relation->rel_pre_modify)
		MET_release_triggers(tdbb, &relation->rel_pre_modify);
	if (relation->rel_post_modify)
		MET_release_triggers(tdbb, &relation->rel_post_modify);

/* No need to load triggers for ReadOnly databases, since
   INSERT/DELETE/UPDATE statements are not going to be allowed */

	if (dbb->dbb_flags & DBB_read_only)
	{
		return;
	}

	relation->rel_flags |= REL_sys_trigs_being_loaded;

	const jrd_trg* trigger = NULL;
	const UCHAR*	blr;
	UCHAR	type;
	const TEXT*	name;
	USHORT	trig_flags;
	jrd_req* request;
	
	while ( (trigger =
		   INI_lookup_sys_trigger(relation,
										trigger,
										&blr,
										&type,
										&name,
										&trig_flags)) )
	{
        trig_vec** ptr;
		switch (type) {
		case 1:
			ptr = &relation->rel_pre_store;
			break;
		case 2:
			ptr = &relation->rel_post_store;
			break;
		case 3:
			ptr = &relation->rel_pre_modify;
			break;
		case 4:
			ptr = &relation->rel_post_modify;
			break;
		case 5:
			ptr = &relation->rel_pre_erase;
			break;
		case 6:
			ptr = &relation->rel_post_erase;
			break;
		default:
			ptr = NULL;
			break;
		}

		if (ptr)
		{
			const USHORT par_flags = (USHORT)
				((trig_flags & TRG_ignore_perm) ? csb_ignore_perm : 0);

			{
				Jrd::ContextPoolHolder context(tdbb, JrdMemoryPool::createPool());
				PAR_blr(tdbb, relation, blr, NULL, NULL,
						&request, true, par_flags);
			}

			request->req_trg_name = name;

			request->req_flags |= req_sys_trigger;
			if (trig_flags & TRG_ignore_perm)
			{
				request->req_flags |= req_ignore_perm;
			}

			save_trigger_data(tdbb, ptr, relation, request, NULL, NULL, true, 0);
		}
	}

	relation->rel_flags &= ~REL_sys_trigs_being_loaded;
}


// Currently, nobody checks the result of this function, but let's keep it.
bool MET_post_existence( thread_db* tdbb, jrd_rel* relation)
{
/**************************************
 *
 *      M E T _ p o s t _ e x i s t e n c e
 *
 **************************************
 *
 * Functional description
 *      Post an interest in the existence of a relation.
 *
 **************************************/
	SET_TDBB(tdbb);

	if (++relation->rel_use_count == 1 &&
		!MET_lookup_relation_id(tdbb, relation->rel_id, false))
	{
		return false;
	}

	return true;
}


void MET_prepare( thread_db* tdbb, jrd_tra* transaction, USHORT length,
	const UCHAR* msg)
{
/**************************************
 *
 *      M E T _ p r e p a r e 
 *
 **************************************
 *
 * Functional description
 *      Post a transaction description to RDB$TRANSACTIONS.
 *
 **************************************/
	SET_TDBB(tdbb);
	Database* dbb = tdbb->tdbb_database;

	jrd_req* request = CMP_find_request(tdbb, irq_s_trans, IRQ_REQUESTS);

	STORE(REQUEST_HANDLE request) X IN RDB$TRANSACTIONS
		X.RDB$TRANSACTION_ID = transaction->tra_number;
		X.RDB$TRANSACTION_STATE =
			RDB$TRANSACTIONS.RDB$TRANSACTION_STATE.LIMBO;
		blb* blob =
			BLB_create(tdbb, dbb->dbb_sys_trans,
					   &X.RDB$TRANSACTION_DESCRIPTION);
		BLB_put_segment(tdbb, blob, msg, length);
		BLB_close(tdbb, blob);
	END_STORE;

	if (!REQUEST(irq_s_trans))
		REQUEST(irq_s_trans) = request;
}


jrd_prc* MET_procedure(thread_db* tdbb, int id, bool noscan, USHORT flags)
{
/**************************************
 *
 *      M E T _ p r o c e d u r e
 *
 **************************************
 *
 * Functional description
 *      Find or create a procedure block for a given procedure id.
 *
 **************************************/
	jrd_req* request;
	jrd_req* request2;
	vec::iterator ptr, end;
	jrd_nod* node;
	Format* format;
	Format::fmt_desc_iterator desc;

	SET_TDBB(tdbb);
	Database* dbb = tdbb->tdbb_database;

	vec* vector = dbb->dbb_procedures;
	if (!vector)
	{
		vector = dbb->dbb_procedures = vec::newVector(*dbb->dbb_permanent, id + 10);
	}
	else if (id >= (int) vector->count())
	{
		vector->resize(id + 10);
	}

#ifdef SUPERSERVER

	if (!(dbb->dbb_flags & DBB_sp_rec_mutex_init))
	{
		THD_rec_mutex_init(&dbb->dbb_sp_rec_mutex);
		dbb->dbb_flags |= DBB_sp_rec_mutex_init;
	}
	THREAD_EXIT();
	
	if (THD_rec_mutex_lock(&dbb->dbb_sp_rec_mutex))
	{
		THREAD_ENTER();
		return NULL;
	}
	
	THREAD_ENTER();

#endif /* SUPERSERVER */

	jrd_prc* procedure = (jrd_prc*) (*vector)[id];
	if (procedure)
	{
		/* Make sure PRC_being_scanned and PRC_scanned
		   are not set at the same time
		 */
		fb_assert(!(procedure->prc_flags & PRC_being_scanned) ||
			   !(procedure->prc_flags & PRC_scanned));

		/* To avoid scanning recursive procedure's blr recursively let's
		   make use of PRC_being_scanned bit. Because this bit is set
		   later in the code, it is not set when we are here first time.
		   If (in case of rec. procedure) we get here second time it is 
		   already set and we return half baked procedure.
		   In case of superserver this code is under the rec. mutex
		   protection, thus the only guy (thread) who can get here and see
		   PRC_being_scanned bit set is the guy which started procedure scan
		   and currently holds the mutex.
		   In case of classic, there is always only one guy and if it 
		   sees PRC_being_scanned bit set it is safe to assume it is here
		   second time.

		   If procedure has already been scanned - return. This condition
		   is for those threads that did not find procedure in cach and 
		   came here to get it from disk. But only one was able to lock
		   the mutex and do the scanning, others were waiting. As soon as
		   the first thread releases the mutex another thread gets in and
		   it would be just unfair to make it do the work again
		 */
		if ((procedure->prc_flags & PRC_being_scanned) ||
			(procedure->prc_flags & PRC_scanned))
		{

#ifdef SUPERSERVER
			THD_rec_mutex_unlock(&dbb->dbb_sp_rec_mutex);
#endif
			return procedure;
		}
	}

	if (!procedure)
	{
		procedure = FB_NEW_RPT(*dbb->dbb_permanent, 0) jrd_prc(*dbb->dbb_permanent);
	}

	try {

	procedure->prc_flags |= (PRC_being_scanned | flags);
	procedure->prc_flags &= ~PRC_obsolete;
	
	procedure->prc_id = id;
	(*vector)[id] = procedure;

	if (!procedure->prc_existence_lock) {
		Lock* lock = FB_NEW_RPT(*dbb->dbb_permanent, 0) Lock;
		procedure->prc_existence_lock = lock;
		lock->lck_parent = dbb->dbb_lock;
		lock->lck_dbb = dbb;
		lock->lck_key.lck_long = procedure->prc_id;
		lock->lck_length = sizeof(lock->lck_key.lck_long);
		lock->lck_type = LCK_prc_exist;
		lock->lck_owner_handle = LCK_get_owner_handle(tdbb, lock->lck_type);
		lock->lck_object = procedure;
		lock->lck_ast = blocking_ast_procedure;

		LCK_lock(tdbb, procedure->prc_existence_lock, LCK_SR, LCK_WAIT);
	}

	if (!noscan) {
		request = CMP_find_request(tdbb, irq_r_procedure, IRQ_REQUESTS);
		request2 = CMP_find_request(tdbb, irq_r_params, IRQ_REQUESTS);

		FOR(REQUEST_HANDLE request)
			P IN RDB$PROCEDURES WITH P.RDB$PROCEDURE_ID EQ procedure->prc_id

	        if (!REQUEST(irq_r_procedure))
			{
	            REQUEST(irq_r_procedure) = request;
			}

			if (procedure->prc_name.empty())
			{
				fb_utils::exact_name(P.RDB$PROCEDURE_NAME);
				procedure->prc_name = P.RDB$PROCEDURE_NAME;
			}
			procedure->prc_id = P.RDB$PROCEDURE_ID;
			if (!P.RDB$SECURITY_CLASS.NULL)
			{
				procedure->prc_security_name = P.RDB$SECURITY_CLASS;
			}
			if (P.RDB$SYSTEM_FLAG.NULL || !P.RDB$SYSTEM_FLAG)
			{
				procedure->prc_flags &= ~PRC_system;
			}
			else
			{
				procedure->prc_flags |= PRC_system;
			}
			if ( (procedure->prc_inputs = P.RDB$PROCEDURE_INPUTS) )
			{
				procedure->prc_input_fields =
					vec::newVector(*dbb->dbb_permanent, procedure->prc_input_fields,
								   P.RDB$PROCEDURE_INPUTS + 1);
			}
			if ( (procedure->prc_outputs = P.RDB$PROCEDURE_OUTPUTS) )
			{
				procedure->prc_output_fields =
					vec::newVector(*dbb->dbb_permanent, procedure->prc_output_fields,
								   P.RDB$PROCEDURE_OUTPUTS + 1);
			}

			procedure->prc_defaults = 0;
			FOR(REQUEST_HANDLE request2) PA IN RDB$PROCEDURE_PARAMETERS CROSS
				F IN RDB$FIELDS WITH F.RDB$FIELD_NAME = PA.RDB$FIELD_SOURCE
					AND PA.RDB$PROCEDURE_NAME = P.RDB$PROCEDURE_NAME

	            if (!REQUEST(irq_r_params))
				{
					REQUEST(irq_r_params) = request2;
				}

				if (PA.RDB$PARAMETER_TYPE) {
					vector = procedure->prc_output_fields;
				}
				else {
					vector = procedure->prc_input_fields;
				}

				/* should be error if field already exists */
				Parameter* parameter = 
					FB_NEW_RPT(*dbb->dbb_permanent, fb_utils::name_length(PA.RDB$PARAMETER_NAME))
					Parameter();
				parameter->prm_number = PA.RDB$PARAMETER_NUMBER;
				(*vector)[parameter->prm_number] = (BLK) parameter;
				name_copy(parameter->prm_string, PA.RDB$PARAMETER_NAME);
				DSC_make_descriptor(&parameter->prm_desc, F.RDB$FIELD_TYPE,
									F.RDB$FIELD_SCALE, F.RDB$FIELD_LENGTH,
									F.RDB$FIELD_SUB_TYPE, F.RDB$CHARACTER_SET_ID,
									F.RDB$COLLATION_ID);

				if ((PA.RDB$PARAMETER_TYPE == 0) && !F.RDB$DEFAULT_VALUE.NULL) 
				{
					procedure->prc_defaults++;
					Jrd::ContextPoolHolder context(tdbb, JrdMemoryPool::createPool());
					CompilerScratch* csb = CompilerScratch::newCsb(*tdbb->getDefaultPool(), 5);
					parameter->prm_default_val = 
						parse_param_blr(tdbb, procedure, &F.RDB$DEFAULT_VALUE, csb);
				
					delete csb;
				}

			END_FOR;

			if (!REQUEST(irq_r_params)) {
				REQUEST(irq_r_params) = request2;
			}

			if ((vector = procedure->prc_output_fields) && (*vector)[0])
			{
				ULONG length;
				format = procedure->prc_format =
					Format::newFormat(*dbb->dbb_permanent, procedure->prc_outputs);
				format->fmt_count = procedure->prc_outputs;
				length = FLAG_BYTES(format->fmt_count);
				desc = format->fmt_desc.begin();
				for (ptr = vector->begin(), end = vector->end();
					 ptr < end; ptr++, desc++)
				{
					Parameter* parameter = (Parameter*) * ptr;
					/* check for parameter to be null, this can only happen if the
					 * parameter numbers get out of sync. This was added to fix bug
					 * 10534. -Shaunak Mistry 12-May-99
					 */
					if (parameter)
					{
						*desc = parameter->prm_desc;
						length = MET_align(dbb, &(*desc), length);
						desc->dsc_address = (UCHAR *) (IPTR) length;
						length += desc->dsc_length;
					}
				}
				format->fmt_length = (USHORT) length;
			}

			{
				Jrd::ContextPoolHolder context(tdbb, JrdMemoryPool::createPool());
				CompilerScratch* csb = CompilerScratch::newCsb(*tdbb->getDefaultPool(), 5);
				// Now, check the result of this function here! Null pointer means failure.
				// Or should parse_procedure_blr and its callee throw exceptions instead?
				if (!parse_procedure_blr(tdbb, procedure, &P.RDB$PROCEDURE_BLR, csb))
					ERR_post(isc_random, isc_arg_string, "Error while parsing procedure's BLR.", 0);
				procedure->prc_request->req_procedure = procedure;
				for (size_t i = 0; i < csb->csb_rpt.getCount(); i++)
				{
					if ( (node = csb->csb_rpt[i].csb_message) )
					{
						if ((int) (IPTR) node->nod_arg[e_msg_number] == 0)
						{
							procedure->prc_input_msg = node;
						}
						else if ((int) (IPTR) node->nod_arg[e_msg_number] == 1)
						{
							procedure->prc_output_msg = node;
						}
					}
				}
				delete csb;
			}

		END_FOR;

		if (!REQUEST(irq_r_procedure)) {
			REQUEST(irq_r_procedure) = request;
		}

		procedure->prc_flags |= PRC_scanned;

	} /* if !noscan */
	
/* Make sure that it is really being Scanned ! */
	fb_assert(procedure->prc_flags & PRC_being_scanned);
	
	procedure->prc_flags &= ~PRC_being_scanned;

#ifdef SUPERSERVER
	THD_rec_mutex_unlock(&dbb->dbb_sp_rec_mutex);
#endif

	}	// try
	catch (const std::exception&) {
		procedure->prc_flags &= ~(PRC_being_scanned | PRC_scanned);
#ifdef SUPERSERVER
		THD_rec_mutex_unlock(&dbb->dbb_sp_rec_mutex);
#endif
		if (procedure->prc_existence_lock)
		{
			LCK_release(tdbb, procedure->prc_existence_lock);
			procedure->prc_existence_lock = NULL;
		}
		throw;
	}

	return procedure;
}


jrd_rel* MET_relation(thread_db* tdbb, USHORT id)
{
/**************************************
 *
 *      M E T _ r e l a t i o n
 *
 **************************************
 *
 * Functional description
 *      Find or create a relation block for a given relation id.
 *
 **************************************/
	SET_TDBB(tdbb);
	Database* dbb = tdbb->tdbb_database;
	CHECK_DBB(dbb);

	vec* vector = dbb->dbb_relations;

	if (!vector)
	{
		vector = dbb->dbb_relations = vec::newVector(*dbb->dbb_permanent, id + 10);
	}
	else if (id >= vector->count())
	{
		vector->resize(id + 10);
	}

	jrd_rel* relation = (jrd_rel*) (*vector)[id];
	if (relation) {
		return relation;
	}

	const USHORT major_version = dbb->dbb_ods_version;
	const USHORT minor_original = dbb->dbb_minor_original;

/* From ODS 9 onwards, the first 128 relation IDS have been 
   reserved for system relations */
	USHORT max_sys_rel;
	if (ENCODE_ODS(major_version, minor_original) < ODS_9_0) {
		max_sys_rel = USER_REL_INIT_ID_ODS8 - 1;
	}
	else {
		max_sys_rel = USER_DEF_REL_INIT_ID - 1;
	}

	relation = FB_NEW(*dbb->dbb_permanent) jrd_rel();
	(*vector)[id] = relation;
	relation->rel_id = id;

	// This should check system flag instead.
	if (relation->rel_id <= max_sys_rel) {
		return relation;
	}

	Lock* lock = FB_NEW_RPT(*dbb->dbb_permanent, 0) Lock;
	relation->rel_existence_lock = lock;
	lock->lck_parent = dbb->dbb_lock;
	lock->lck_dbb = dbb;
	lock->lck_key.lck_long = relation->rel_id;
	lock->lck_length = sizeof(lock->lck_key.lck_long);
	lock->lck_type = LCK_rel_exist;
	lock->lck_owner_handle = LCK_get_owner_handle(tdbb, lock->lck_type);
	lock->lck_object = relation;
	lock->lck_ast = blocking_ast_relation;

	relation->rel_flags |= (REL_check_existence | REL_check_partners);
	return relation;
}


bool MET_relation_owns_trigger (thread_db* tdbb, const TEXT* relation_name,
                                   const TEXT* trigger_name)
{
/**************************************
 *
 *      M E T _ r e l a t i o n _ o w n s _ t r i g g e r
 *
 **************************************
 *
 * Functional description
 *      Checks that a given trigger is defined for a
 *      given relation, returning TRUE if there's a match.
 *      It's almost a subset of MET_load_trigger().
 *
 **************************************/
    SET_TDBB (tdbb);
    Database* dbb = tdbb->tdbb_database;
    CHECK_DBB (dbb);

    /* No need to load triggers for ReadOnly databases,
       since INSERT/DELETE/UPDATE statements are not going to be allowed;
       but we do not care of this flag here. We do not load, we only check. */
    /*if (dbb->dbb_flags & DBB_read_only)
      return;*/

    /* Scan RDB$TRIGGERS next */

    bool found = false;
    /* CVC: Notice that we'll use the request irq_s_triggers2 that was found
       to be unused at this time. */

    jrd_req* trigger_request = CMP_find_request (tdbb, irq_s_triggers2, IRQ_REQUESTS);

    FOR (REQUEST_HANDLE trigger_request)
        TRG IN RDB$TRIGGERS WITH TRG.RDB$RELATION_NAME = relation_name AND
	    TRG.RDB$TRIGGER_NAME EQ trigger_name

        if (!REQUEST (irq_s_triggers2))
            REQUEST (irq_s_triggers2) = trigger_request;

        found = true;

        /* Notice we do not care whether the trigger is valid or not. We assume
           the caller wants to verify already validated entities.
           if (TRG.RDB$TRIGGER_TYPE > 0 && TRG.RDB$TRIGGER_TYPE < TRIGGER_MAX)
        */

    END_FOR;

    if (!REQUEST (irq_s_triggers2))
        REQUEST (irq_s_triggers2) = trigger_request;

    return found;
}

bool MET_relation_default_class (thread_db* tdbb, const TEXT* relation_name,
                                    const TEXT* default_security_class_name)
{
/**************************************
 *
 *      M E T _ r e l a t i o n _ d e f a u l t _ c l a s s
 *
 **************************************
 *
 * Functional description
 *      Checks that a given security class is the default for
 *      a given relation, returning TRUE if there's a match.
 *      It can be made obsolete in the future if jrd_rel struct
 *	gets another field, although metadata loading order
 *	would not be safe when compared with this function.
 *
 **************************************/
    SET_TDBB (tdbb);
    Database* dbb = tdbb->tdbb_database;
    CHECK_DBB (dbb);
    
	bool found = false;
    jrd_req* request = CMP_find_request (tdbb, irq_l_relation_defsec, IRQ_REQUESTS);
    
    FOR (REQUEST_HANDLE request)
        REL IN RDB$RELATIONS WITH REL.RDB$RELATION_NAME EQ relation_name

        if (!REQUEST (irq_l_relation_defsec))
            REQUEST (irq_l_relation_defsec) = request;

        if (!REL.RDB$DEFAULT_CLASS.NULL) {
            const USHORT nl = fb_utils::name_length(REL.RDB$DEFAULT_CLASS),
                nl2 = fb_utils::name_length(default_security_class_name);
            if (nl == nl2 &&
				!strncmp (REL.RDB$DEFAULT_CLASS, default_security_class_name, nl))
			{
                found = true;
            }
        }

    END_FOR;

    if (!REQUEST (irq_l_relation_defsec))
        REQUEST (irq_l_relation_defsec) = request;

    return found;
}


void MET_release_existence( jrd_rel* relation)
{
/**************************************
 *
 *      M E T _ r e l e a s e _ e x i s t e n c e
 *
 **************************************
 *
 * Functional description
 *      Release interest in relation. If no remaining interest
 *      and we're blocking the drop of the relation then release
 *      existence lock and mark deleted.
 *
 **************************************/
	if (relation->rel_use_count) {
		relation->rel_use_count--;
	}

	if (!relation->rel_use_count) {
		if (relation->rel_flags & REL_blocking) {
			LCK_re_post(relation->rel_existence_lock);
		}
	}
}


void MET_remove_procedure( thread_db* tdbb, int id, jrd_prc* procedure)
{
/**************************************
 *
 *      M E T _ r e m o v e  _ p r o c e d u r e
 *
 **************************************
 *
 * Functional description
 *      Remove a procedure from cache
 *
 **************************************/
	SET_TDBB(tdbb);
	Database* dbb = tdbb->tdbb_database;

	vec* vector = dbb->dbb_procedures;
	if (!vector) {
		return;
	}

	if (!procedure) {
	/** If we are in here then dfw.epp/modify_procedure() called us **/
		if (!(procedure = (jrd_prc*) (*vector)[id]))
			return;
	}
	
	/* MET_procedure locks it. Lets unlock it now to avoid troubles later */
	if (procedure->prc_existence_lock)
	{
		LCK_release(tdbb, procedure->prc_existence_lock);
	}

/* Procedure that is being altered may have references
   to it by other procedures via pointer to current meta
   data structure, so don't loose the structure or the pointer. */
	if ((procedure == (jrd_prc*) (*vector)[id]) &&
		!(procedure->prc_flags & PRC_being_altered))
	{
	    (*vector)[id] = NULL;
	}

/* deallocate all structure which were allocated.  The procedure
 * blr is originally read into a new pool from which all request
 * are allocated.  That will not be freed up.
 */

	if (procedure->prc_existence_lock) {
		delete procedure->prc_existence_lock;
		procedure->prc_existence_lock = NULL;
	}

/* deallocate input param structures */
	SSHORT i;
	if ((procedure->prc_inputs) && (vector = procedure->prc_input_fields)) {
		for (i = 0; i < procedure->prc_inputs; i++)
		{
			if ((*vector)[i])
			{
				delete (*vector)[i];
			}
		}
		delete vector;
		procedure->prc_inputs = 0;
		procedure->prc_input_fields = NULL;
	}

/* deallocate output param structures */

	if ((procedure->prc_outputs) && (vector = procedure->prc_output_fields)) {
		for (i = 0; i < procedure->prc_outputs; i++)
		{
			if ((*vector)[i])
			{
				delete (*vector)[i];
			}
		}
		delete vector;
		procedure->prc_outputs = 0;
		procedure->prc_output_fields = NULL;
	}

	if (procedure->prc_format) {
		delete procedure->prc_format;
		procedure->prc_format = NULL;
	}

	if (!(procedure->prc_flags & PRC_being_altered) && !procedure->prc_use_count)
	{
		delete procedure;
	}
	else
	{
		// Fully clear procedure block. Some pieces of code check for empty 
		// procedure name and ID, this is why we do it.
		procedure->prc_name = "";
		procedure->prc_security_name = "";
		procedure->prc_defaults = 0;
		procedure->prc_id = 0;
	}
}


void MET_revoke(
				thread_db* tdbb,
				jrd_tra* transaction,
				const TEXT* relation,
				const TEXT* revokee, const TEXT* privilege)
{
/**************************************
 *
 *      M E T _ r e v o k e
 *
 **************************************
 *
 * Functional description
 *      Execute a recursive revoke.  This is called only when
 *      a revoked privilege had the grant option.
 *
 **************************************/
	SET_TDBB(tdbb);
	Database* dbb = tdbb->tdbb_database;

/* See if the revokee still has the privilege.  If so, there's
   nothing to do */

	USHORT count = 0;

	jrd_req* request = CMP_find_request(tdbb, irq_revoke1, IRQ_REQUESTS);

	FOR(REQUEST_HANDLE request TRANSACTION_HANDLE transaction)
		FIRST 1 P IN RDB$USER_PRIVILEGES WITH
			P.RDB$RELATION_NAME EQ relation AND
			P.RDB$PRIVILEGE EQ privilege AND
			P.RDB$USER EQ revokee 

        if (!REQUEST(irq_revoke1))
			REQUEST(irq_revoke1) = request;
		++count;
	END_FOR;

	if (!REQUEST(irq_revoke1))
		REQUEST(irq_revoke1) = request;

	if (count)
		return;

	request = CMP_find_request(tdbb, irq_revoke2, IRQ_REQUESTS);

/* User lost privilege.  Take it away from anybody he/she gave
   it to. */

	FOR(REQUEST_HANDLE request TRANSACTION_HANDLE transaction)
		P IN RDB$USER_PRIVILEGES WITH
			P.RDB$RELATION_NAME EQ relation AND
			P.RDB$PRIVILEGE EQ privilege AND
			P.RDB$GRANTOR EQ revokee 

        if (!REQUEST(irq_revoke2))
            REQUEST(irq_revoke2) = request;
		ERASE P;
	END_FOR;

	if (!REQUEST(irq_revoke2))
		REQUEST(irq_revoke2) = request;
}


TEXT* MET_save_name(thread_db* tdbb, const TEXT* name)
{
/**************************************
 *
 *      M E T _ s a v e _ n a m e
 *
 **************************************
 *
 * Functional description
 *      Immortalize a field or relation name in a permant string block.
 *      Oh, wow.
 *
 **************************************/
	SET_TDBB(tdbb);

	str* string = save_name(tdbb, name);
	return (TEXT*) string->str_data;
}


void MET_scan_relation( thread_db* tdbb, jrd_rel* relation)
{
/**************************************
 *
 *      M E T _ s c a n _ r e l a t i o n
 *
 **************************************
 *
 * Functional description
 *      Scan a relation for view RecordSelExpr, computed by expressions, missing
 *      expressions, and validation expressions.
 *
 **************************************/
	trig_vec* triggers[TRIGGER_MAX];

	SET_TDBB(tdbb);
	Database* dbb = tdbb->tdbb_database;

#ifdef SUPERSERVER
	if (!(dbb->dbb_flags & DBB_sp_rec_mutex_init)) {
		THD_rec_mutex_init(&dbb->dbb_sp_rec_mutex);
		dbb->dbb_flags |= DBB_sp_rec_mutex_init;
	}
	THREAD_EXIT();
	if (THD_rec_mutex_lock(&dbb->dbb_sp_rec_mutex)) {
		THREAD_ENTER();
		return;
	}
	THREAD_ENTER();
#endif /* SUPERSERVER */

	if (relation->rel_flags & REL_scanned
		|| relation->rel_flags & REL_deleted)
	{
#ifdef SUPERSERVER
		THD_rec_mutex_unlock(&dbb->dbb_sp_rec_mutex);
#endif
		return;
	}

	relation->rel_flags |= REL_being_scanned;
	const bool dependencies =
		(relation->rel_flags & REL_get_dependencies) ? true : false;
	const bool sys_triggers = (relation->rel_flags & REL_sys_triggers) ? true : false;
	relation->rel_flags &= ~(REL_get_dependencies | REL_sys_triggers);
	for (USHORT itr = 0; itr < TRIGGER_MAX; ++itr) {
		triggers[itr] = NULL;
	}
	Jrd::ContextPoolHolder context(tdbb, dbb->dbb_permanent);
	blb* blob = 0;

/* If anything errors, catch it to reset the scan flag.  This will
   make sure that the error will be caught if the operation is tried
   again. */

	try {

/* Since this can be called recursively, find an inactive clone of the request */

	jrd_req* request = CMP_find_request(tdbb, irq_r_fields, IRQ_REQUESTS);
	CompilerScratch* csb = NULL;

	FOR(REQUEST_HANDLE request)
		REL IN RDB$RELATIONS WITH REL.RDB$RELATION_ID EQ relation->rel_id
			/* Pick up relation level stuff */
		if (!REQUEST(irq_r_fields)) {
            REQUEST(irq_r_fields) = request;
		}
		relation->rel_current_fmt = REL.RDB$FORMAT;
		vec* vector = relation->rel_fields =
			vec::newVector(*dbb->dbb_permanent, relation->rel_fields,
						   REL.RDB$FIELD_ID + 1);
		if (!REL.RDB$SECURITY_CLASS.NULL) {
			relation->rel_security_name =
				MET_save_name(tdbb, REL.RDB$SECURITY_CLASS);
		}
		if (!relation->rel_name) {
			relation->rel_name = MET_save_name(tdbb, REL.RDB$RELATION_NAME);
			relation->rel_length = strlen(relation->rel_name);
		}
		if (!relation->rel_owner_name)
			relation->rel_owner_name =
				MET_save_name(tdbb, REL.RDB$OWNER_NAME);
		if (REL.RDB$FLAGS & REL_sql)
		{
			relation->rel_flags |= REL_sql_relation;
		}
		if (!REL.RDB$VIEW_BLR.isEmpty())
		{
			/* parse the view blr, getting dependencies on relations, etc. at the same time */

			if (dependencies)
			{
				relation->rel_view_rse =
				(RecordSelExpr*) MET_get_dependencies(tdbb, relation, NULL, NULL,
											&REL.RDB$VIEW_BLR, NULL, 
											&csb, REL.RDB$RELATION_NAME,
											obj_view);
			}
			else
			{
				relation->rel_view_rse =
					(RecordSelExpr*) MET_parse_blob(tdbb, relation,
										&REL.RDB$VIEW_BLR, &csb,
										NULL, false, false);
			}

			/* retrieve the view context names */

			lookup_view_contexts(tdbb, relation);
		}

		relation->rel_flags |= REL_scanned;
		if (REL.RDB$EXTERNAL_FILE[0])
		{
			EXT_file(relation,
					REL.RDB$EXTERNAL_FILE,
					&REL.RDB$EXTERNAL_DESCRIPTION);
		}

		/* Pick up field specific stuff */

		blob = BLB_open(tdbb, dbb->dbb_sys_trans, &REL.RDB$RUNTIME);
		Firebird::HalfStaticArray<UCHAR, 256> temp;
		UCHAR* const buffer = temp.getBuffer(blob->blb_max_segment);

		jrd_fld* field = NULL;
		ArrayField* array = 0;
		USHORT view_context = 0;
		USHORT field_id = 0;
		for (;;)
		{
			USHORT length =
				BLB_get_segment(tdbb, blob, buffer, blob->blb_max_segment);
			if (blob->blb_flags & BLB_eof)
			{
				break;
			}
			USHORT n;
			buffer[length] = 0;
			UCHAR* p = (UCHAR*) &n;
			const UCHAR* q = buffer + 1;
			while (q < buffer + 1 + sizeof(SSHORT))
			{
				*p++ = *q++;
			}
			p = buffer + 1;
			--length;
			switch ((RSR_T) buffer[0]) {
			case RSR_field_id:
				if (field && !field->fld_security_name
					&& !REL.RDB$DEFAULT_CLASS.NULL)
				{
					field->fld_security_name =
						MET_save_name(tdbb, REL.RDB$DEFAULT_CLASS);
				}
				field_id = n;
				field = (jrd_fld*) (*vector)[field_id];
				array = NULL;
				break;

			case RSR_field_name:
				if (field) {
					/* The field exists.  If its name hasn't changed, then
					   there's no need to copy anything. */

					if (!strcmp((char*)p, (char*)field->fld_name))
						break;

					field->fld_name = stringDup(*(dbb->dbb_permanent), (char*)p);
				}
				else {
					field = FB_NEW_RPT(*dbb->dbb_permanent, length) jrd_fld();
					(*vector)[field_id] = field;
					field->fld_name = (TEXT *) field->fld_string;
					/*
					 * TMN: This const_cast equivalent is safe since
					 * we just allocated the struct.
					 */
					strcpy((char*)field->fld_name, (char*)p);
				}
				field->fld_length = strlen(field->fld_name);

				// CVC: Be paranoid and allow the possible trigger(s) to have a
				//   not null security class to work on, even if we only take it
				//   from the relation itself.
				if (!field->fld_security_name && !REL.RDB$DEFAULT_CLASS.NULL) {
					field->fld_security_name = MET_save_name (tdbb, REL.RDB$DEFAULT_CLASS);
				}

				break;

			case RSR_view_context:
				view_context = n;
				break;

			case RSR_base_field:
				field->fld_source =
					PAR_make_field(tdbb, csb, view_context, (TEXT*)p);
				break;

			case RSR_computed_blr:
				field->fld_computation = (dependencies) ?
					MET_get_dependencies(tdbb, relation, (const TEXT*) p, csb,
										 NULL, NULL, NULL, field->fld_name,
										 obj_computed) :
					PAR_blr(tdbb, relation, p, csb, NULL, NULL, false, 0);
				break;

			case RSR_missing_value:
				field->fld_missing_value =
					PAR_blr(tdbb, relation, p, csb, NULL, NULL, false, 0);
				break;

			case RSR_default_value:
				field->fld_default_value =
					PAR_blr(tdbb, relation, p, csb, NULL, NULL, false, 0);
				break;

			case RSR_validation_blr:
				field->fld_validation =
					PAR_blr(tdbb, relation, p, csb, NULL, NULL, false,
							csb_validation);
				break;

			case RSR_field_not_null:
				field->fld_not_null =
					PAR_blr(tdbb, relation, p, csb, NULL, NULL, false,
							csb_validation);
				break;

			case RSR_security_class:
				field->fld_security_name = MET_save_name(tdbb, (const TEXT*) p);
				break;

			case RSR_trigger_name:
				MET_load_trigger(tdbb, relation, (const TEXT*) p, triggers);
				break;

			case RSR_dimensions:
				field->fld_array = array = FB_NEW_RPT(*dbb->dbb_permanent, n) ArrayField();
				array->arr_desc.iad_dimensions = n;
				break;

			case RSR_array_desc:
				if (array)
					MOVE_FAST(p, &array->arr_desc, length);
				break;

			default:    /* Shut up compiler warning */
				break;
			}
		}
		BLB_close(tdbb, blob);
		blob = 0;
		if (field && !field->fld_security_name && !REL.RDB$DEFAULT_CLASS.NULL)
		{
			field->fld_security_name =
				MET_save_name(tdbb, REL.RDB$DEFAULT_CLASS);
		}
	END_FOR;

	if (csb)
	{
		delete csb;
	}

/* release any triggers in case of a rescan, but not if the rescan 
   hapenned while system triggers were being loaded. */

	if (!(relation->rel_flags & REL_sys_trigs_being_loaded)) {
		/* if we are scanning a system relation during loading the system 
		   triggers, (during parsing its blr actually), we must not release the
		   existing system triggers; because we have already set the
		   relation->rel_flag to not have REL_sys_trig, so these
		   system triggers will not get loaded again. This fixes bug 8149. */

		/* We have just loaded the triggers onto the local vector triggers.
		   Its now time to place them at their rightful place ie the relation
		   block. 
		 */
		trig_vec* tmp_vector;
		
		tmp_vector = relation->rel_pre_store;
		relation->rel_pre_store = triggers[TRIGGER_PRE_STORE];
		MET_release_triggers(tdbb, &tmp_vector);

		tmp_vector = relation->rel_post_store;
		relation->rel_post_store = triggers[TRIGGER_POST_STORE];
		MET_release_triggers(tdbb, &tmp_vector);

		tmp_vector = relation->rel_pre_erase;
		relation->rel_pre_erase = triggers[TRIGGER_PRE_ERASE];
		MET_release_triggers(tdbb, &tmp_vector);

		tmp_vector = relation->rel_post_erase;
		relation->rel_post_erase = triggers[TRIGGER_POST_ERASE];
		MET_release_triggers(tdbb, &tmp_vector);

		tmp_vector = relation->rel_pre_modify;
		relation->rel_pre_modify = triggers[TRIGGER_PRE_MODIFY];
		MET_release_triggers(tdbb, &tmp_vector);

		tmp_vector = relation->rel_post_modify;
		relation->rel_post_modify = triggers[TRIGGER_POST_MODIFY];
		MET_release_triggers(tdbb, &tmp_vector);
	}

	relation->rel_flags &= ~REL_being_scanned;
#ifdef SUPERSERVER
	THD_rec_mutex_unlock(&dbb->dbb_sp_rec_mutex);
#endif
	relation->rel_current_format = NULL;

	}	// try
	catch (const std::exception&) {
		relation->rel_flags &= ~(REL_being_scanned | REL_scanned);
		if (dependencies) {
			relation->rel_flags |= REL_get_dependencies;
		}
		if (sys_triggers) {
			relation->rel_flags |= REL_sys_triggers;
		}
		if (blob)
			BLB_close(tdbb, blob);
#ifdef SUPERSERVER
		THD_rec_mutex_unlock(&dbb->dbb_sp_rec_mutex);
#endif
		throw;
	}
}


const TEXT* MET_trigger_msg(thread_db* tdbb, const TEXT* name, USHORT number)
{
/**************************************
 *
 *      M E T _ t r i g g e r _ m s g
 *
 **************************************
 *
 * Functional description
 *      Look up trigger message using trigger and abort code.
 *
 **************************************/
	SET_TDBB(tdbb);
	Database* dbb = tdbb->tdbb_database;

	const TEXT* msg = 0;
	jrd_req* request = CMP_find_request(tdbb, irq_s_msgs, IRQ_REQUESTS);

	FOR(REQUEST_HANDLE request)
		MSG IN RDB$TRIGGER_MESSAGES WITH
			MSG.RDB$TRIGGER_NAME EQ name AND
			MSG.RDB$MESSAGE_NUMBER EQ number 

        if (!REQUEST(irq_s_msgs))
            REQUEST(irq_s_msgs) = request;
		msg = ERR_cstring(MSG.RDB$MESSAGE);
	END_FOR;

	if (!REQUEST(irq_s_msgs))
		REQUEST(irq_s_msgs) = request;

	return msg;
}


void MET_update_shadow( thread_db* tdbb, Shadow* shadow, USHORT file_flags)
{
/**************************************
 *
 *      M E T _ u p d a t e _ s h a d o w
 *
 **************************************
 *
 * Functional description
 *      Update the stored file flags for the specified shadow.
 *
 **************************************/
	SET_TDBB(tdbb);
	Database* dbb = tdbb->tdbb_database;

	jrd_req* handle = NULL;
	FOR(REQUEST_HANDLE handle)
		FIL IN RDB$FILES WITH FIL.RDB$SHADOW_NUMBER EQ shadow->sdw_number
		MODIFY FIL USING
			FIL.RDB$FILE_FLAGS = file_flags;
		END_MODIFY;
	END_FOR;
	CMP_release(tdbb, handle);
}


void MET_update_transaction( thread_db* tdbb, jrd_tra* transaction, const bool do_commit)
{
/**************************************
 *
 *      M E T _ u p d a t e _ t r a n s a c t i o n
 *
 **************************************
 *
 * Functional description
 *      Update a record in RDB$TRANSACTIONS.  If do_commit is true, this is a
 *      commit; otherwise it is a ROLLBACK.
 *
 **************************************/
	SET_TDBB(tdbb);
	Database* dbb = tdbb->tdbb_database;

	jrd_req* request = CMP_find_request(tdbb, irq_m_trans, IRQ_REQUESTS);

	FOR(REQUEST_HANDLE request)
		X IN RDB$TRANSACTIONS 
        WITH X.RDB$TRANSACTION_ID EQ transaction->tra_number 

        if (!REQUEST(irq_m_trans))
            REQUEST(irq_m_trans) = request;
		if (do_commit && (transaction->tra_flags & TRA_prepare2))
		{
			ERASE X
		}
		else
		{
			MODIFY X
				X.RDB$TRANSACTION_STATE = (do_commit) ?
					RDB$TRANSACTIONS.RDB$TRANSACTION_STATE.COMMITTED :
					RDB$TRANSACTIONS.RDB$TRANSACTION_STATE.ROLLED_BACK;
			END_MODIFY;
		}
	END_FOR;

	if (!REQUEST(irq_m_trans))
		REQUEST(irq_m_trans) = request;
}


static int blocking_ast_procedure(void* ast_object)
{
/**************************************
 *
 *      b l o c k i n g _ a s t _ p r o c e d u r e
 *
 **************************************
 *
 * Functional description
 *      Someone is trying to drop a proceedure. If there
 *      are outstanding interests in the existence of
 *      the relation then just mark as blocking and return.
 *      Otherwise, mark the procedure block as questionable
 *      and release the procedure existence lock.
 *
 **************************************/
	jrd_prc* procedure = static_cast<jrd_prc*>(ast_object);
	thread_db thd_context, *tdbb;

/* Since this routine will be called asynchronously, we must establish
   a thread context. */

	JRD_set_thread_data(tdbb, thd_context);

	tdbb->tdbb_database = procedure->prc_existence_lock->lck_dbb;
	tdbb->tdbb_attachment = procedure->prc_existence_lock->lck_attachment;
	tdbb->tdbb_quantum = QUANTUM;
	tdbb->tdbb_request = NULL;
	tdbb->tdbb_transaction = NULL;
	Jrd::ContextPoolHolder context(tdbb, 0);

	if (procedure->prc_existence_lock) {
		LCK_release(tdbb, procedure->prc_existence_lock);
	}
	procedure->prc_flags |= PRC_obsolete;

/* Restore the prior thread context */

	JRD_restore_thread_data();
	return 0;
}


static int blocking_ast_relation(void* ast_object)
{
/**************************************
 *
 *      b l o c k i n g _ a s t _ r e l a t i o n
 *
 **************************************
 *
 * Functional description
 *      Someone is trying to drop a relation. If there
 *      are outstanding interests in the existence of
 *      the relation then just mark as blocking and return.
 *      Otherwise, mark the relation block as questionable
 *      and release the relation existence lock.
 *
 **************************************/
	jrd_rel* relation = static_cast<jrd_rel*>(ast_object);
	thread_db thd_context, *tdbb;

/* Since this routine will be called asynchronously, we must establish
   a thread context. */

	JRD_set_thread_data(tdbb, thd_context);

	tdbb->tdbb_database = relation->rel_existence_lock->lck_dbb;
	tdbb->tdbb_attachment = relation->rel_existence_lock->lck_attachment;
	tdbb->tdbb_quantum = QUANTUM;
	tdbb->tdbb_request = NULL;
	tdbb->tdbb_transaction = NULL;
	Jrd::ContextPoolHolder context(tdbb, 0);

	if (relation->rel_use_count) {
		relation->rel_flags |= REL_blocking;
	}
	else {
		relation->rel_flags &= ~REL_blocking;
		relation->rel_flags |= (REL_check_existence | REL_check_partners);
		if (relation->rel_existence_lock)
			LCK_release(tdbb, relation->rel_existence_lock);
	}

/* Restore the prior thread context */

	JRD_restore_thread_data();
	return 0; 
}


static void get_trigger(
						thread_db* tdbb,
						jrd_rel* relation,
						bid* blob_id,
						trig_vec** ptr,
						const TEXT* name, bool sys_trigger, USHORT flags)
{
/**************************************
 *
 *      g e t _ t r i g g e r
 *
 **************************************
 *
 * Functional description
 *      Get trigger.
 *
 **************************************/
	SET_TDBB(tdbb);

	if (blob_id->isEmpty())
		return;

	Database* dbb = tdbb->tdbb_database;
	blb* blob = BLB_open(tdbb, dbb->dbb_sys_trans, blob_id);
	save_trigger_data(tdbb, ptr, relation, NULL, blob, name, sys_trigger, flags);
}


static bool get_type(thread_db* tdbb, SSHORT* id, const UCHAR* name, const TEXT* field)
{
/**************************************
 *
 *      g e t _ t y p e
 *
 **************************************
 *
 * Functional description
 *      Resoved a symbolic name in RDB$TYPES.  Returned the value
 *      defined for the name in (*id).  Don't touch (*id) if you
 *      don't find the name.
 *
 *      Return (1) if found, (0) otherwise.
 *
 **************************************/
	UCHAR buffer[32];			/* BASED ON RDB$TYPE_NAME */

	SET_TDBB(tdbb);
	Database* dbb = tdbb->tdbb_database;

	fb_assert(id != NULL);
	fb_assert(name != NULL);
	fb_assert(field != NULL);

/* Force key to uppercase, following C locale rules for uppercase */
	UCHAR* p;
	for (p = buffer; *name && p < buffer + sizeof(buffer) - 1; p++, name++)
	{
		*p = UPPER7(*name);
	}
	*p = 0;

/* Try for exact name match */

	bool found = false;

	jrd_req* handle = NULL;
	FOR(REQUEST_HANDLE handle)
		FIRST 1 T IN RDB$TYPES WITH
			T.RDB$FIELD_NAME EQ field AND
			T.RDB$TYPE_NAME EQ buffer

        found = true;
		*id = T.RDB$TYPE;
	END_FOR;
	CMP_release(tdbb, handle);

	return found;
}


static void lookup_view_contexts( thread_db* tdbb, jrd_rel* view)
{
/**************************************
 *
 *      l o o k u p _ v i e w _ c o n t e x t s
 *
 **************************************
 *
 * Functional description
 *      Lookup view contexts and store in a linked 
 *      list on the relation block.
 *                                       
 **************************************/
	SET_TDBB(tdbb);
	Database* dbb = tdbb->tdbb_database;
	jrd_req* request = CMP_find_request(tdbb, irq_view_context, IRQ_REQUESTS);

	ViewContext** vcx_ptr = &view->rel_view_contexts;

	FOR(REQUEST_HANDLE request)
		V IN RDB$VIEW_RELATIONS WITH
			V.RDB$VIEW_NAME EQ view->rel_name
			SORTED BY V.RDB$VIEW_CONTEXT 

        if (!REQUEST(irq_view_context))
            REQUEST(irq_view_context) = request;

		/* allocate a view context block and link it in
		   to the relation block's linked list */

		ViewContext* view_context = FB_NEW(*tdbb->getDefaultPool()) ViewContext();
		*vcx_ptr = view_context;
		vcx_ptr = &view_context->vcx_next;

		view_context->vcx_context = V.RDB$VIEW_CONTEXT;

		/* allocate a string block for the context name */

		SSHORT length = fb_utils::name_length(V.RDB$CONTEXT_NAME);
		str* alias = FB_NEW_RPT(*tdbb->getDefaultPool(), length + 1) str();
		V.RDB$CONTEXT_NAME[length] = 0;
		strcpy((char*)alias->str_data, V.RDB$CONTEXT_NAME);
		alias->str_length = length;

		view_context->vcx_context_name = alias;

		/* allocate a string block for the relation name */

		length = fb_utils::name_length(V.RDB$RELATION_NAME);
		alias = FB_NEW_RPT(*tdbb->getDefaultPool(), length + 1) str();
		V.RDB$RELATION_NAME[length] = 0;
		strcpy((char*)alias->str_data, V.RDB$RELATION_NAME);
		alias->str_length = length;

		view_context->vcx_relation_name = alias;

	END_FOR;

	if (!REQUEST(irq_view_context))
		REQUEST(irq_view_context) = request;
}


static void name_copy(TEXT* to, const TEXT* from)
{
/**************************************
 *
 *      n a m e _ c o p y
 *
 **************************************
 *
 * Functional description
 *      Copy a system name, stripping trailing blanks.
 *
 **************************************/
	const USHORT length = fb_utils::name_length(from);
	memcpy(to, from, length);
	to[length] = '\0';
}


static jrd_nod* parse_param_blr(thread_db* tdbb,
		jrd_prc* procedure, bid* blob_id, CompilerScratch* csb)
{
	SET_TDBB(tdbb);
	Database* dbb = tdbb->tdbb_database;

	blb*	blob   = BLB_open(tdbb, dbb->dbb_sys_trans, blob_id);
	SLONG	length = blob->blb_length + 10;
	Firebird::HalfStaticArray<UCHAR, 512>	temp;

	BLB_get_data(tdbb, blob, temp.getBuffer(length), length);
	csb->csb_blr = temp.begin();

	jrd_nod* node = PAR_blr(tdbb, NULL, temp.begin(), NULL, &csb,
				&procedure->prc_request, false, 0);
	csb->csb_blr = 0;

	return node;
}

static jrd_nod* parse_procedure_blr(
							   thread_db* tdbb,
							   jrd_prc* procedure, bid* blob_id, CompilerScratch* csb)
{
/**************************************
 *
 *      p a r s e _ p r o c e d u r e _ b l r
 *
 **************************************
 *
 * Functional description
 *      Parse blr, returning a compiler scratch block with the results.
 *
 **************************************/
	SET_TDBB(tdbb);
	Database* dbb = tdbb->tdbb_database;

	blb* blob = BLB_open(tdbb, dbb->dbb_sys_trans, blob_id);
	const SLONG length = blob->blb_length + 10;
	// CVC: Warning: the str class is limited by 64K
	str* temp = FB_NEW_RPT(*tdbb->getDefaultPool(), length) str();
	BLB_get_data(tdbb, blob, temp->str_data, length);
	csb->csb_blr = temp->str_data;
	// CVC: Why don't we check this function's return value!
	// Trashed memory may be a cause of failure here
	if (!par_messages(tdbb, temp->str_data, (USHORT) length, procedure, csb))
	{
		delete temp;
		return NULL;
	}
		
	jrd_nod* node =
		PAR_blr(tdbb, NULL, temp->str_data, NULL, &csb,
				&procedure->prc_request, false, 0);
	delete temp;

	return node;
}


static bool par_messages(thread_db*	tdbb,
							const UCHAR*	blr,
							USHORT	blr_length,
							jrd_prc*	procedure,
							CompilerScratch*	csb)
{
/**************************************
 *
 *      p a r _ m e s s a g e s
 *
 **************************************
 *
 * Functional description
 *      Parse the messages of a blr request.  For specified message, allocate
 *      a format (Format) block.
 *
 **************************************/
	csb->csb_running = blr;
	const SSHORT version = BLR_BYTE;
	if (version != blr_version4 && version != blr_version5) {
		return false;
	}

	if (BLR_BYTE != blr_begin) {
		return false;
	}

	SET_TDBB(tdbb);

	while (BLR_BYTE == blr_message) {
		const USHORT msg_number = BLR_BYTE;
		USHORT count = BLR_BYTE;
		count += (BLR_BYTE) << 8;
		Format* format = Format::newFormat(*tdbb->getDefaultPool(), count);
		format->fmt_count = count;
		// CVC: This offset should be protected against 32K overflow in the future
		USHORT offset = 0;
		for (Format::fmt_desc_iterator desc = format->fmt_desc.begin(); count;
			--count, ++desc)
		{
			const USHORT align = PAR_desc(csb, &*desc);
			if (align) {
				offset = FB_ALIGN(offset, align);
			}
			desc->dsc_address = (UCHAR *) (IPTR) offset;
			offset += desc->dsc_length;
		}
		format->fmt_length = offset;
		if (msg_number == 0)
		{
			procedure->prc_input_fmt = format;
		}
		else if (msg_number == 1)
		{
			procedure->prc_output_fmt = format;
		}
		else
		{
			delete format;
		}
	}

	return true;
}


void MET_release_triggers( thread_db* tdbb, trig_vec** vector_ptr)
{
/***********************************************
 *
 *      M E T _ r e l e a s e _ t r i g g e r s
 *
 ***********************************************
 *
 * Functional description
 *      Release a possibly null vector of triggers.
 *      If triggers are still active let someone
 *      else do the work.
 *
 **************************************/
	trig_vec* vector = *vector_ptr;
	if (!vector) 
	{
		return;
	}

	SET_TDBB(tdbb);

	*vector_ptr = NULL;
	size_t i;

	for (i = 0; i < vector->getCount(); i++) 
	{
		jrd_req* r = (*vector)[i].request;
		if (r && CMP_clone_is_active(r))
		{
			return;
		}
	}

	for (i = 0; i < vector->getCount(); i++) 
	{
		jrd_req* r = (*vector)[i].request;
		if (r) 
		{
			CMP_release(tdbb, r);
		}
	}

	delete vector;
}


static bool resolve_charset_and_collation(
											 thread_db* tdbb,
											 SSHORT* id,
											 const UCHAR* charset,
											 const UCHAR* collation)
{
/**************************************
 *
 *      r e s o l v e _ c h a r s e t _ a n d _ c o l l a t i o n
 *
 **************************************
 *
 * Functional description
 *      Given ASCII7 name of charset & collation
 *      resolve the specification to a Character set id.
 *      This character set id is also the id of the text_object
 *      that implements the C locale for the Character set.
 *
 * Inputs:
 *      (charset)
 *              ASCII7z name of character set.
 *              NULL (implying unspecified) means use the character set
 *              for defined for (collation).
 *
 *      (collation)
 *              ASCII7z name of collation.
 *              NULL means use the default collation for (charset).
 *
 * Outputs:
 *      (*id)   
 *              Set to character set specified by this name.
 *
 * Return:
 *      1 if no errors (and *id is set).
 *      0 if either name not found.
 *        or if names found, but the collation isn't for the specified
 *        character set.
 *
 **************************************/
	bool found = false;

	SET_TDBB(tdbb);
	Database* dbb = tdbb->tdbb_database;

	fb_assert(id != NULL);

	jrd_req* handle = NULL;

	if (collation == NULL)
	{
		if (charset == NULL)
			charset = (const UCHAR*) DEFAULT_CHARACTER_SET_NAME;

		SSHORT charset_id = 0;
		if (get_type(tdbb, &charset_id, charset, "RDB$CHARACTER_SET_NAME"))
		{
			*id = charset_id;
			return true;
		}

		/* Charset name not found in the alias table - before giving up
		   try the character_set table */

		FOR(REQUEST_HANDLE handle)
			FIRST 1 CS IN RDB$CHARACTER_SETS
				WITH CS.RDB$CHARACTER_SET_NAME EQ charset

            found = true;
			*id = CS.RDB$CHARACTER_SET_ID;

		END_FOR;
		CMP_release(tdbb, handle);

		return found;
	}
	else if (charset == NULL)
	{
		FOR(REQUEST_HANDLE handle)
			FIRST 1 COL IN RDB$COLLATIONS
				WITH COL.RDB$COLLATION_NAME EQ collation

            found = true;
			*id = COL.RDB$CHARACTER_SET_ID;

		END_FOR;
		CMP_release(tdbb, handle);

		return found;
	}

	FOR(REQUEST_HANDLE handle)
		FIRST 1 CS IN RDB$CHARACTER_SETS CROSS
			COL IN RDB$COLLATIONS OVER RDB$CHARACTER_SET_ID CROSS
			AL1 IN RDB$TYPES
			WITH AL1.RDB$FIELD_NAME EQ "RDB$CHARACTER_SET_NAME"
			AND AL1.RDB$TYPE_NAME EQ charset
			AND COL.RDB$COLLATION_NAME EQ collation
			AND AL1.RDB$TYPE EQ CS.RDB$CHARACTER_SET_ID 

        found = true;
		*id = CS.RDB$CHARACTER_SET_ID;

	END_FOR;
	CMP_release(tdbb, handle);

	return found;
}


static str* save_name(thread_db* tdbb, const TEXT* name)
{
/**************************************
 *
 *      s a v e _ n a m e
 *
 **************************************
 *
 * Functional description
 *      save a name in a string.
 *
 **************************************/
	SET_TDBB(tdbb);
	Database* dbb = tdbb->tdbb_database;

	USHORT l = fb_utils::name_length(name);
	str* string = FB_NEW_RPT(*dbb->dbb_permanent, l) str();
	string->str_length = l;
	TEXT* p = (TEXT *) string->str_data;

	if (l)
	{
		do {
			*p++ = *name++;
		} while (--l);
	}

	return string;
}


static void save_trigger_data(thread_db* tdbb, trig_vec** ptr, jrd_rel* relation,
							jrd_req* request, blb* blrBlob,
							  const TEXT* name, bool sys_trigger, USHORT flags)
{
/**************************************
 *
 *      s a v e _ t r i g g e r _ d a t a
 *
 **************************************
 *
 * Functional description
 *      Save trigger data to passed vector
 *
 **************************************/
	trig_vec* vector = *ptr;

	if (!vector) {
		vector = FB_NEW(*tdbb->tdbb_database->dbb_permanent) 
			trig_vec(*tdbb->tdbb_database->dbb_permanent);
		*ptr = vector;
	}

	Trigger& t = vector->add();
	if (blrBlob) 
	{
		const SLONG length = blrBlob->blb_length + 10;
		UCHAR* ptr2 = t.blr.getBuffer(length);
		BLB_get_data(tdbb, blrBlob, ptr2, length);
	}
	if (name) {
		t.name = name;
	}
	t.flags = flags;
	t.compile_in_progress = false;
	t.sys_trigger = sys_trigger;
	t.request = request;
	t.relation = relation;
}


static void store_dependencies(thread_db*	tdbb,
							   CompilerScratch*	csb,
							   const TEXT*	object_name,
							   USHORT		dependency_type)
{
/**************************************
 *
 *      s t o r e _ d e p e n d e n c i e s
 *
 **************************************
 *
 * Functional description
 *      Store records in RDB$DEPENDENCIES
 *      corresponding to the objects found during 
 *      compilation of blr for a trigger, view, etc.
 *
 **************************************/
	SqlIdentifier name;

	SET_TDBB(tdbb);
	Database* dbb = tdbb->tdbb_database;

	while (csb->csb_dependencies.hasData())
	{
		jrd_nod* node = csb->csb_dependencies.pop();
		if (!node->nod_arg[e_dep_object])
			continue;
		const SSHORT dpdo_type = (SSHORT) (IPTR) node->nod_arg[e_dep_object_type];
        jrd_rel* relation = NULL;
        jrd_prc* procedure = NULL;
        const TEXT* dpdo_name;
        switch (dpdo_type) {
        case obj_relation:
			relation = (jrd_rel*) node->nod_arg[e_dep_object];
			dpdo_name = relation->rel_name;
            break;
        case obj_procedure:
            procedure = (jrd_prc*) node->nod_arg [e_dep_object];
            dpdo_name = procedure->prc_name.c_str();
            break;
        case obj_exception:
			{
				const SLONG number = (IPTR) node->nod_arg [e_dep_object];
				MET_lookup_exception (tdbb, number, name, NULL);
				dpdo_name = name;
				break;
			}
            /* CVC: Here I'm going to track those pesky things named generators and UDFs. */
		case obj_generator:
			{
				const SLONG number = (IPTR) node->nod_arg [e_dep_object];
				MET_lookup_generator_id (tdbb, number, name);
				dpdo_name = name;
				break;
			}
        case obj_udf:
			{
				UserFunction* udf = (UserFunction*) node->nod_arg [e_dep_object];
				dpdo_name = udf->fun_symbol->sym_string.c_str();
			}
			break;
		}

		jrd_nod* field_node = node->nod_arg[e_dep_field];

		const TEXT* field_name = NULL;
		if (field_node)
		{
			if (field_node->nod_type == nod_field)
			{
				const SSHORT fld_id = (SSHORT) (IPTR) field_node->nod_arg[0];
				if (relation)
				{
					const jrd_fld* field = MET_get_field(relation, fld_id);
					if (field)
					{
						field_name = field->fld_name;
					}
				}
				else if (procedure)
				{
					const jrd_fld* field =
						(jrd_fld*) (*procedure->prc_output_fields)[fld_id];
					// CVC: Setting the field var here didn't make sense alone,
					// so I thought the missing code was to try to extract
					// the field name that's in this case an output var from a proc.
					if (field)
					{
						field_name = field->fld_name;
					}
				}
			}
			else
			{
				field_name = (TEXT *) field_node->nod_arg[0];
			}
		}

		if (field_name)
		{
			jrd_req* request =
				CMP_find_request(tdbb, irq_c_deps_f, IRQ_REQUESTS);
			bool found = false;
			FOR(REQUEST_HANDLE request) X IN RDB$DEPENDENCIES WITH
				X.RDB$DEPENDENT_NAME = object_name AND
					X.RDB$DEPENDED_ON_NAME = dpdo_name AND
					X.RDB$DEPENDED_ON_TYPE = dpdo_type AND
					X.RDB$FIELD_NAME = field_name AND
					X.RDB$DEPENDENT_TYPE = dependency_type

                if (!REQUEST(irq_c_deps_f))
                    REQUEST(irq_c_deps_f) = request;
				found = true;
			END_FOR;

			if (found) {
				continue;
			}
			if (!REQUEST(irq_c_deps_f))
				REQUEST(irq_c_deps_f) = request;
		}
		else
		{
			jrd_req* request = CMP_find_request(tdbb, irq_c_deps, IRQ_REQUESTS);
			bool found = false;
			FOR(REQUEST_HANDLE request) X IN RDB$DEPENDENCIES WITH
				X.RDB$DEPENDENT_NAME = object_name AND
					X.RDB$DEPENDED_ON_NAME = dpdo_name AND
					X.RDB$DEPENDED_ON_TYPE = dpdo_type AND
					X.RDB$FIELD_NAME MISSING AND
					X.RDB$DEPENDENT_TYPE = dependency_type

                if (!REQUEST(irq_c_deps))
					REQUEST(irq_c_deps) = request;
				found = true;

			END_FOR;

			if (found) {
				continue;
			}
			if (!REQUEST(irq_c_deps))
				REQUEST(irq_c_deps) = request;
		}

		jrd_req* request = CMP_find_request(tdbb, irq_s_deps, IRQ_REQUESTS);

		STORE(REQUEST_HANDLE request) DEP IN RDB$DEPENDENCIES
			strcpy(DEP.RDB$DEPENDENT_NAME, object_name);
			DEP.RDB$DEPENDED_ON_TYPE = dpdo_type;
			strcpy(DEP.RDB$DEPENDED_ON_NAME, dpdo_name);
			if (field_name)
			{
				DEP.RDB$FIELD_NAME.NULL = FALSE;
				strcpy(DEP.RDB$FIELD_NAME, field_name);
			}
			else {
				DEP.RDB$FIELD_NAME.NULL = TRUE;
			}
			DEP.RDB$DEPENDENT_TYPE = dependency_type;
		END_STORE;

		if (!REQUEST(irq_s_deps))
			REQUEST(irq_s_deps) = request;
	}
}


static bool verify_TRG_ignore_perm(thread_db* tdbb, const TEXT* trig_name)
{
/*****************************************************
 *
 *      v e r i f y _ T R G _ i g n o r e  _ p e r m
 *
 *****************************************************
 *
 * Functional description
 *      Return true if this trigger can go through without any permission
 *      checks. Currently, the only class of triggers that can go
 *      through without permission checks are 
 *      (a) two system triggers (RDB$TRIGGERS_34 and RDB$TRIGGERS_35)
 *      (b) those defined for referential integrity actions such as, 
 *      set null, set default, and cascade.
 *
 **************************************/
	SET_TDBB(tdbb);
	Database* dbb = tdbb->tdbb_database;

/* see if this is a system trigger, with the flag set as TRG_ignore_perm */
	if (INI_get_trig_flags(trig_name) & (USHORT) TRG_ignore_perm)
	{
		return true;
	}

	jrd_req* request = CMP_find_request(tdbb, irq_c_trg_perm, IRQ_REQUESTS);

	FOR(REQUEST_HANDLE request)
		CHK IN RDB$CHECK_CONSTRAINTS CROSS
			REF IN RDB$REF_CONSTRAINTS WITH
			CHK.RDB$TRIGGER_NAME EQ trig_name AND
			REF.RDB$CONSTRAINT_NAME = CHK.RDB$CONSTRAINT_NAME

        if (!REQUEST(irq_c_trg_perm))
		{
			REQUEST(irq_c_trg_perm) = request;
		}

		EXE_unwind(tdbb, request);
		fb_utils::exact_name_limit(REF.RDB$UPDATE_RULE, sizeof(REF.RDB$UPDATE_RULE));
		fb_utils::exact_name_limit(REF.RDB$DELETE_RULE, sizeof(REF.RDB$DELETE_RULE));

		if (!strcmp(REF.RDB$UPDATE_RULE, RI_ACTION_CASCADE) ||
			!strcmp(REF.RDB$UPDATE_RULE, RI_ACTION_NULL) ||
			!strcmp(REF.RDB$UPDATE_RULE, RI_ACTION_DEFAULT) ||
			!strcmp(REF.RDB$DELETE_RULE, RI_ACTION_CASCADE) ||
			!strcmp(REF.RDB$DELETE_RULE, RI_ACTION_NULL) ||
			!strcmp(REF.RDB$DELETE_RULE, RI_ACTION_DEFAULT))
		{
			return true;
		}
		else
		{
			return false;
		}
	END_FOR;

	if (!REQUEST(irq_c_trg_perm))
	{
		REQUEST(irq_c_trg_perm) = request;
	}

	return false;
}

