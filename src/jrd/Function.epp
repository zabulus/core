/*
 * The contents of this file are subject to the Interbase Public
 * License Version 1.0 (the "License"); you may not use this file
 * except in compliance with the License. You may obtain a copy
 * of the License at http://www.Inprise.com/IPL.html
 *
 * Software distributed under the License is distributed on an
 * "AS IS" basis, WITHOUT WARRANTY OF ANY KIND, either express
 * or implied. See the License for the specific language governing
 * rights and limitations under the License.
 *
 * The Original Code was created by Inprise Corporation
 * and its predecessors. Portions created by Inprise Corporation are
 * Copyright (C) Inprise Corporation.
 *
 * All Rights Reserved.
 * Contributor(s): ______________________________________.
 */

#include "firebird.h"
#include "../common/common.h"
#include "../common/gdsassert.h"
#include "../jrd/flags.h"
#include "../jrd/ibase.h"
#include "../jrd/jrd.h"
#include "../jrd/val.h"
#include "../jrd/irq.h"
#include "../jrd/tra.h"
#include "../jrd/lck.h"
#include "../jrd/req.h"
#include "../jrd/exe.h"
#include "../jrd/blb.h"
#include "../jrd/met.h"
#include "../jrd/align.h"
#include "../dsql/ExprNodes.h"
#include "../jrd/blb_proto.h"
#include "../jrd/cmp_proto.h"
#include "../common/dsc_proto.h"
#include "../jrd/evl_proto.h"
#include "../jrd/exe_proto.h"
#include "../jrd/flu_proto.h"
#include "../jrd/fun_proto.h"
#include "../jrd/lck_proto.h"
#include "../jrd/met_proto.h"
#include "../jrd/mov_proto.h"
#include "../jrd/par_proto.h"
#include "../jrd/vio_proto.h"
#include "../jrd/thread_proto.h"
#include "../common/utils_proto.h"
#include "../jrd/DebugInterface.h"

#include "../jrd/Function.h"

using namespace Firebird;
using namespace Jrd;

DATABASE DB = FILENAME "ODS.RDB";

const char* const Function::EXCEPTION_MESSAGE = "The user defined function: \t%s\n\t   referencing"
	" entrypoint: \t%s\n\t                in module: \t%s\n\tcaused the fatal exception:";

Function* Function::lookup(thread_db* tdbb, USHORT id, bool return_deleted, bool noscan, USHORT flags)
{
	Jrd::Attachment* attachment = tdbb->getAttachment();
	Database* const dbb = tdbb->getDatabase();
	Function* check_function = NULL;

	Function* function = (id < attachment->att_functions.getCount()) ? attachment->att_functions[id] : NULL;

	if (function && function->getId() == id &&
		!(function->fun_flags & FUN_being_scanned) &&
		((function->fun_flags & FUN_scanned) || noscan) &&
		!(function->fun_flags & FUN_being_altered) &&
		(!(function->fun_flags & FUN_obsolete) || return_deleted))
	{
		if (!(function->fun_flags & FUN_check_existence))
		{
			return function;
		}

		check_function = function;
		LCK_lock(tdbb, check_function->fun_existence_lock, LCK_SR, LCK_WAIT);
	}

	// We need to look up the function in RDB$FUNCTIONS

	function = NULL;

	AutoCacheRequest request(tdbb, irq_l_fun_id, IRQ_REQUESTS);

	FOR(REQUEST_HANDLE request)
		X IN RDB$FUNCTIONS WITH X.RDB$FUNCTION_ID EQ id
	{
		function = loadMetadata(tdbb, X.RDB$FUNCTION_ID, noscan, flags);
	}
	END_FOR

	if (check_function)
	{
		check_function->fun_flags &= ~FUN_check_existence;
		if (check_function != function)
		{
			LCK_release(tdbb, check_function->fun_existence_lock);
			check_function->fun_flags |= FUN_obsolete;
		}
	}

	return function;
}

Function* Function::lookup(thread_db* tdbb, const QualifiedName& name, bool noscan)
{
	Jrd::Attachment* attachment = tdbb->getAttachment();
	Database* const dbb = tdbb->getDatabase();

	Function* check_function = NULL;

	// See if we already know the function by name

	for (Function** iter = attachment->att_functions.begin(); iter < attachment->att_functions.end(); ++iter)
	{
		Function* const function = *iter;

		if (function && !(function->fun_flags & FUN_obsolete) &&
			((function->fun_flags & FUN_scanned) || noscan) &&
			!(function->fun_flags & FUN_being_scanned) &&
			!(function->fun_flags & FUN_being_altered))
		{
			if (function->getName() == name)
			{
				if (function->fun_flags & FUN_check_existence)
				{
					check_function = function;
					LCK_lock(tdbb, check_function->fun_existence_lock, LCK_SR, LCK_WAIT);
					break;
				}

				return function;
			}
		}
	}

	// We need to look up the function in RDB$FUNCTIONS

	Function* function = NULL;

	AutoCacheRequest request(tdbb, irq_l_fun_name, IRQ_REQUESTS);

	FOR(REQUEST_HANDLE request)
		X IN RDB$FUNCTIONS
		WITH X.RDB$FUNCTION_NAME EQ name.identifier.c_str() AND
			 X.RDB$PACKAGE_NAME EQUIV NULLIF(name.package.c_str(), '')
	{
		function = loadMetadata(tdbb, X.RDB$FUNCTION_ID, noscan, 0);
	}
	END_FOR

	if (check_function)
	{
		check_function->fun_flags &= ~FUN_check_existence;
		if (check_function != function)
		{
			LCK_release(tdbb, check_function->fun_existence_lock);
			check_function->fun_flags |= FUN_obsolete;
		}
	}

	return function;
}

Function* Function::loadMetadata(thread_db* tdbb, USHORT id, bool noscan, USHORT flags)
{
	Jrd::Attachment* attachment = tdbb->getAttachment();
	jrd_tra* sysTransaction = attachment->getSysTransaction();
	Database* const dbb = tdbb->getDatabase();

	if (id >= attachment->att_functions.getCount())
		attachment->att_functions.grow(id + 1);

	Function* function = attachment->att_functions[id];

	if (function && !(function->fun_flags & FUN_obsolete))
	{
		// Make sure FUN_being_scanned and FUN_scanned are not set at the same time
		fb_assert(!(function->fun_flags & FUN_being_scanned) || !(function->fun_flags & FUN_scanned));

		if ((function->fun_flags & FUN_being_scanned) || (function->fun_flags & FUN_scanned))
		{
			return function;
		}
	}

	if (!function)
		function = FB_NEW(*attachment->att_pool) Function(*attachment->att_pool);

	try
	{
	function->fun_flags |= (FUN_being_scanned | flags);
	function->fun_flags &= ~FUN_obsolete;

	function->setId(id);
	attachment->att_functions[id] = function;

	if (!function->fun_existence_lock)
	{
		Lock* const lock = FB_NEW_RPT(*attachment->att_pool, 0) Lock;
		function->fun_existence_lock = lock;
		lock->lck_parent = dbb->dbb_lock;
		lock->lck_dbb = dbb;
		lock->lck_key.lck_long = function->getId();
		lock->lck_length = sizeof(lock->lck_key.lck_long);
		lock->lck_type = LCK_fun_exist;
		lock->lck_owner_handle = LCK_get_owner_handle(tdbb, lock->lck_type);
		lock->lck_object = function;
		lock->lck_ast = blockingAst;
	}

	LCK_lock(tdbb, function->fun_existence_lock, LCK_SR, LCK_WAIT);

	if (!noscan)
	{
		bool valid_blr = true;

		AutoCacheRequest request_fun(tdbb, irq_l_functions, IRQ_REQUESTS);

		Argument temp[MAX_UDF_ARGUMENTS + 1];

		FOR(REQUEST_HANDLE request_fun)
			X IN RDB$FUNCTIONS
			WITH X.RDB$FUNCTION_ID EQ id
		{
			function->setName(QualifiedName(X.RDB$FUNCTION_NAME,
				(X.RDB$PACKAGE_NAME.NULL ? NULL : X.RDB$PACKAGE_NAME)));

			if (!X.RDB$SECURITY_CLASS.NULL)
			{
				function->setSecurityName(X.RDB$SECURITY_CLASS);
			}
			else if (!X.RDB$PACKAGE_NAME.NULL)
			{
				AutoCacheRequest requestHandle(tdbb, irq_l_procedure_pkg_class, IRQ_REQUESTS);

				FOR (REQUEST_HANDLE requestHandle)
					PKG IN RDB$PACKAGES
					WITH PKG.RDB$PACKAGE_NAME EQ X.RDB$PACKAGE_NAME

					if (!PKG.RDB$SECURITY_CLASS.NULL)
					{
						function->setSecurityName(PKG.RDB$SECURITY_CLASS);
					}

				END_FOR
			}

			size_t count = 0;
			memset(temp, 0, sizeof(temp));
			ULONG length = 0;

			function->fun_inputs = 0;
			function->fun_defaults = 0;

			AutoCacheRequest request_arg(tdbb, irq_l_args, IRQ_REQUESTS);

			FOR(REQUEST_HANDLE request_arg)
				Y IN RDB$FUNCTION_ARGUMENTS
				WITH Y.RDB$FUNCTION_NAME EQ function->getName().identifier.c_str() AND
					 Y.RDB$PACKAGE_NAME EQUIV NULLIF(function->getName().package.c_str(), '')
				SORTED BY Y.RDB$ARGUMENT_POSITION
			{
				if (Y.RDB$ARGUMENT_POSITION != X.RDB$RETURN_ARGUMENT)
					function->fun_inputs++;

				Argument* const tail = temp + Y.RDB$ARGUMENT_POSITION;
				tail->fun_mechanism = (FUN_T) Y.RDB$MECHANISM;

				Parameter* const parameter = FB_NEW(*dbb->dbb_permanent) Parameter(*dbb->dbb_permanent);
				tail->fun_parameter = parameter;
				parameter->prm_number = Y.RDB$ARGUMENT_POSITION;
				parameter->prm_name = Y.RDB$ARGUMENT_NAME.NULL ? "" : Y.RDB$ARGUMENT_NAME;
				parameter->prm_nullable = Y.RDB$NULL_FLAG.NULL || Y.RDB$NULL_FLAG == 0;
				parameter->prm_mechanism = Y.RDB$ARGUMENT_MECHANISM.NULL ?
					prm_mech_normal : (prm_mech_t) Y.RDB$ARGUMENT_MECHANISM;

				const SSHORT collation_id_null = Y.RDB$COLLATION_ID.NULL;
				const SSHORT collation_id = Y.RDB$COLLATION_ID;

				SSHORT default_value_null = Y.RDB$DEFAULT_VALUE.NULL;
				bid default_value = Y.RDB$DEFAULT_VALUE;

				if (!Y.RDB$FIELD_SOURCE.NULL)
				{
					parameter->prm_field_source = Y.RDB$FIELD_SOURCE;

					AutoCacheRequest request_arg_fld(tdbb, irq_l_arg_fld, IRQ_REQUESTS);

					FOR(REQUEST_HANDLE request_arg_fld)
						F IN RDB$FIELDS
						WITH F.RDB$FIELD_NAME = Y.RDB$FIELD_SOURCE
					{
						DSC_make_descriptor(&parameter->prm_desc, F.RDB$FIELD_TYPE,
											F.RDB$FIELD_SCALE, F.RDB$FIELD_LENGTH,
											F.RDB$FIELD_SUB_TYPE, F.RDB$CHARACTER_SET_ID,
											(collation_id_null ? F.RDB$COLLATION_ID : collation_id));

						if (default_value_null && fb_utils::implicit_domain(F.RDB$FIELD_NAME))
						{
							default_value_null = F.RDB$DEFAULT_VALUE.NULL;
							default_value = F.RDB$DEFAULT_VALUE;
						}
					}
					END_FOR
				}
				else
				{
					DSC_make_descriptor(&parameter->prm_desc, Y.RDB$FIELD_TYPE,
										Y.RDB$FIELD_SCALE, Y.RDB$FIELD_LENGTH,
										Y.RDB$FIELD_SUB_TYPE, Y.RDB$CHARACTER_SET_ID,
										(collation_id_null ? 0 : collation_id));
				}

				if (Y.RDB$ARGUMENT_POSITION != X.RDB$RETURN_ARGUMENT && !default_value_null)
				{
					function->fun_defaults++;

					MemoryPool* const csb_pool = attachment->createPool();
					Jrd::ContextPoolHolder context(tdbb, csb_pool);

					try
					{
						parameter->prm_default_value = static_cast<ValueExprNode*>(MET_parse_blob(
							tdbb, NULL, &default_value, NULL, NULL, false, false));
					}
					catch (const Exception&)
					{
						attachment->deletePool(csb_pool);
						throw; // an explicit error message would be better
					}
				}

				if (tail->fun_parameter->prm_desc.dsc_dtype == dtype_cstring)
					tail->fun_parameter->prm_desc.dsc_length++;

				length += (tail->fun_parameter->prm_desc.dsc_dtype == dtype_blob) ?
					sizeof(udf_blob) : FB_ALIGN(tail->fun_parameter->prm_desc.dsc_length, FB_DOUBLE_ALIGN);

				count = MAX(count, size_t(Y.RDB$ARGUMENT_POSITION));
			}
			END_FOR

			function->fun_return_arg = X.RDB$RETURN_ARGUMENT;
			function->fun_temp_length = length;
			function->fun_args.resize(count + 1);
			memcpy(function->fun_args.begin(), temp, function->fun_args.getCount() * sizeof(Argument));

			// Prepare the exception message to be used in case this function ever
			// causes an exception.  This is done at this time to save us from preparing
			// (thus allocating) this message every time the function is called.
			function->fun_exception_message.printf(EXCEPTION_MESSAGE,
				function->getName().toString().c_str(), X.RDB$ENTRYPOINT, X.RDB$MODULE_NAME);

			if (!X.RDB$DETERMINISTIC_FLAG.NULL)
			{
				function->fun_deterministic = (X.RDB$DETERMINISTIC_FLAG != 0);
			}

			function->setUndefined(false);
			function->setImplemented(true);

			function->fun_entrypoint = NULL;
			function->fun_external = NULL;
			function->setStatement(NULL);

			if (!X.RDB$ENGINE_NAME.NULL)
			{
				HalfStaticArray<UCHAR, 512> body;

				if (!X.RDB$FUNCTION_SOURCE.NULL)
				{
					blb* const blob = BLB_open(tdbb, sysTransaction, &X.RDB$FUNCTION_SOURCE);
					const ULONG len = BLB_get_data(tdbb, blob,
						body.getBuffer(blob->blb_length + 1), blob->blb_length + 1);
					body[MIN(blob->blb_length, len)] = 0;
				}
				else
				{
					body.getBuffer(1)[0] = 0;
				}

				BlrMessage inBlr;
				inBlr.blr = NULL;
				inBlr.blrLength = 0;
				inBlr.bufferLength = 0;

				BlrMessage outBlr;
				outBlr.blr = NULL;
				outBlr.blrLength = 0;
				outBlr.bufferLength = 0;

				function->fun_external =
					dbb->dbb_extManager.makeFunction(tdbb, function, X.RDB$ENGINE_NAME,
					(X.RDB$ENTRYPOINT.NULL ? "" : X.RDB$ENTRYPOINT), (char*) body.begin(),
					&inBlr, &outBlr);

				if (!function->fun_external)
					function->setImplemented(false);

				function->makeFormat(tdbb, (inBlr.blr ? &inBlr : NULL), (outBlr.blr ? &outBlr : NULL));
			}
			else if (!X.RDB$FUNCTION_BLR.NULL)
			{
				MemoryPool* const csb_pool = attachment->createPool();
				Jrd::ContextPoolHolder context(tdbb, csb_pool);

				try
				{
					AutoPtr<CompilerScratch> csb(CompilerScratch::newCsb(*csb_pool, 5));

					if (!X.RDB$DEBUG_INFO.NULL)
						DBG_parse_debug_info(tdbb, &X.RDB$DEBUG_INFO, *csb->csb_dbg_info);

					try
					{
						function->parseBlr(tdbb, &X.RDB$FUNCTION_BLR, csb);
					}
					catch (const Exception&)
					{
						const string name = function->getName().toString();
						status_exception::raise(Arg::Gds(isc_bad_fun_BLR) << Arg::Str(name));
					}
				}
				catch (const Exception&)
				{
					attachment->deletePool(csb_pool);
					throw;
				}

				function->makeFormat(tdbb, NULL, NULL);
			}
			else if (!X.RDB$MODULE_NAME.NULL && !X.RDB$ENTRYPOINT.NULL)
			{
				function->fun_entrypoint =
					Module::lookup(X.RDB$MODULE_NAME, X.RDB$ENTRYPOINT, dbb->dbb_modules);

				// Could not find a function with given MODULE, ENTRYPOINT.
				// Try the list of internally implemented functions.
				if (!function->fun_entrypoint)
				{
					function->fun_entrypoint =
						BUILTIN_entrypoint(X.RDB$MODULE_NAME, X.RDB$ENTRYPOINT);
				}

				if (!function->fun_entrypoint)
				{
					function->setImplemented(false);
				}
			}
			else
			{
				function->setUndefined(true);
			}

			if (X.RDB$VALID_BLR.NULL || X.RDB$VALID_BLR == FALSE)
			{
				valid_blr = false;
			}

			function->fun_flags |= FUN_scanned;
		}
		END_FOR

		if (!(dbb->dbb_flags & DBB_read_only) && !valid_blr)
		{
			// if the BLR was marked as invalid but the function was compiled,
			// mark the BLR as valid

			AutoRequest request_set_valid;

			FOR(REQUEST_HANDLE request_set_valid)
				F IN RDB$FUNCTIONS WITH F.RDB$FUNCTION_ID EQ function->getId()
			{
				MODIFY F USING
					F.RDB$VALID_BLR = TRUE;
					F.RDB$VALID_BLR.NULL = FALSE;
				END_MODIFY
			}
			END_FOR
		}
	}

	// Make sure that it is really being scanned
	fb_assert(function->fun_flags & FUN_being_scanned);

	function->fun_flags &= ~FUN_being_scanned;

	}	// try
	catch (const Exception&)
	{
		function->fun_flags &= ~(FUN_being_scanned | FUN_scanned);

		if (function->fun_existence_lock)
		{
			LCK_release(tdbb, function->fun_existence_lock);
			function->fun_existence_lock = NULL;
		}

		throw;
	}

	return function;
}

int Function::blockingAst(void* ast_object)
{
	Function* const function = static_cast<Function*>(ast_object);

	try
	{
		Database* const dbb = function->fun_existence_lock->lck_dbb;
		Jrd::Attachment* att = function->fun_existence_lock->lck_attachment;

		Jrd::Attachment::SyncGuard guard(att);

		ThreadContextHolder tdbb;
		tdbb->setDatabase(dbb);
		tdbb->setAttachment(function->fun_existence_lock->lck_attachment);

		Jrd::ContextPoolHolder context(tdbb, 0);

		LCK_release(tdbb, function->fun_existence_lock);

		function->fun_flags |= FUN_obsolete;
	}
	catch (const Firebird::Exception&)
	{} // no-op

	return 0;
}

void Function::remove(thread_db* tdbb)
{
	if (fun_existence_lock)
	{
		LCK_release(tdbb, fun_existence_lock);
		delete fun_existence_lock;
		fun_existence_lock = NULL;
	}

	if (!(fun_flags & FUN_being_altered) && !fun_use_count)
	{
		delete this;
	}
	else
	{
		setName(QualifiedName());
		setSecurityName("");
		setId(0);
		fun_defaults = 0;
	}
}

ULONG Function::allocateImpure(CompilerScratch* csb) const
{
	const ULONG impure = CMP_impure(csb, sizeof(impure_value));

	if (fun_external || getStatement())
	{
		if (fun_in_msg_format.fmt_count)
		{
			fb_assert(fun_in_msg_format.fmt_length);
			CMP_impure(csb, fun_in_msg_format.fmt_length);
		}

		fb_assert(fun_out_msg_format.fmt_count == 2);
		fb_assert(fun_out_msg_format.fmt_length);
		CMP_impure(csb, fun_out_msg_format.fmt_length);

		if (fun_in_msg_format2.fmt_count)
		{
			fb_assert(fun_in_msg_format2.fmt_length);
			CMP_impure(csb, fun_in_msg_format2.fmt_length);
		}

		fb_assert(fun_out_msg_format2.fmt_count == 2 ||
			(fun_out_msg_format2.fmt_length == 0 && fun_out_msg_format2.fmt_count == 0));

		if (fun_out_msg_format2.fmt_length)
		{
			fb_assert(fun_out_msg_format2.fmt_count == 2);
			CMP_impure(csb, fun_out_msg_format2.fmt_length);
		}
		else
			fb_assert(fun_out_msg_format2.fmt_count == 0);
	}

	return impure;
}

void Function::parseBlr(thread_db* tdbb, bid* blob_id, CompilerScratch* csb)
{
	fb_assert(blob_id && !blob_id->isEmpty());

	JrdStatement* statement = getStatement();

	if (statement)
	{
		statement->release(tdbb);
		setStatement(NULL);
		statement = NULL;
	}

	MET_parse_blob(tdbb, NULL, blob_id, &csb, &statement, false, false);
	statement->function = this;
	setStatement(statement);
}

ValueListNode* Function::parseArgs(thread_db* tdbb, CompilerScratch* csb)
{
	const UCHAR arg_count = csb->csb_blr_reader.getByte();

	// Check to see if the argument count matches
	if (arg_count < fun_inputs - fun_defaults || arg_count > fun_inputs)
	{
		PAR_error(csb, Arg::Gds(isc_funmismat) << Arg::Str(getName().toString()));
	}

	ValueListNode* const args = PAR_args(tdbb, csb, arg_count, fun_inputs);

	for (USHORT i = arg_count; i < fun_inputs; i++)
	{
		Parameter* const parameter = fun_args[i + 1].fun_parameter;
		args->args[i] = CMP_clone_node(tdbb, csb, parameter->prm_default_value);
	}

	return args;
}

void Function::addRef()
{
	fun_use_count++;
}

void Function::release(thread_db* tdbb)
{
	if (fun_use_count)
	{
		fun_use_count--;

		Jrd::Attachment* attachment = tdbb->getAttachment();
		if (fun_use_count == 0 && attachment->att_functions[getId()] != this)
		{
			if (getStatement())
			{
				getStatement()->release(tdbb);
				setStatement(NULL);
			}
			fun_flags &= ~FUN_being_altered;
			remove(tdbb);
		}
	}
}

void Function::releaseLocks(thread_db* tdbb)
{
	if (fun_existence_lock)
	{
		LCK_release(tdbb, fun_existence_lock);
		fun_flags |= FUN_check_existence;
		fun_use_count = 0;
	}
}

dsc* Function::execute(thread_db* tdbb, const NestValueArray& args, impure_value* value,
	bool invariant) const
{
	if (isUndefined())
	{
		status_exception::raise(
			Arg::Gds(isc_func_pack_not_implemented) <<
				Arg::Str(getName().identifier) << Arg::Str(getName().package));
	}
	else if (!isImplemented())
	{
		status_exception::raise(
			Arg::Gds(isc_funnotdef) << Arg::Str(getName().toString()) << Arg::Gds(isc_modnotfound));
	}

	jrd_req* const request = tdbb->getRequest();

	const Argument* const return_ptr = &fun_args[fun_return_arg];
	value->vlu_desc = return_ptr->fun_parameter->prm_desc;

	// If the return data type is any of the string types,
	// allocate space to hold value

	if (value->vlu_desc.dsc_dtype <= dtype_varying)
	{
		const USHORT ret_length = value->vlu_desc.dsc_length;
		VaryingString* string = value->vlu_string;
		if (string && string->str_length < ret_length)
		{
			delete string;
			string = NULL;
		}
		if (!string)
		{
			string = FB_NEW_RPT(*tdbb->getDefaultPool(), ret_length) VaryingString;
			string->str_length = ret_length;
			value->vlu_string = string;
		}
		value->vlu_desc.dsc_address = string->str_data;
	}
	else
	{
		value->vlu_desc.dsc_address = (UCHAR*) &value->vlu_misc;
	}

	USHORT& invariant_flags = value->vlu_flags;

	// If the function is known as being both deterministic and invariant,
	// check whether it has already been evaluated

	if (fun_deterministic && invariant)
	{
		if (invariant_flags & VLU_computed)
		{
			if (invariant_flags & VLU_null)
				request->req_flags |= req_null;
			else
				request->req_flags &= ~req_null;

			return (request->req_flags & req_null) ? NULL : &value->vlu_desc;
		}
	}

	// Evaluate the function

	if (fun_entrypoint)
		FUN_evaluate(tdbb, this, args, value);
	else if (fun_external || getStatement())
	{
		fb_assert(!fun_return_arg);
		fb_assert(args.getCount() == fun_inputs);

		Jrd::Attachment* attachment = tdbb->getAttachment();

		const ULONG inMsgLength = fun_in_msg_format.fmt_length;
		const ULONG outMsgLength = fun_out_msg_format.fmt_length;

		UCHAR* const impure = reinterpret_cast<UCHAR*>(value);
		UCHAR* const inMsg = (UCHAR*) FB_ALIGN((IPTR) impure + sizeof(impure_value), FB_ALIGNMENT);
		UCHAR* const outMsg = (UCHAR*) FB_ALIGN((IPTR) inMsg + inMsgLength, FB_ALIGNMENT);

		const ULONG inMsgLength2 = fun_in_msg_format2.fmt_length;
		const ULONG outMsgLength2 = fun_out_msg_format2.fmt_length;
		UCHAR* const inMsg2 = inMsgLength2 ?
			(UCHAR*) FB_ALIGN((IPTR) outMsg + outMsgLength, FB_ALIGNMENT) : inMsg;
		UCHAR* const outMsg2 = outMsgLength2 ?
			(UCHAR*) FB_ALIGN((IPTR) inMsg2 + inMsgLength2, FB_ALIGNMENT) : outMsg;

		for (USHORT i = 0; i < fun_inputs; i++)
		{
			const ULONG argOffset = (IPTR) fun_in_msg_format.fmt_desc[i * 2].dsc_address;
			const ULONG nullOffset = (IPTR) fun_in_msg_format.fmt_desc[i * 2 + 1].dsc_address;
			SSHORT* const nullPtr = reinterpret_cast<SSHORT*>(inMsg + nullOffset);
			dsc argDesc = fun_args[i + 1].fun_parameter->prm_desc;
			argDesc.dsc_address = inMsg + argOffset;

			//// TODO: Validate constraints for external.
			dsc* const srcDesc = EVL_expr(tdbb, request, args[i]);
			if (srcDesc && !(request->req_flags & req_null))
			{
				*nullPtr = FALSE;
				MOV_move(tdbb, srcDesc, &argDesc);
			}
			else
				*nullPtr = TRUE;

			if (fun_external && inMsgLength2)
			{
				const ULONG argOffset2 = (IPTR) fun_in_msg_format2.fmt_desc[i * 2].dsc_address;
				const ULONG nullOffset2 = (IPTR) fun_in_msg_format2.fmt_desc[i * 2 + 1].dsc_address;
				SSHORT* const nullPtr2 = reinterpret_cast<SSHORT*>(inMsg2 + nullOffset2);

				if (!(*nullPtr2 = *nullPtr))
				{
					dsc argDesc2 = fun_in_msg_format2.fmt_desc[i * 2];
					argDesc2.dsc_address = inMsg2 + argOffset2;
					MOV_move(tdbb, &argDesc, &argDesc2);
				}
			}
		}

		const ULONG argOffset = (IPTR) fun_out_msg_format.fmt_desc[0].dsc_address;
		const ULONG nullOffset = (IPTR) fun_out_msg_format.fmt_desc[1].dsc_address;
		SSHORT* const nullPtr = reinterpret_cast<SSHORT*>(outMsg + nullOffset);
		dsc argDesc = fun_args[fun_return_arg].fun_parameter->prm_desc;
		argDesc.dsc_address = outMsg + argOffset;

		if (fun_external)
		{
			fun_external->execute(tdbb, inMsg2, outMsg2);

			if (outMsgLength2)
			{
				const ULONG argOffset2 = (IPTR) fun_out_msg_format2.fmt_desc[0].dsc_address;
				const ULONG nullOffset2 = (IPTR) fun_out_msg_format2.fmt_desc[1].dsc_address;
				SSHORT* const nullPtr2 = reinterpret_cast<SSHORT*>(outMsg2 + nullOffset2);

				if (!(*nullPtr = *nullPtr2))
				{
					dsc argDesc2 = fun_out_msg_format2.fmt_desc[0];
					argDesc2.dsc_address = outMsg2 + argOffset2;
					MOV_move(tdbb, &argDesc2, &argDesc);
				}
			}
		}
		else
		{
			jrd_req* const new_request = getStatement()->findRequest(tdbb);

			try
			{
				// Save the old pool
				Jrd::ContextPoolHolder context(tdbb, request->req_pool);

				jrd_tra* const transaction = request->req_transaction;
				const SLONG save_point_number = transaction->tra_save_point ?
					transaction->tra_save_point->sav_number : 0;

				new_request->req_timestamp = request->req_timestamp;

				EXE_start(tdbb, new_request, transaction);

				if (inMsgLength)
					EXE_send(tdbb, new_request, 0, inMsgLength, inMsg);

				fb_assert(outMsgLength);
				EXE_receive(tdbb, new_request, 1, outMsgLength, outMsg);

				// Clean up all savepoints started during execution of the function

				if (transaction != attachment->getSysTransaction())
				{
					for (const Savepoint* save_point = transaction->tra_save_point;
						 save_point && save_point_number < save_point->sav_number;
						 save_point = transaction->tra_save_point)
					{
						VIO_verb_cleanup(tdbb, transaction);
					}
				}
			}
			catch (const Firebird::Exception&)
			{
				tdbb->setRequest(request);
				EXE_unwind(tdbb, new_request);
				new_request->req_attachment = NULL;
				new_request->req_flags &= ~req_in_use;
				throw;
			}

			tdbb->setRequest(request);
			EXE_unwind(tdbb, new_request);
			new_request->req_attachment = NULL;
			new_request->req_flags &= ~req_in_use;
		}

		//// TODO: Validate constraints for external.
		if (*nullPtr)
			request->req_flags |= req_null;
		else
		{
			request->req_flags &= ~req_null;
			MOV_move(tdbb, &argDesc, &value->vlu_desc);
		}
	}
	else
		fb_assert(false);

	// If the function is declared as invariant, mark it as computed

	if (fun_deterministic && invariant)
	{
		invariant_flags |= VLU_computed;

		if (request->req_flags & req_null)
			invariant_flags |= VLU_null;
	}

	return (request->req_flags & req_null) ? NULL : &value->vlu_desc;
}

USHORT Function::incrementAlterCount()
{
	if (fun_alter_count == Function::MAX_ALTER_COUNT)
	{
		status_exception::raise(Arg::Gds(isc_no_meta_update) <<
				 Arg::Gds(isc_udf_name) << Arg::Str(getName().toString()) <<
				 Arg::Gds(isc_version_err));
	}

	return ++fun_alter_count;
}

void Function::makeFormat(thread_db* tdbb, const BlrMessage* inBlr, const BlrMessage* outBlr)
{
	// Input format

	bool messageNeeded = false;
	ULONG offset = 0;
	UCHAR maxAlignment = 0;
	USHORT count;

	dsc shortDesc;
	shortDesc.makeShort(0);

	if (inBlr)
	{
		BlrReader reader(inBlr->blr, inBlr->blrLength);

		reader.checkByte(blr_version5);
		reader.checkByte(blr_begin);
		reader.checkByte(blr_message);
		reader.getByte();	// message number: ignore it
		count = reader.checkWord(fun_inputs * 2);

		fun_in_msg_format2.fmt_desc.resize(count);
		fun_in_msg_format2.fmt_count = count;

		for (unsigned i = 0; i < count / 2; ++i)
		{
			dsc* desc = &fun_in_msg_format2.fmt_desc[i * 2];
			PAR_datatype(tdbb, reader, desc);

			if (desc->dsc_dtype >= dtype_aligned)
			{
				maxAlignment = MAX(maxAlignment, type_alignments[desc->dsc_dtype]);
				offset = FB_ALIGN(offset, type_alignments[desc->dsc_dtype]);
			}

			desc->dsc_address = (UCHAR*)(IPTR) offset;
			offset += desc->dsc_length;

			const dsc* prmDesc = &fun_args[i + 1].fun_parameter->prm_desc;

			if (desc->isText() && desc->getCharSet() == CS_NONE)
				desc->setTextType(prmDesc->getTextType());
			desc->setNullable(prmDesc->isNullable());

			messageNeeded |= !DSC_EQUIV(desc, prmDesc, false);

			++desc;
			PAR_datatype(tdbb, reader, desc);

			if (!DSC_EQUIV(desc, &shortDesc, false))
			{
				status_exception::raise(
					Arg::Gds(isc_ee_blr_mismatch_null) <<
					Arg::Num(i * 2 + 1));
			}

			offset = FB_ALIGN(offset, sizeof(SSHORT));
			desc->dsc_address = (UCHAR*)(IPTR) offset;
			offset += sizeof(SSHORT);

			messageNeeded |= !DSC_EQUIV(desc, &shortDesc, false);
		}

		reader.checkByte(blr_end);
		reader.checkByte(blr_eoc);

		if (offset != inBlr->bufferLength)
		{
			status_exception::raise(
				Arg::Gds(isc_ee_blr_mismatch_length) <<
				Arg::Num(inBlr->bufferLength) <<
				Arg::Num(offset));
		}

		if (messageNeeded)
		{
			// Pad the external message.
			offset = FB_ALIGN(offset, MAX(maxAlignment, sizeof(SSHORT)));

			if (offset > MAX_MESSAGE_SIZE)
				status_exception::raise(Arg::Gds(isc_imp_exc) << Arg::Gds(isc_blktoobig));

			fun_in_msg_format2.fmt_length = offset;
		}
		else
		{
			// The external and internal messages are compatible, so there is no need to create a new one.
			fun_in_msg_format2.fmt_desc.clear();
			fun_in_msg_format2.fmt_count = 0;
		}
	}

	count = fun_inputs * 2;
	fun_in_msg_format.fmt_desc.resize(count);
	fun_in_msg_format.fmt_count = count;

	offset = 0;
	maxAlignment = 0;

	for (USHORT i = 0; i < fun_inputs; i++)
	{
		dsc arg_desc = fun_args[i + 1].fun_parameter->prm_desc;

		if (arg_desc.dsc_dtype >= dtype_aligned)
		{
			maxAlignment = MAX(maxAlignment, type_alignments[arg_desc.dsc_dtype]);
			offset = FB_ALIGN(offset, type_alignments[arg_desc.dsc_dtype]);
		}

		arg_desc.dsc_address = (UCHAR*)(IPTR) offset;
		offset += arg_desc.dsc_length;
		fun_in_msg_format.fmt_desc[i * 2] = arg_desc;

		arg_desc.makeShort(0);
		offset = FB_ALIGN(offset, sizeof(SSHORT));
		arg_desc.dsc_address = (UCHAR*)(IPTR) offset;
		offset += sizeof(SSHORT);
		fun_in_msg_format.fmt_desc[i * 2 + 1] = arg_desc;
	}

	if (!messageNeeded)
	{
		// This message will be used by external. Pad it.
		offset = FB_ALIGN(offset, MAX(maxAlignment, sizeof(SSHORT)));
	}

	if (offset > MAX_MESSAGE_SIZE)
		status_exception::raise(Arg::Gds(isc_imp_exc) << Arg::Gds(isc_blktoobig));

	fun_in_msg_format.fmt_length = offset;

	// Output format

	messageNeeded = false;

	if (outBlr)
	{
		BlrReader reader(outBlr->blr, outBlr->blrLength);

		reader.checkByte(blr_version5);
		reader.checkByte(blr_begin);
		reader.checkByte(blr_message);
		reader.getByte();	// message number: ignore it
		count = reader.checkWord(2);

		fun_out_msg_format2.fmt_desc.resize(2);
		fun_out_msg_format2.fmt_count = 2;

		offset = 0;

		dsc* desc = &fun_out_msg_format2.fmt_desc[0];
		PAR_datatype(tdbb, reader, desc);

		if (desc->dsc_dtype >= dtype_aligned)
			offset = FB_ALIGN(offset, type_alignments[desc->dsc_dtype]);

		desc->dsc_address = (UCHAR*)(IPTR) offset;
		offset += desc->dsc_length;

		const dsc* prmDesc = &fun_args[fun_return_arg].fun_parameter->prm_desc;

		if (desc->isText() && desc->getCharSet() == CS_NONE)
			desc->setTextType(prmDesc->getTextType());
		desc->setNullable(prmDesc->isNullable());

		messageNeeded |= !DSC_EQUIV(desc, prmDesc, false);

		++desc;
		PAR_datatype(tdbb, reader, desc);

		if (!DSC_EQUIV(desc, &shortDesc, false))
		{
			status_exception::raise(
				Arg::Gds(isc_ee_blr_mismatch_null) <<
				Arg::Num(1));
		}

		offset = FB_ALIGN(offset, sizeof(SSHORT));
		desc->dsc_address = (UCHAR*)(IPTR) offset;
		offset += sizeof(SSHORT);

		messageNeeded |= !DSC_EQUIV(desc, &shortDesc, false);

		reader.checkByte(blr_end);
		reader.checkByte(blr_eoc);

		if (offset != outBlr->bufferLength)
		{
			status_exception::raise(
				Arg::Gds(isc_ee_blr_mismatch_length) <<
				Arg::Num(outBlr->bufferLength) <<
				Arg::Num(offset));
		}

		// Pad the external message.
		offset = FB_ALIGN(offset,
			MAX(type_alignments[fun_out_msg_format2.fmt_desc[0].dsc_dtype], sizeof(SSHORT)));

		if (messageNeeded)
			fun_out_msg_format2.fmt_length = offset;
		else
		{
			// The external and internal messages are compatible, so there is no need to create a new one.
			fun_out_msg_format2.fmt_desc.clear();
			fun_out_msg_format2.fmt_count = 0;
		}
	}

	fun_out_msg_format.fmt_desc.resize(2);
	fun_out_msg_format.fmt_count = 2;

	dsc ret_desc = fun_args[fun_return_arg].fun_parameter->prm_desc;
	ret_desc.dsc_address = (UCHAR*)(IPTR) 0;
	offset = ret_desc.dsc_length;
	fun_out_msg_format.fmt_desc[0] = ret_desc;

	ret_desc.makeShort(0);
	offset = FB_ALIGN(offset, sizeof(SSHORT));
	ret_desc.dsc_address = (UCHAR*)(IPTR) offset;
	offset += sizeof(SSHORT);
	fun_out_msg_format.fmt_desc[1] = ret_desc;

	if (!messageNeeded)
	{
		// This message will be used by external. Pad it.
		offset = FB_ALIGN(offset,
			MAX(type_alignments[fun_args[fun_return_arg].fun_parameter->prm_desc.dsc_dtype],
				sizeof(SSHORT)));
	}

	fun_out_msg_format.fmt_length = offset;
}
