/**************** history	************
*
*	COMPONENT: JRD	MODULE: SUN_FTN.C
*	generated by Marion V2.5     2/6/90
*	from dev              db	on 7-MAR-1995
*****************************************************************
*
*	19332	rkumar	7-MAR-1995
*	Calling convention error in ISC_MODIFY, ISC_ATTACH and ISC_FREE
*
*	19325	rkumar	7-MAR-1995 
*	Add entry point for ISC_FREE
*
*	19323	rkumar	7-MAR-1995 
*	A typo in the previous change
*
*	19322	rkumar	7-MAR-1995 
*	Add an entry point for ISC_MODIFY_DPB
*
*	19170	rkumar	9-FEB-1995 
*	change __ to _$
*
*	19054	rkumar	30-JAN-1995
*	One more mode on the ftn calling conventions problem
*
*	19034	rkumar	26-JAN-1995
*	to fix ftn calling convention problem for 4.0 isc_ calls
*
*	19015	rkumar	25-JAN-1995
*	parameter passing bug fix
*
*	19014	rkumar	25-JAN-1995
*	Further changes to 4.0 calling convention
*
*	18998	rkumar	24-JAN-1995
*	Fix bugs in fortran ISC_ calling convention
*
*	15607	katz	24-FEB-1994
*	Use ISC_STATUS to declare status vectors instead of SLONG
*
*	15078	daves	27-JAN-1994
*	ANSI compile error: fixed return result of isc_print_sqlerror
*
*	13615	katz	28-OCT-1993
*	Parameterize use of va_start
*
*	13380	katz	16-OCT-1993
*	Move away from C language datatypes
*
*	12467	katz	16-AUG-1993
*	Change exec_procedure to transact_request
*
 * The contents of this file are subject to the Interbase Public
 * License Version 1.0 (the "License"); you may not use this file
 * except in compliance with the License. You may obtain a copy
 * of the License at http://www.Inprise.com/IPL.html
 *
 * Software distributed under the License is distributed on an
 * "AS IS" basis, WITHOUT WARRANTY OF ANY KIND, either express
 * or implied. See the License for the specific language governing
 * rights and limitations under the License.
 *
 * The Original Code was created by Inprise Corporation
 * and its predecessors. Portions created by Inprise Corporation are
 * Copyright (C) Inprise Corporation.
 *
 * All Rights Reserved.
 * Contributor(s): ______________________________________.
*/


/*
 *	PROGRAM:	JRD Access Method
 *	MODULE:		sun_ftn.c
 *	DESCRIPTION:	"Wrapper" module which compensates for the
 *			Sun Fortran compiler appending an underscore
 *			to external entrypoints.  (Each function in
 *			this module is an InterBase entrypoint with
 *			an underscore appended to it which calls the
 *			real InterBase function).
 *
 * copyright (c) 1990, 1995 by Borland International
 */

#include "firebird.h"
#include "../jrd/common.h"
#include <stdarg.h>
#include "../jrd/gds.h"
#include "../jrd/perf.h"
#undef GDS_VAL
#define GDS_VAL(val)	(*val)

extern UCHAR *gds__alloc();

typedef ISC_STATUS(*PTR) ();

typedef struct handle {
	struct handle **user_handle;
} *HANDLE, *REQ, *DBB, *TRA, *BLB, *ATT, *OBJ, *BLK, *MAP, *WIN, *MENU, *STMT;

typedef struct {
	short array_bound_lower;
	short array_bound_upper;
} ARRAY_BOUND;

typedef struct {
	unsigned char array_desc_dtype;
	char array_desc_scale;
	unsigned short array_desc_length;
	char array_desc_field_name[32];
	char array_desc_relation_name[32];
	short array_desc_dimensions;
	short array_desc_flags;
	ARRAY_BOUND array_desc_bounds[16];
} ARRAY_DESC;

/* Transaction element block */

typedef struct teb {
	ATT *teb_database;
	int teb_tpb_length;
	UCHAR *teb_tpb;
} TEB;

#ifndef SQLDA_PROTOTYPE
#define SQLDA_PROTOTYPE		sqlda
#define SQLDA_ARG		SQLDA_PROTOTYPE
#endif

#define BLOB_DISPLAY		blob__display_
#define BLOB_DUMP		blob__dump_
#define BLOB_EDIT		blob__edit_
#define BLOB_LOAD		blob__load_

#define GDS_ALLOC		gds__alloc_
#define GDS_ATTACH_DATABASE	gds__attach_database_
#define GDS_BLOB_INFO		gds__blob_info_
#define GDS_BLOB_SIZE		gds__blob_size_
#define GDS_CANCEL_BLOB		gds__cancel_blob_
#define GDS_CANCEL_EVENTS	gds__cancel_events_
#define GDS_CLOSE		gds__close_
#define GDS_CLOSE_BLOB		gds__close_blob_
#define GDS_COMMIT		gds__commit_transaction_
#define GDS_COMMIT_RETAINING	gds__commit_retaining_
#define GDS_COMPILE		gds__compile_request_
#define GDS_COMPILE2		gds__compile_request2_
#define GDS_CREATE_BLOB		gds__create_blob_
#define GDS_CREATE_BLOB2	gds__create_blob2_
#define GDS_CREATE_DATABASE	gds__create_database_
#define GDS_DATABASE_INFO	gds__database_info_
#define GDS_DDL			gds__ddl_
#define GDS_DETACH		gds__detach_database_
#define GDS_DECLARE		gds__declare_
#define GDS_DECODE_DATE		gds__decode_date_
#define GDS_DESCRIBE		gds__describe_
#define GDS_DESCRIBE_BIND	gds__describe_bind_
#define GDS_DSQL_FINISH		gds__dsql_finish_
#define GDS_ENCODE_DATE		gds__encode_date_
#define GDS_EVENT_WAIT		gds__event_wait_
#define GDS_EXECUTE		gds__execute_
#define GDS_EXECUTE_IMMEDIATE	gds__execute_immediate_
#define GDS_EVENT_BLOCK_A	gds__event_block_a_
#define GDS_EVENT_COUNTS	gds__event_counts_
#define GDS_FREE		gds__free_
#define GDS_GET_SEGMENT		gds__get_segment_
#define GDS_GET_SLICE		gds__get_slice_
#define GDS_FETCH		gds__fetch_
#define GDS_FTOF		gds__ftof_
#define GDS_OPEN		gds__open_
#define GDS_OPEN_BLOB		gds__open_blob_
#define GDS_OPEN_BLOB2		gds__open_blob2_
#define GDS_PREPARE		gds__prepare_
#define GDS_PREPARE_TRANS	gds__prepare_transaction_
#define GDS_PREPARE2		gds__prepare_transaction2_
#define GDS_PRINT_STATUS	gds__print_status_
#define GDS_PUT_SEGMENT		gds__put_segment_
#define GDS_PUT_SLICE		gds__put_slice_
#define GDS_QTOQ		gds__qtoq_
#define GDS_QUE_EVENTS		gds__que_events_
#define GDS_RECONNECT		gds__reconnect_transaction_
#define GDS_RECEIVE		gds__receive_
#define GDS_RELEASE_REQUEST	gds__release_request_
#define GDS_REQUEST_INFO	gds__request_info_
#define GDS_ROLLBACK		gds__rollback_transaction_
#define GDS_SEEK_BLOB		gds__seek_blob_
#define GDS_SEND		gds__send_
#define GDS_SQLCODE		gds__sqlcode_
#define GDS_START		gds__start_request_
#define GDS_START_AND_SEND	gds__start_and_send_
#define GDS_START_MULTIPLE	gds__start_multiple_
#define GDS_START_TRANSACTION	gds__start_transaction_
#define GDS_TRANSACTION_INFO	gds__transaction_info_
#define GDS_UNWIND_REQUEST	gds__unwind_request_
#define GDS_VAX_INTEGER		gds__vax_integer_
#define GDS_VERSION		gds__version_

#define ISC_ARRAY_GEN_SDL	isc_array_gen_sdl_
#define ISC_ARRAY_GET_SLICE	isc_array_get_slice_
#define ISC_ARRAY_LOOKUP_BOUNDS	isc_array_lookup_bounds_
#define ISC_ARRAY_LOOKUP_DESC	isc_array_lookup_desc_
#define ISC_ARRAY_PUT_SLICE	isc_array_put_slice_
#define ISC_ARRAY_SET_DESC	isc_array_set_desc_
#define ISC_ATTACH_DATABASE	isc_attach_database_
#define ISC_MODIFY_DPB		isc_modify_dpb_
#define ISC_FREE		isc_free_
#define ISC_BADDRESS		isc_baddress_
#define ISC_BLOB_INFO		isc_blob_info_
#define ISC_CANCEL_BLOB		isc_cancel_blob_
#define ISC_CANCEL_EVENTS	isc_cancel_events_
#define ISC_CLOSE		isc_close_
#define ISC_CLOSE_BLOB		isc_close_blob_
#define ISC_COMMIT		isc_commit_transaction_
#define ISC_COMMIT_RETAINING	isc_commit_retaining_
#define ISC_COMPILE		isc_compile_request_
#define ISC_COMPILE2		isc_compile_request2_
#define ISC_CREATE_BLOB		isc_create_blob_
#define ISC_CREATE_BLOB2	isc_create_blob2_
#define ISC_CREATE_DATABASE	isc_create_database_
#define ISC_DATABASE_INFO	isc_database_info_
#define ISC_DDL			isc_ddl_
#define ISC_DECODE_DATE		isc_decode_date_
#define ISC_DECLARE		isc_declare_
#define ISC_DESCRIBE		isc_describe_
#define ISC_DESCRIBE_BIND	isc_describe_bind_
#define ISC_DETACH		isc_detach_database_
#define ISC_DROP_DATABASE	isc_drop_database_
#define ISC_DSQL_ALLOCATE	isc_dsql_allocate_statement_
#define ISC_DSQL_ALLOCATE2	isc_dsql_alloc_statement2_
#define ISC_DSQL_DESCRIBE	isc_dsql_describe_
#define ISC_DSQL_DESCRIBE_BIND	isc_dsql_describe_bind_
#define ISC_DSQL_EXEC_IMMED2	isc_dsql_exec_immed2_
#define ISC_DSQL_EXEC_IMMED2_M	isc_dsql_exec_immed2_m_
#define ISC_DSQL_EXECUTE	isc_dsql_execute_
#define ISC_DSQL_EXECUTE2	isc_dsql_execute2_
#define ISC_DSQL_EXECUTE_M	isc_dsql_execute_m_
#define ISC_DSQL_EXECUTE2_M	isc_dsql_execute2_m_
#define ISC_DSQL_EXECUTE_IMMED	isc_dsql_execute_immediate_
#define ISC_DSQL_EXECUTE_IMM_M	isc_dsql_execute_immediate_m_
#define ISC_DSQL_FETCH		isc_dsql_fetch_
#define ISC_DSQL_FETCH2		isc_dsql_fetch2_
#define ISC_DSQL_FETCH_M	isc_dsql_fetch_m_
#define ISC_DSQL_FETCH2_M	isc_dsql_fetch2_m_
#define ISC_DSQL_FINISH		isc_dsql_finish_
#define ISC_DSQL_FREE		isc_dsql_free_statement_
#define ISC_DSQL_INSERT		isc_dsql_insert_
#define ISC_DSQL_INSERT_M	isc_dsql_insert_m_
#define ISC_DSQL_PREPARE	isc_dsql_prepare_
#define ISC_DSQL_PREPARE_M	isc_dsql_prepare_m_
#define ISC_DSQL_RELEASE	isc_dsql_release_
#define ISC_DSQL_SET_CURSOR	isc_dsql_set_cursor_name_
#define ISC_DSQL_SQL_INFO	isc_dsql_sql_info_
#define ISC_EMBED_DSQL_CLOSE	isc_embed_dsql_close_
#define ISC_EMBED_DSQL_DECLARE	isc_embed_dsql_declare_
#define ISC_EMBED_DSQL_DESCR	isc_embed_dsql_describe_
#define ISC_EMBED_DSQL_DESCR_B	isc_embed_dsql_describe_bind_
#define ISC_EMBED_DSQL_EXEC_IM2	isc_embed_dsql_exec_immed2_
#define ISC_EMBED_DSQL_EXECUTE	isc_embed_dsql_execute_
#define ISC_EMBED_DSQL_EXECUTE2	isc_embed_dsql_execute2_
#define ISC_EMBED_DSQL_EXEC_IMM	isc_embed_dsql_execute_immed_
#define ISC_EMBED_DSQL_FETCH	isc_embed_dsql_fetch_
#define ISC_EMBED_DSQL_FETCH2	isc_embed_dsql_fetch2_
#define ISC_EMBED_DSQL_INSERT	isc_embed_dsql_insert_
#define ISC_EMBED_DSQL_LENGTH	isc_embed_dsql_length_
#define ISC_EMBED_DSQL_OPEN	isc_embed_dsql_open_
#define ISC_EMBED_DSQL_OPEN2	isc_embed_dsql_open2_
#define ISC_EMBED_DSQL_PREPARE	isc_embed_dsql_prepare_
#define ISC_EMBED_DSQL_RELEASE	isc_embed_dsql_release_
#define ISC_ENCODE_DATE		isc_encode_date_
#define ISC_EVENT_BLOCK_A	isc_event_block_a_
#define ISC_EVENT_COUNTS	isc_event_counts_
#define ISC_EXECUTE		isc_execute_
#define ISC_EXECUTE_IMMEDIATE	isc_execute_immediate_
#define ISC_FETCH		isc_fetch_
#define ISC_FTOF		isc_ftof_
#define ISC_GET_SEGMENT		isc_get_segment_
#define ISC_GET_SLICE		isc_get_slice_
#define ISC_OPEN		isc_open_
#define ISC_OPEN_BLOB		isc_open_blob_
#define ISC_OPEN_BLOB2		isc_open_blob2_
#define ISC_PREPARE		isc_prepare_
#define ISC_PREPARE_TRANS	isc_prepare_transaction_
#define ISC_PREPARE2		isc_prepare_transaction2_
#define ISC_PRINT_SQLERROR	isc_print_sqlerror_
#define ISC_PRINT_STATUS	isc_print_status_
#define ISC_PUT_SEGMENT		isc_put_segment_
#define ISC_PUT_SLICE		isc_put_slice_
#define ISC_QTOQ		isc_qtoq_
#define ISC_QUE_EVENTS		isc_que_events_
#define ISC_RECEIVE		isc_receive_
#define ISC_RECONNECT		isc_reconnect_transaction_
#define ISC_RELEASE_REQUEST	isc_release_request_
#define ISC_REQUEST_INFO	isc_request_info_
#define ISC_ROLLBACK		isc_rollback_transaction_
#define ISC_SEEK_BLOB		isc_seek_blob_
#define ISC_SEND		isc_send_
#define ISC_SQLCODE		isc_sqlcode_
#define ISC_START		isc_start_request_
#define ISC_START_AND_SEND	isc_start_and_send_
#define ISC_START_MULTIPLE	isc_start_multiple_
#define ISC_START_TRANSACTION	isc_start_transaction_
#define ISC_TRANSACT_REQUEST	isc_transact_request_
#define ISC_TRANSACTION_INFO	isc_transaction_info_
#define ISC_UNWIND_REQUEST	isc_unwind_request_
#define ISC_VAX_INTEGER		isc__vax_integer_
#define ISC_VERSION		isc_version_
#define ISC_WAIT_FOR_EVENT	isc_wait_for_event_

#define PERF_FORMAT		perf_format_
#define PERF_GET_INFO		perf_get_info_
#define PERF_REPORT		perf_report_



BLOB_EDIT(blob_id, database, transaction, field_name, name_length)
	 SLONG *blob_id;
	 int **database, *transaction;
	 SCHAR *field_name;
	 SLONG *name_length;
{
/**************************************
 *
 *	b l o b _ $ e d i t
 *
 **************************************
 *
 * Functional description
 *	Translate a pascal callable edit
 *	into an internal edit call.
 *
 **************************************/
	USHORT length;

	length = *name_length;
	return blob__edit(blob_id, database, transaction, field_name, &length);
}


BLOB_DISPLAY(blob_id, database, transaction, field_name, name_length)
	 SLONG *blob_id;
	 int **database, *transaction;
	 SCHAR *field_name;
	 SLONG *name_length;
{
/**************************************
 *
 *	b l o b _ $ d i s p l a y
 *
 **************************************
 *
 * Functional description
 *	just dump a blob to the screen
 *
 **************************************/
	USHORT length;

	length = *name_length;

	return blob__display(blob_id, database, transaction, field_name, &length);
}


BLOB_DUMP(blob_id, database, transaction, file_name, length)
	 SLONG *blob_id;
	 int **database, *transaction;
	 SCHAR *file_name;
	 SLONG GDS_VAL(length);
{
/**************************************
 *
 *	B L O B _ d u m p
 *
 **************************************
 *
 * Functional description
 *	Dump a blob into a file.
 *
 **************************************/
	USHORT len;

	len = *length;

	return blob__dump(blob_id, database, transaction, file_name, &len);
}


BLOB_LOAD(blob_id, database, transaction, file_name, name_length)
	 SLONG *blob_id;
	 int **database, *transaction;
	 SCHAR *file_name;
	 SLONG GDS_VAL(name_length);
{
/**************************************
 *
 *	b l o b _ $ l o a d
 *
 **************************************
 *
 * Functional description
 *	Translate a Fortran callable load
 *	into an internal load call.
 *
 **************************************/
	USHORT length;

	length = *name_length;

	return blob__load(blob_id, database, transaction, file_name, &length);
}


UCHAR *GDS_ALLOC(size)
	 SLONG GDS_VAL(size);
{
/**************************************
 *
 *	g d s _ $ a l l o c
 *
 **************************************
 *
 * Functional description
 *	Allocate a block of memory.
 *
 **************************************/

	return gds__alloc(size);
}


ISC_STATUS GDS_ATTACH_DATABASE(user_status, file_length, file_name, handle,
						   dpb_length, dpb)
	 ISC_STATUS *user_status;
	 SLONG GDS_VAL(file_length);
	 SCHAR *file_name;
	 ATT *handle;
	 SLONG GDS_VAL(dpb_length);
	 SCHAR *dpb;
{
/**************************************
 *
 *	g d s _ $ a t t a c h _ d a t a b a s e
 *
 **************************************
 *
 * Functional description
 *	Attach a database through the first subsystem
 *	that recognizes it.
 *
 **************************************/

	return gds__attach_database(user_status,
								(SSHORT) * file_length, file_name, handle,
								(SSHORT) * dpb_length, dpb);
}


ISC_STATUS GDS_BLOB_INFO(user_status, blob_handle, item_length, items,
					 buffer_length, buffer)
	 ISC_STATUS *user_status;
	 BLB *blob_handle;
	 SLONG GDS_VAL(item_length), GDS_VAL(buffer_length);
	 SCHAR *items, *buffer;
{
/**************************************
 *
 *	g d s _ $ b l o b _ i n f o
 *
 **************************************
 *
 * Functional description
 *	Provide information on blob object.
 *
 **************************************/

	return gds__blob_info(user_status, blob_handle, (SSHORT) * item_length,
						  items, (SSHORT) * buffer_length, buffer);
}


int GDS_BLOB_SIZE(b, size, seg_count, max_seg)
	 SLONG *b, *size, *seg_count, *max_seg;
{
/**************************************
 *
 *	g d s _ $ b l o b _ s i z e 
 *
 **************************************
 *
 * Functional description
 *	Get the size, number of segments, and max
 *	segment length of a blob.  Return true
 *	if it happens to succeed.
 *
 **************************************/

	return gds__blob_size(b, size, seg_count, max_seg);
}


ISC_STATUS GDS_CANCEL_BLOB(user_status, blob_handle)
	 ISC_STATUS *user_status;
	 BLB *blob_handle;
{
/**************************************
 *
 *	g d s _ $ c a n c e l _ b l o b
 *
 **************************************
 *
 * Functional description
 *	Abort a partially completed blob.
 *
 **************************************/

	return gds__cancel_blob(user_status, blob_handle);
}


ISC_STATUS GDS_CANCEL_EVENTS(user_status, handle, id)
	 ISC_STATUS *user_status;
	 ATT *handle;
	 SLONG *id;
{
/**************************************
 *
 *	g d s _ $ c a n c e l _ e v e n t s
 *
 **************************************
 *
 * Functional description
 *	Try to cancel an event.
 *
 **************************************/

	return gds__cancel_events(user_status, handle, id);
}


GDS_CLOSE(user_status, name)
	 ISC_STATUS *user_status;
	 TEXT *name;
{
/**************************************
 *
 *	g d s _ $ c l o s e
 *
 **************************************
 *
 * Functional description
 *	Close a dynamic SQL cursor.
 *
 **************************************/

	return gds__close(user_status, name);
}


ISC_STATUS GDS_CLOSE_BLOB(user_status, blob_handle)
	 ISC_STATUS *user_status;
	 BLB *blob_handle;
{
/**************************************
 *
 *	g d s _ $ c l o s e _ b l o b
 *
 **************************************
 *
 * Functional description
 *	Abort a partially completed blob.
 *
 **************************************/

	return gds__close_blob(user_status, blob_handle);
}


ISC_STATUS GDS_COMMIT(user_status, tra_handle)
	 ISC_STATUS *user_status;
	 TRA *tra_handle;
{
/**************************************
 *
 *	g d s _ $ c o m m i t
 *
 **************************************
 *
 * Functional description
 *	Commit a transaction.
 *
 **************************************/

	return gds__commit_transaction(user_status, tra_handle);
}


ISC_STATUS GDS_COMMIT_RETAINING(user_status, tra_handle)
	 ISC_STATUS *user_status;
	 TRA *tra_handle;
{
/**************************************
 *
 *	g d s _ $ c o m m i t _ r e t a i n i n g
 *
 **************************************
 *
 * Functional description
 *	Do a commit retaining.
 *
 **************************************/

	return gds__commit_retaining(user_status, tra_handle);
}


ISC_STATUS GDS_COMPILE(user_status, db_handle, req_handle, blr_length, blr)
	 ISC_STATUS *user_status;
	 ATT *db_handle;
	 REQ *req_handle;
	 SLONG GDS_VAL(blr_length);
	 SCHAR *blr;
{
/**************************************
 *
 *	g d s _ $ c o m p i l e
 *
 **************************************
 *
 * Functional description
 *
 **************************************/

	return gds__compile_request(user_status, db_handle, req_handle,
								(SSHORT) * blr_length, blr);
}


ISC_STATUS GDS_COMPILE2(user_status, db_handle, req_handle, blr_length, blr)
	 ISC_STATUS *user_status;
	 ATT *db_handle;
	 REQ *req_handle;
	 SLONG GDS_VAL(blr_length);
	 SCHAR *blr;
{
/**************************************
 *
 *	g d s _ $ c o m p i l e 2
 *
 **************************************
 *
 * Functional description
 *
 **************************************/

	return gds__compile_request2(user_status, db_handle, req_handle,
								 (SSHORT) * blr_length, blr);
}


ISC_STATUS GDS_CREATE_BLOB(user_status, db_handle, tra_handle, blob_handle,
					   blob_id)
	 ISC_STATUS *user_status;
	 ATT *db_handle;
	 TRA *tra_handle;
	 BLB *blob_handle;
	 SLONG *blob_id;
{
/**************************************
 *
 *	g d s _ $ c r e a t e _ b l o b
 *
 **************************************
 *
 * Functional description
 *	Open an existing blob.
 *
 **************************************/

	return gds__create_blob(user_status, db_handle, tra_handle, blob_handle,
							blob_id);
}


ISC_STATUS GDS_CREATE_BLOB2(user_status, db_handle, tra_handle, blob_handle,
						blob_id, bpb_length, bpb)
	 ISC_STATUS *user_status;
	 ATT *db_handle;
	 TRA *tra_handle;
	 BLB *blob_handle;
	 SLONG *blob_id;
	 SLONG GDS_VAL(bpb_length);
	 UCHAR *bpb;
{
/**************************************
 *
 *	g d s _ $ c r e a t e _ b l o b 2
 *
 **************************************
 *
 * Functional description
 *	Open an existing blob.
 *
 **************************************/

	return gds__create_blob2(user_status, db_handle, tra_handle, blob_handle,
							 blob_id, (SSHORT) * bpb_length, bpb);
}


ISC_STATUS GDS_CREATE_DATABASE(user_status, file_length, file_name, handle,
						   dpb_length, dpb, db_type)
	 ISC_STATUS *user_status;
	 SLONG GDS_VAL(file_length);
	 UCHAR *file_name;
	 ATT *handle;
	 SLONG GDS_VAL(dpb_length);
	 UCHAR *dpb;
	 SLONG GDS_VAL(db_type);
{
/**************************************
 *
 *	g d s _ $ c r e a t e _ d a t a b a s e
 *
 **************************************
 *
 * Functional description
 *	Create a nice, squeaky clean database, uncorrupted by user data.
 *
 **************************************/

	return gds__create_database(user_status, (SSHORT) * file_length,
								file_name, handle, (SSHORT) * dpb_length, dpb,
								(SSHORT) * db_type);
}


ISC_STATUS GDS_DATABASE_INFO(user_status, handle, item_length, items,
						 buffer_length, buffer)
	 ISC_STATUS *user_status;
	 ATT *handle;
	 SLONG GDS_VAL(item_length), GDS_VAL(buffer_length);
	 SCHAR *items, *buffer;
{
/**************************************
 *
 *	g d s _ $ d a t a b a s e _ i n f o
 *
 **************************************
 *
 * Functional description
 *	Provide information on database object.
 *
 **************************************/

	return gds__database_info(user_status, handle, (SSHORT) * item_length,
							  items, (SSHORT) * buffer_length, buffer);
}


ISC_STATUS GDS_DDL(user_status, db_handle, tra_handle, length, ddl)
	 ISC_STATUS *user_status;
	 ATT *db_handle;
	 TRA *tra_handle;
	 SLONG GDS_VAL(length);
	 UCHAR *ddl;
{
/**************************************
 *
 *	g d s _ $ d d l
 *
 **************************************
 *
 * Functional description
 *	Do meta-data update.
 *
 **************************************/

	return gds__ddl(user_status, db_handle, tra_handle, (SSHORT) * length,
					ddl);
}


GDS_DECLARE(user_status, statement, cursor)
	 ISC_STATUS *user_status;
	 TEXT *statement, *cursor;
{
/**************************************
 *
 *	g d s _ $ d e c l a r e
 *
 **************************************
 *
 * Functional description
 *	Declare a cursor for a dynamic request.
 *
 **************************************/

	return gds__declare(user_status, statement, cursor);
}


void GDS_DECODE_DATE(date, times)
	 SLONG date[2];
	 struct tm *times;
{
/**************************************
 *
 *	g d s _ $ d e c o d e
 *
 **************************************
 *
 * Functional description
 *	Convert from internal date format to UNIX time structure.
 *
 **************************************/

	gds__decode_date(date, times);
}


GDS_DESCRIBE(user_status, name, sqlda)
	 ISC_STATUS *user_status;
	 TEXT *name;
	 XSQLDA *sqlda;
{
/**************************************
 *
 *	g d s _ $ d e s c r i b e
 *
 **************************************
 *
 * Functional description
 *	Describe output parameters for a prepared statement.
 *
 **************************************/

	return gds__describe(user_status, name, sqlda);
}


GDS_DESCRIBE_BIND(user_status, name, sqlda)
	 ISC_STATUS *user_status;
	 TEXT *name;
	 XSQLDA *sqlda;
{
/**************************************
 *
 *	g d s _ $ d e s c r i b e _ b i n d
 *
 **************************************
 *
 * Functional description
 *	Describe input parameters for a prepared statement.
 *
 **************************************/

	return gds__describe_bind(user_status, name, sqlda);
}


ISC_STATUS GDS_DETACH(user_status, handle)
	 ISC_STATUS *user_status;
	 ATT *handle;
{
/**************************************
 *
 *	g d s _ $ d e t a c h
 *
 **************************************
 *
 * Functional description
 *	Close down a database.
 *
 **************************************/

	return gds__detach_database(user_status, handle);
}



GDS_DSQL_FINISH(db_handle)
	 SLONG **db_handle;
{
/**************************************
 *
 *	g d s _ $ d s q l _ f i n i s h
 *
 **************************************
 *
 * Functional description
 *	Clean up DSQL globals
 *
 **************************************/

	return gds__dsql_finish(db_handle);
}



void GDS_ENCODE_DATE(times, date)
	 struct tm *times;
	 SLONG date[2];
{
/**************************************
 *
 *	g d s _ $ e n c o d e
 *
 **************************************
 *
 * Functional description
 *	Convert from UNIX time structure to internal date format.
 *
 **************************************/

	gds__encode_date(times, date);
}


USHORT GDS_EVENT_BLOCK_A(event_buffer, result_buffer, count, name_buffer)
	 UCHAR **event_buffer, **result_buffer;
	 SLONG GDS_VAL(count);
	 UCHAR **name_buffer;
{
/**************************************
 *
 *	g d s _ $ e v e n t _ b l o c k _ a 
 *
 **************************************
 *
 * Functional description
 *	Create an initialized event parameter block from a
 *	vector of input arguments. (Ada needs this)
 *	Assume all strings are 31 characters long.
 *	Return the size of the block.
 *
 **************************************/

	return gds__event_block_a(event_buffer, result_buffer, (USHORT) * count,
							  name_buffer);
}


void GDS_EVENT_COUNTS(result_vector, buffer_length, event_buffer,
					  result_buffer)
	 ULONG *result_vector;
	 USHORT GDS_VAL(buffer_length);
	 UCHAR **event_buffer, **result_buffer;
{
/**************************************
 *
 *	g d s _ $ e v e n t _ c o u n t s
 *
 **************************************
 *
 * Functional description
 *	Get the delta between two events in an event
 *	parameter block.  Used to update gds__events
 *	for GPRE support of events.
 *
 **************************************/

	gds__event_counts(result_vector, (USHORT) * buffer_length, *event_buffer,
					  *result_buffer);
}


ISC_STATUS GDS_EVENT_WAIT(user_status, handle, length, events, buffer)
	 ULONG *user_status;
	 ATT *handle;
	 USHORT GDS_VAL(length);
	 UCHAR **events, **buffer;
{
/**************************************
 *
 *	g d s _ $ e v e n t _ w a i t
 *
 **************************************
 *
 * Functional description
 *	Que request for event notification.
 *
 **************************************/

	return gds__event_wait(user_status, handle, (USHORT) * length, *events,
						   *buffer);
}


GDS_EXECUTE(user_status, trans_handle, name, sqlda)
	 ISC_STATUS *user_status;
	 TEXT *name;
	 TRA *trans_handle;
	 XSQLDA *sqlda;
{
/**************************************
 *
 *	g d s _ $ e x e c u t e
 *
 **************************************
 *
 * Functional description
 *	Execute a non-SELECT dynamic SQL statement.
 *
 **************************************/

	return gds__execute(user_status, trans_handle, name, sqlda);
}



GDS_EXECUTE_IMMEDIATE(user_status, db_handle, trans_handle, length, string)
	 ISC_STATUS *user_status;
	 int **db_handle, **trans_handle;
	 SLONG *length;
	 TEXT *string;
{
/**************************************
 *
 *	g d s _ $ e x e c u t e _ i m m e d i a t e
 *
 **************************************
 *
 * Functional description
 *	Prepare a statement for execution.
 *
 **************************************/
	USHORT len;

	len = *length;
	return gds__execute_immediate(user_status, db_handle,
								  trans_handle, &len, string);
}


GDS_FETCH(user_status, name, sqlda)
	 ISC_STATUS *user_status;
	 TEXT *name;
	 XSQLDA *sqlda;
{
/**************************************
 *
 *	g d s _ $ f e t c h
 *
 **************************************
 *
 * Functional description
 *	Fetch next record from a dynamic SQL cursor
 *
 **************************************/
	return gds__fetch(user_status, name, sqlda);
}


SLONG GDS_FREE(blk)
	 SLONG *blk;
{
/**************************************
 *
 *	g d s _ $ f r e e
 *
 **************************************
 *
 * Functional description
 *	Release a block allocated by gds__alloc.  Return number
 *	of bytes released.
 *
 **************************************/

	return gds__free(blk);
}


GDS_FTOF(string, length1, field, length2)
	 SCHAR *string, *field;
	 SLONG GDS_VAL(length1), GDS_VAL(length2);
{
/**************************************
 *
 *	G D S _ f t o f
 *
 **************************************
 *
 * Functional description
 *	Move a fixed length string to a fixed length string.
 *	This is typically generated by the preprocessor to
 *	move strings around.
 *
 **************************************/

	gds__ftof(string, (SSHORT) * length1, field, (SSHORT) * length2);
}


ISC_STATUS GDS_GET_SEGMENT(user_status, blob_handle, length, buffer_length,
					   buffer)
	 ISC_STATUS *user_status;
	 BLB *blob_handle;
	 SSHORT *length;
	 SLONG GDS_VAL(buffer_length);
	 SCHAR *buffer;
{
/**************************************
 *
 *	g d s _ $ g e t _ s e g m e n t
 *
 **************************************
 *
 * Functional description
 *	Abort a partially completed blob.
 *
 **************************************/
	ISC_STATUS status;
	SSHORT return_length;

	status = gds__get_segment(user_status, blob_handle,
							  &return_length, (SSHORT) * buffer_length,
							  buffer);
	*length = return_length;

	return status;
}


ISC_STATUS GDS_GET_SLICE(user_status, db_handle, tra_handle, array_id,
					 sdl_length, sdl, param_length, param, slice_length,
					 slice, return_length)
	 ISC_STATUS *user_status;
	 ATT *db_handle;
	 TRA *tra_handle;
	 SLONG *array_id;
	 SLONG GDS_VAL(sdl_length);
	 UCHAR *sdl;
	 SLONG GDS_VAL(param_length);
	 UCHAR *param;
	 SLONG GDS_VAL(slice_length);
	 UCHAR *slice;
	 SLONG *return_length;
{
/**************************************
 *
 *	g d s _ $ g e t _ s l i c e
 *
 **************************************
 *
 * Functional description
 *	Snatch a slice of an array.
 *
 **************************************/

	return gds__get_slice(user_status, db_handle, tra_handle, array_id,
						  (SSHORT) * sdl_length, sdl,
						  (SSHORT) * param_length, param,
						  *slice_length, slice, return_length);
}


GDS_OPEN(user_status, trans_handle, name, sqlda)
	 ISC_STATUS *user_status;
	 TEXT *name;
	 TRA *trans_handle;
	 XSQLDA *sqlda;
{
/**************************************
 *
 *	g d s _ $ o p e n
 *
 **************************************
 *
 * Functional description
 *	Open a dynamic SQL cursor.
 *
 **************************************/

	return gds__open(user_status, trans_handle, name, sqlda);
}


ISC_STATUS GDS_OPEN_BLOB(user_status, db_handle, tra_handle, blob_handle, blob_id)
	 ISC_STATUS *user_status;
	 ATT *db_handle;
	 TRA *tra_handle;
	 BLB *blob_handle;
	 SLONG *blob_id;
{
/**************************************
 *
 *	g d s _ $ o p e n _ b l o b
 *
 **************************************
 *
 * Functional description
 *	Open an existing blob.
 *
 **************************************/

	return gds__open_blob(user_status, db_handle, tra_handle, blob_handle,
						  blob_id);
}


ISC_STATUS GDS_OPEN_BLOB2(user_status, db_handle, tra_handle, blob_handle,
					  blob_id, bpb_length, bpb)
	 ISC_STATUS *user_status;
	 ATT *db_handle;
	 TRA *tra_handle;
	 BLB *blob_handle;
	 SLONG *blob_id;
	 SLONG GDS_VAL(bpb_length);
	 UCHAR *bpb;
{
/**************************************
 *
 *	g d s _ $ o p e n _ b l o b 2
 *
 **************************************
 *
 * Functional description
 *	Open an existing blob (extended edition).
 *
 **************************************/

	return gds__open_blob2(user_status, db_handle, tra_handle, blob_handle,
						   blob_id, (SSHORT) * bpb_length, bpb);
}


GDS_PREPARE(user_status, db_handle, trans_handle, name, length, string, sqlda)
	 ISC_STATUS *user_status;
	 int **db_handle, **trans_handle;
	 TEXT *name;
	 SLONG *length;
	 TEXT *string;
	 XSQLDA *sqlda;
{
/**************************************
 *
 *	g d s _ $ p r e p a r e
 *
 **************************************
 *
 * Functional description
 *	Prepare a dsql statement for execution.
 *
 **************************************/
	USHORT len;

	len = *length;

	return gds__prepare(user_status, db_handle, trans_handle, name,
						&len, string, sqlda);
}


ISC_STATUS GDS_PREPARE_TRANS(user_status, tra_handle)
	 ISC_STATUS *user_status;
	 TRA *tra_handle;
{
/**************************************
 *
 *	g d s _ $ p r e p a r e _ t r a n s a c t i o n
 *
 **************************************
 *
 * Functional description
 *	Prepare a transaction for commit.  First 
 *	phase of a two phase commit.
 *
 **************************************/

	return gds__prepare_transaction(user_status, tra_handle);
}


ISC_STATUS GDS_PREPARE2(user_status, tra_handle, msg_length, msg)
	 ISC_STATUS *user_status;
	 TRA *tra_handle;
	 SLONG GDS_VAL(msg_length);
	 UCHAR *msg;
{
/**************************************
 *
 *	g d s _ $ p r e p a r e 2
 *
 **************************************
 *
 * Functional description
 *	Prepare a transaction for commit.  First phase of a two
 *	phase commit.
 *
 **************************************/

	return gds__prepare_transaction2(user_status, tra_handle,
									 (SSHORT) * msg_length, msg);
}


GDS_PRINT_STATUS(status_vector)
	 ISC_STATUS *status_vector;
{
/**************************************
 *
 *	g d s _ $ p r i n t _ s t a t u s
 *
 **************************************
 *
 * Functional description
 *	Print status vector.
 *
 **************************************/

	return gds__print_status(status_vector);
}


ISC_STATUS GDS_PUT_SEGMENT(user_status, blob_handle, buffer_length, buffer)
	 ISC_STATUS *user_status;
	 BLB *blob_handle;
	 SSHORT GDS_VAL(buffer_length);
	 SCHAR *buffer;
{
/**************************************
 *
 *	g d s _ $ p u t _ s e g m e n t
 *
 **************************************
 *
 * Functional description
 *	Store one piece of a blob
 *
 **************************************/

	return gds__put_segment(user_status, blob_handle, *buffer_length, buffer);
}


ISC_STATUS GDS_PUT_SLICE(user_status, db_handle, tra_handle, array_id,
					 sdl_length, sdl, param_length, param, slice_length,
					 slice)
	 ISC_STATUS *user_status;
	 ATT *db_handle;
	 TRA *tra_handle;
	 SLONG *array_id;
	 SLONG GDS_VAL(sdl_length);
	 UCHAR *sdl;
	 SLONG GDS_VAL(param_length);
	 UCHAR *param;
	 SLONG GDS_VAL(slice_length);
	 UCHAR *slice;
{
/**************************************
 *
 *	g d s _ $ p u t _ s l i c e
 *
 **************************************
 *
 * Functional description
 *	Snatch a slice of an array.
 *
 **************************************/

	return gds__put_slice(user_status, db_handle, tra_handle, array_id,
						  (SSHORT) * sdl_length, sdl,
						  (SSHORT) * param_length, param,
						  *slice_length, slice);
}


void GDS_QTOQ(quad_in, quad_out)
	 GDS__QUAD *quad_in, *quad_out;
{
/**************************************
 *
 *	G D S _ q t o q
 *
 **************************************
 *
 * Functional description
 *	Move a quad value to another quad value.  This
 *      call is generated by the preprocessor when assigning
 *      quad values in FORTRAN.
 *
 **************************************/

	gds__qtoq(quad_in, quad_out);
}


ISC_STATUS GDS_QUE_EVENTS(user_status, handle, id, length, events, ast, arg)
	 ISC_STATUS *user_status;
	 ATT *handle;
	 SLONG *id;
	 USHORT GDS_VAL(length);
	 UCHAR *events;
	 int (*ast) ();
	 SLONG arg;
{
/**************************************
 *
 *	g d s _ $ q u e _ e v e n t s
 *
 **************************************
 *
 * Functional description
 *	Que request for event notification.
 *
 **************************************/

	return gds__que_events(user_status, handle, id,
						   (USHORT) * length, events, ast, arg);
}


ISC_STATUS GDS_RECEIVE(user_status, req_handle, msg_type, msg_length, msg, level)
	 ISC_STATUS *user_status;
	 REQ *req_handle;
	 SLONG GDS_VAL(msg_type), GDS_VAL(msg_length);
	 SCHAR *msg;
	 SLONG GDS_VAL(level);
{
/**************************************
 *
 *	g d s _ $ r e c e i v e
 *
 **************************************
 *
 * Functional description
 *	Get a record from the host program.
 *
 **************************************/

	return gds__receive(user_status, req_handle,
						(SSHORT) * msg_type, (SSHORT) * msg_length, msg,
						(SSHORT) * level);
}


ISC_STATUS GDS_RECONNECT(user_status, db_handle, tra_handle, length, id)
	 ISC_STATUS *user_status;
	 ATT *db_handle;
	 TRA *tra_handle;
	 SLONG GDS_VAL(length);
	 UCHAR *id;
{
/**************************************
 *
 *	g d s _ $ r e c o n n e c t
 *
 **************************************
 *
 * Functional description
 *	Connect to a transaction in limbo.
 *
 **************************************/

	return gds__reconnect_transaction(user_status, db_handle,
									  tra_handle, (SSHORT) * length, id);
}


ISC_STATUS GDS_RELEASE_REQUEST(user_status, req_handle)
	 ISC_STATUS *user_status;
	 REQ *req_handle;
{
/**************************************
 *
 *	g d s _ $ r e l e a s e _ r e q u e s t
 *
 **************************************
 *
 * Functional description
 *	Release a request.
 *
 **************************************/

	return gds__release_request(user_status, req_handle);
}


ISC_STATUS GDS_REQUEST_INFO(user_status, req_handle, level, item_length, items,
						buffer_length, buffer)
	 ISC_STATUS *user_status;
	 REQ *req_handle;
	 SLONG GDS_VAL(item_length), GDS_VAL(buffer_length);
	 SCHAR *items, *buffer;
	 SLONG GDS_VAL(level);
{
/**************************************
 *
 *	g d s _ $ r e q u e s t _ i n f o
 *
 **************************************
 *
 * Functional description
 *	Provide information on blob object.
 *
 **************************************/

	return gds__request_info(user_status, req_handle,
							 (SSHORT) * level, (SSHORT) * item_length, items,
							 (SSHORT) * buffer_length, buffer);
}


ISC_STATUS GDS_ROLLBACK(user_status, tra_handle)
	 ISC_STATUS *user_status;
	 TRA *tra_handle;
{
/**************************************
 *
 *	g d s _ $ r o l l b a c k
 *
 **************************************
 *
 * Functional description
 *	Abort a transaction.
 *
 **************************************/

	return gds__rollback_transaction(user_status, tra_handle);
}


ISC_STATUS GDS_SEEK_BLOB(user_status, blob_handle, mode, offset, result)
	 ISC_STATUS *user_status;
	 BLB *blob_handle;
	 SLONG GDS_VAL(mode);
	 SLONG GDS_VAL(offset);
	 SLONG *result;
{
/**************************************
 *
 *	g d s _ $ s e e k _ b l o b
 *
 **************************************
 *
 * Functional description
 *	Seek a blob.
 *
 **************************************/

	return gds__seek_blob(user_status, blob_handle, (SSHORT) * mode, *offset,
						  result);
}


ISC_STATUS GDS_SEND(user_status, req_handle, msg_type, msg_length, msg, level)
	 ISC_STATUS *user_status;
	 REQ *req_handle;
	 SLONG GDS_VAL(msg_type), GDS_VAL(msg_length);
	 SCHAR *msg;
	 SLONG GDS_VAL(level);
{
/**************************************
 *
 *	g d s _ $ s e n d
 *
 **************************************
 *
 * Functional description
 *	Get a record from the host program.
 *
 **************************************/

	return gds__send(user_status, req_handle, (SSHORT) * msg_type,
					 (SSHORT) * msg_length, msg, (SSHORT) * level);
}


ISC_STATUS GDS_SQLCODE(user_status)
	 ISC_STATUS *user_status;
{
/**************************************
 *
 *	g d s _  s q l c o d e
 *
 **************************************
 *
 * Functional description
 *	Translate the GDS error code to SQL error code.
 *
 **************************************/
	return gds__sqlcode(user_status);
}


ISC_STATUS GDS_START(user_status, req_handle, tra_handle, level)
	 ISC_STATUS *user_status;
	 REQ *req_handle;
	 TRA *tra_handle;
	 SLONG GDS_VAL(level);
{
/**************************************
 *
 *	g d s _ $ s t a r t
 *
 **************************************
 *
 * Functional description
 *	Get a record from the host program.
 *
 **************************************/

	return gds__start_request(user_status, req_handle, tra_handle,
							  (SSHORT) * level);
}


ISC_STATUS GDS_START_AND_SEND(user_status, req_handle, tra_handle,
						  msg_type, msg_length, msg, level)
	 ISC_STATUS *user_status;
	 REQ *req_handle;
	 TRA *tra_handle;
	 SLONG GDS_VAL(msg_type), GDS_VAL(msg_length);
	 SCHAR *msg;
	 SLONG GDS_VAL(level);
{
/**************************************
 *
 *	g d s _ $ s t a r t _ a n d _ s e n d
 *
 **************************************
 *
 * Functional description
 *	Get a record from the host program.
 *
 **************************************/

	return gds__start_and_send(user_status, req_handle, tra_handle,
							   (SSHORT) * msg_type, (SSHORT) * msg_length,
							   msg, (SSHORT) * level);
}


ISC_STATUS GDS_START_MULTIPLE(user_status, tra_handle, count, vector)
	 ISC_STATUS *user_status;
	 TRA *tra_handle;
	 SLONG GDS_VAL(count);
	 TEB *vector;
{
/**************************************
 *
 *	g d s _ $ s t a r t _ m u l t i p l e
 *
 **************************************
 *
 * Functional description
 *	Start a transaction.
 *
 **************************************/

	return gds__start_multiple(user_status, tra_handle, (SSHORT) * count,
							   vector);
}


ISC_STATUS GDS_START_TRANSACTION(ISC_STATUS * user_status,
							 TRA * tra_handle, SLONG GDS_VAL(count), ...)
{
/**************************************
 *
 *	g d s _ $ s t a r t _ t r a n s a c t i o n
 *
 **************************************
 *
 * Functional description
 *	Start a transaction.
 *
 **************************************/
	TEB tebs[16], *teb, *end;
	va_list ptr;

	teb = tebs;
	end = teb + *count;
	VA_START(ptr, count);

	for (; teb < end; teb++) {
		teb->teb_database = va_arg(ptr, ATT *);
		teb->teb_tpb_length = *(va_arg(ptr, int *));
		teb->teb_tpb = va_arg(ptr, UCHAR *);
	}

	return gds__start_multiple(user_status, tra_handle,
							   (SSHORT) * count, tebs);
}


ISC_STATUS GDS_TRANSACTION_INFO(user_status, tra_handle,
							item_length, items, buffer_length, buffer)
	 ISC_STATUS *user_status;
	 TRA *tra_handle;
	 SLONG GDS_VAL(item_length), GDS_VAL(buffer_length);
	 SCHAR *items, *buffer;
{
/**************************************
 *
 *	g d s _ $ t r a n s a c t i o n _ i n f o
 *
 **************************************
 *
 * Functional description
 *	Provide information on blob object.
 *
 **************************************/

	return gds__transaction_info(user_status, tra_handle,
								 (SSHORT) * item_length, items,
								 (SSHORT) * buffer_length, buffer);
}


ISC_STATUS GDS_UNWIND_REQUEST(user_status, req_handle, level)
	 ISC_STATUS *user_status;
	 REQ *req_handle;
	 SLONG GDS_VAL(level);
{
/**************************************
 *
 *	g d s _ $ u n w i n d
 *
 **************************************
 *
 * Functional description
 *	Unwind a running request.  This is potentially nasty since it can be called
 *	asynchronously.
 *
 **************************************/

	gds__unwind_request(user_status, req_handle, (SSHORT) GDS_VAL(level));
	return;
}


SLONG GDS_VAX_INTEGER(ptr, length)
	 UCHAR *ptr;
	 SLONG length;
{
/**************************************
 *
 *	g d s _ $ v a x _ i n t e g e r
 *
 **************************************
 *
 * Functional description
 *	Pick up (and convert) a VAX style integer of length 1, 2, or 4
 *	bytes.
 *
 **************************************/

	return gds__vax_integer(ptr, (SSHORT) length);
}


GDS_VERSION(handle, routine, user_arg)
	 int *handle;
	 int (*routine) ();
	 SCHAR *user_arg;
{
/**************************************
 *
 *	g d s _ $ v e r s i o n
 *
 **************************************
 *
 * Functional description
 *	Obtain and print information about a database.
 *
 **************************************/

	gds__version(handle, routine, user_arg);
}


SLONG ISC_BADDRESS(object)
	 SCHAR *object;
{
/**************************************
 *
 *        i s c _ b a d d r e s s
 *
 **************************************
 *
 * Functional description
 *      Return the address of whatever is passed in
 *
 **************************************/

	return (SLONG) object;
}


ISC_STATUS ISC_ARRAY_GEN_SDL(status, desc, sdl_buffer_length, sdl_buffer,
						 sdl_length)
	 ISC_STATUS *status;
	 ARRAY_DESC *desc;
	 SSHORT *sdl_buffer_length;
	 SCHAR *sdl_buffer;
	 SSHORT *sdl_length;
{
/**************************************
 *
 *	i s c _ a r r a y _ g e n _ s d l
 *
 **************************************
 *
 * Functional description
 *
 **************************************/

	return isc_array_gen_sdl(status, desc, sdl_buffer_length, sdl_buffer,
							 sdl_length);
}


ISC_STATUS ISC_ARRAY_GET_SLICE(status, db_handle, trans_handle, array_id,
						   desc, array, slice_length)
	 ISC_STATUS *status;
	 SLONG *db_handle;
	 SLONG *trans_handle;
	 GDS__QUAD *array_id;
	 ARRAY_DESC *desc;
	 void *array;
	 SLONG *slice_length;
{
/**************************************
 *
 *	i s c _ a r r a y _ g e t _ s l i c e
 *
 **************************************
 *
 * Functional description
 *
 **************************************/

	return isc_array_get_slice(status, db_handle, trans_handle, array_id,
							   desc, array, slice_length);
}


ISC_STATUS ISC_ARRAY_LOOKUP_BOUNDS(status, db_handle, trans_handle,
							   relation_name, field_name, desc)
	 ISC_STATUS *status;
	 SLONG *db_handle;
	 SLONG *trans_handle;
	 SCHAR *relation_name;
	 SCHAR *field_name;
	 ARRAY_DESC *desc;
{
/**************************************
 *
 *	i s c _ a r r a y _ l o o k u p _ b o u n d s
 *
 **************************************
 *
 * Functional description
 *
 **************************************/

	return isc_array_lookup_bounds(status, db_handle, trans_handle,
								   relation_name, field_name, desc);
}


ISC_STATUS ISC_ARRAY_LOOKUP_DESC(status, db_handle, trans_handle,
							 relation_name, field_name, desc)
	 ISC_STATUS *status;
	 SLONG *db_handle;
	 SLONG *trans_handle;
	 SCHAR *relation_name;
	 SCHAR *field_name;
	 ARRAY_DESC *desc;
{
/**************************************
 *
 *	i s c _ a r r a y _ l o o k u p _ d e s c
 *
 **************************************
 *
 * Functional description
 *
 **************************************/

	return isc_array_lookup_desc(status, db_handle, trans_handle,
								 relation_name, field_name, desc);
}


ISC_STATUS ISC_ARRAY_PUT_SLICE(status, db_handle, trans_handle, array_id,
						   desc, array, slice_length)
	 ISC_STATUS *status;
	 SLONG *db_handle;
	 SLONG *trans_handle;
	 GDS__QUAD *array_id;
	 ARRAY_DESC *desc;
	 void *array;
	 SLONG *slice_length;
{
/**************************************
 *
 *	i s c _ a r r a y _ p u t _ s l i c e
 *
 **************************************
 *
 * Functional description
 *
 **************************************/

	return isc_array_put_slice(status, db_handle, trans_handle, array_id,
							   desc, array, slice_length);
}


ISC_STATUS ISC_ARRAY_SET_DESC(status, relation_name, field_name, sql_dtype,
						  sql_length, dimensions, desc)
	 ISC_STATUS *status;
	 SCHAR *relation_name;
	 SCHAR *field_name;
	 SSHORT *sql_dtype;
	 SSHORT *sql_length;
	 SSHORT *dimensions;
	 ARRAY_DESC *desc;
{
/**************************************
 *
 *	i s c _ a r r a y _ s e t _ d e s c
 *
 **************************************
 *
 * Functional description
 *
 **************************************/

	return isc_array_set_desc(status, relation_name, field_name, sql_dtype,
							  sql_length, dimensions, desc);
}


ISC_STATUS ISC_ATTACH_DATABASE(user_status, file_length, file_name, handle,
						   dpb_length, dpb)
	 ISC_STATUS *user_status;
	 SLONG GDS_VAL(file_length);
	 SCHAR *file_name;
	 ATT *handle;
	 SSHORT GDS_VAL(dpb_length);
	 SCHAR **dpb;
{
/**************************************
 *
 *	i s c _ a t t a c h _ d a t a b a s e
 *
 **************************************
 *
 * Functional description
 *	Attach a database through the first subsystem
 *	that recognizes it.
 *
 **************************************/
	return isc_attach_database(user_status,
							   (SSHORT) * file_length, file_name, handle,
							   *dpb_length, *dpb);
}


ISC_MODIFY_DPB(dpb, dpb_length, type, str, str_len)
	 SCHAR **dpb;
	 SSHORT GDS_VAL(dpb_length);
	 SSHORT GDS_VAL(type);
	 SCHAR *str;
	 SLONG GDS_VAL(str_len);
{
/**************************************
 *
 *	i s c _ m o d i f y  _ d p b
 *
 **************************************
 *
 * Functional description
 *	expand data base parameter block with 
 *	user, password and character set info
 *
 **************************************/
	return isc_modify_dpb(dpb, dpb_length, *type, str, (SSHORT) * str_len);
}


SLONG ISC_FREE(blk)
	 SLONG **blk;
{
/**************************************
 *
 *	g d s _ $ f r e e
 *
 **************************************
 *
 * Functional description
 *	Release a block allocated by gds__alloc.  Return number
 *	of bytes released.
 *
 **************************************/

	return gds__free(*blk);
}


ISC_STATUS ISC_BLOB_INFO(user_status, blob_handle, item_length, items,
					 buffer_length, buffer)
	 ISC_STATUS *user_status;
	 BLB *blob_handle;
	 SLONG GDS_VAL(item_length), GDS_VAL(buffer_length);
	 SCHAR *items, *buffer;
{
/**************************************
 *
 *	i s c _ b l o b _ i n f o
 *
 **************************************
 *
 * Functional description
 *	Provide information on blob object.
 *
 **************************************/

	return isc_blob_info(user_status, blob_handle, (SSHORT) * item_length,
						 items, (SSHORT) * buffer_length, buffer);
}


ISC_STATUS ISC_CANCEL_BLOB(user_status, blob_handle)
	 ISC_STATUS *user_status;
	 BLB *blob_handle;
{
/**************************************
 *
 *	i s c _ c a n c e l _ b l o b
 *
 **************************************
 *
 * Functional description
 *	Abort a partially completed blob.
 *
 **************************************/

	return isc_cancel_blob(user_status, blob_handle);
}


ISC_STATUS ISC_CANCEL_EVENTS(user_status, handle, id)
	 ISC_STATUS *user_status;
	 ATT *handle;
	 SLONG *id;
{
/**************************************
 *
 *	i s c _ c a n c e l _ e v e n t s
 *
 **************************************
 *
 * Functional description
 *	Try to cancel an event.
 *
 **************************************/

	return isc_cancel_events(user_status, handle, id);
}


ISC_STATUS ISC_CLOSE(user_status, name)
	 ISC_STATUS *user_status;
	 TEXT *name;
{
/**************************************
 *
 *	i s c _ c l o s e
 *
 **************************************
 *
 * Functional description
 *	Close a dynamic SQL cursor.
 *
 **************************************/

	return isc_close(user_status, name);
}


ISC_STATUS ISC_CLOSE_BLOB(user_status, blob_handle)
	 ISC_STATUS *user_status;
	 BLB *blob_handle;
{
/**************************************
 *
 *	i s c _ c l o s e _ b l o b
 *
 **************************************
 *
 * Functional description
 *	Abort a partially completed blob.
 *
 **************************************/

	return isc_close_blob(user_status, blob_handle);
}


ISC_STATUS ISC_COMMIT(user_status, tra_handle)
	 ISC_STATUS *user_status;
	 TRA *tra_handle;
{
/**************************************
 *
 *	i s c _ c o m m i t
 *
 **************************************
 *
 * Functional description
 *	Commit a transaction.
 *
 **************************************/

	return isc_commit_transaction(user_status, tra_handle);
}


ISC_STATUS ISC_COMMIT_RETAINING(user_status, tra_handle)
	 ISC_STATUS *user_status;
	 TRA *tra_handle;
{
/**************************************
 *
 *	i s c _ c o m m i t _ r e t a i n i n g
 *
 **************************************
 *
 * Functional description
 *	Do a commit retaining.
 *
 **************************************/

	return isc_commit_retaining(user_status, tra_handle);
}


ISC_STATUS ISC_COMPILE(user_status, db_handle, req_handle, blr_length, blr)
	 ISC_STATUS *user_status;
	 ATT *db_handle;
	 REQ *req_handle;
	 SLONG GDS_VAL(blr_length);
	 SCHAR *blr;
{
/**************************************
 *
 *	i s c _ c o m p i l e
 *
 **************************************
 *
 * Functional description
 *
 **************************************/

	return isc_compile_request(user_status, db_handle, req_handle,
							   (SSHORT) * blr_length, blr);
}


ISC_STATUS ISC_COMPILE2(user_status, db_handle, req_handle, blr_length, blr)
	 ISC_STATUS *user_status;
	 ATT *db_handle;
	 REQ *req_handle;
	 SLONG GDS_VAL(blr_length);
	 SCHAR *blr;
{
/**************************************
 *
 *	i s c _ c o m p i l e 2
 *
 **************************************
 *
 * Functional description
 *
 **************************************/

	return isc_compile_request2(user_status, db_handle, req_handle,
								(SSHORT) * blr_length, blr);
}


ISC_STATUS ISC_CREATE_BLOB(user_status, db_handle, tra_handle, blob_handle,
					   blob_id)
	 ISC_STATUS *user_status;
	 ATT *db_handle;
	 TRA *tra_handle;
	 BLB *blob_handle;
	 SLONG *blob_id;
{
/**************************************
 *
 *	i s c _ c r e a t e _ b l o b
 *
 **************************************
 *
 * Functional description
 *	Open an existing blob.
 *
 **************************************/

	return isc_create_blob(user_status, db_handle, tra_handle, blob_handle,
						   blob_id);
}


ISC_STATUS ISC_CREATE_BLOB2(user_status, db_handle, tra_handle, blob_handle,
						blob_id, bpb_length, bpb)
	 ISC_STATUS *user_status;
	 ATT *db_handle;
	 TRA *tra_handle;
	 BLB *blob_handle;
	 SLONG *blob_id;
	 SLONG GDS_VAL(bpb_length);
	 UCHAR *bpb;
{
/**************************************
 *
 *	i s c _ c r e a t e _ b l o b 2
 *
 **************************************
 *
 * Functional description
 *	Open an existing blob.
 *
 **************************************/

	return isc_create_blob2(user_status, db_handle, tra_handle, blob_handle,
							blob_id, (SSHORT) * bpb_length, bpb);
}


ISC_STATUS ISC_CREATE_DATABASE(user_status, file_length, file_name, handle,
						   dpb_length, dpb, db_type)
	 ISC_STATUS *user_status;
	 SLONG GDS_VAL(file_length);
	 UCHAR *file_name;
	 ATT *handle;
	 SSHORT GDS_VAL(dpb_length);
	 UCHAR *dpb;
	 SLONG GDS_VAL(db_type);
{
/**************************************
 *
 *	i s c _ c r e a t e _ d a t a b a s e
 *
 **************************************
 *
 * Functional description
 *	Create a nice, squeaky clean database, uncorrupted by user data.
 *
 **************************************/

	return isc_create_database(user_status, (SSHORT) * file_length, file_name,
							   handle, (SSHORT) * dpb_length, dpb,
							   (SSHORT) * db_type);
}


ISC_STATUS ISC_DATABASE_INFO(user_status, handle, item_length, items,
						 buffer_length, buffer)
	 ISC_STATUS *user_status;
	 ATT *handle;
	 SLONG GDS_VAL(item_length), GDS_VAL(buffer_length);
	 SCHAR *items, *buffer;
{
/**************************************
 *
 *	i s c _ d a t a b a s e _ i n f o
 *
 **************************************
 *
 * Functional description
 *	Provide information on database object.
 *
 **************************************/

	return isc_database_info(user_status, handle, (SSHORT) * item_length,
							 items, (SSHORT) * buffer_length, buffer);
}


ISC_STATUS ISC_DDL(user_status, db_handle, tra_handle, length, ddl)
	 ISC_STATUS *user_status;
	 ATT *db_handle;
	 TRA *tra_handle;
	 SLONG GDS_VAL(length);
	 UCHAR *ddl;
{
/**************************************
 *
 *	i s c _ d d l
 *
 **************************************
 *
 * Functional description
 *	Do meta-data update.
 *
 **************************************/

	return isc_ddl(user_status, db_handle, tra_handle, (SSHORT) * length,
				   ddl);
}


ISC_DECLARE(user_status, statement, cursor)
	 ISC_STATUS *user_status;
	 TEXT *statement, *cursor;
{
/**************************************
 *
 *	i s c _ d e c l a r e
 *
 **************************************
 *
 * Functional description
 *	Declare a cursor for a dynamic request.
 *
 **************************************/

	return isc_declare(user_status, statement, cursor);
}


void ISC_DECODE_DATE(date, times)
	 SLONG date[2];
	 struct tm *times;
{
/**************************************
 *
 *	i s c _ d e c o d e
 *
 **************************************
 *
 * Functional description
 *	Convert from internal date format to UNIX time structure.
 *
 **************************************/

	isc_decode_date(date, times);
}


ISC_DESCRIBE(user_status, name, sqlda)
	 ISC_STATUS *user_status;
	 TEXT *name;
	 XSQLDA *sqlda;
{
/**************************************
 *
 *	i s c _ d e s c r i b e
 *
 **************************************
 *
 * Functional description
 *	Describe output parameters for a prepared statement.
 *
 **************************************/

	return isc_describe(user_status, name, sqlda);
}


ISC_DESCRIBE_BIND(user_status, name, sqlda)
	 ISC_STATUS *user_status;
	 TEXT *name;
	 XSQLDA *sqlda;
{
/**************************************
 *
 *	i s c _ d e s c r i b e _ b i n d
 *
 **************************************
 *
 * Functional description
 *	Describe input parameters for a prepared statement.
 *
 **************************************/

	return isc_describe_bind(user_status, name, sqlda);
}


ISC_STATUS ISC_DETACH(user_status, handle)
	 ISC_STATUS *user_status;
	 ATT *handle;
{
/**************************************
 *
 *	i s c _ d e t a c h
 *
 **************************************
 *
 * Functional description
 *	Close down a database.
 *
 **************************************/

	return isc_detach_database(user_status, handle);
}


ISC_STATUS ISC_DROP_DATABASE(user_status, handle)
	 ISC_STATUS *user_status;
	 ATT *handle;
{
/**************************************
 *
 *	i s c _ d r o p _ d a t a b a s e
 *
 **************************************
 *
 * Functional description
 *	Close down a database.
 *
 **************************************/

	return isc_drop_database(user_status, handle);
}


ISC_DSQL_ALLOCATE(user_status, db_handle, stmt_handle)
	 ISC_STATUS *user_status;
	 ATT *db_handle;
	 STMT *stmt_handle;
{
/**************************************
 *
 *	i s c _ d s q l _ a l l o c a t e _ s t a t e m e n t
 *
 **************************************
 *
 * Functional description
 *	Allocate a statement handle.
 *
 **************************************/

	return isc_dsql_allocate_statement(user_status, db_handle, stmt_handle);
}


ISC_DSQL_ALLOCATE2(user_status, db_handle, stmt_handle)
	 ISC_STATUS *user_status;
	 ATT *db_handle;
	 STMT *stmt_handle;
{
/**************************************
 *
 *	i s c _ d s q l _ a l l o c _ s t a t e m e n t 2
 *
 **************************************
 *
 * Functional description
 *	Allocate a statement handle.
 *
 **************************************/

	return isc_dsql_alloc_statement2(user_status, db_handle, stmt_handle);
}


ISC_DSQL_DESCRIBE(user_status, stmt_handle, dialect, sqlda)
	 ISC_STATUS *user_status;
	 STMT *stmt_handle;
	 SLONG GDS_VAL(dialect);
	 XSQLDA *sqlda;
{
/**************************************
 *
 *	i s c _ d s q l _ d e s c r i b e
 *
 **************************************
 *
 * Functional description
 *	Describe output parameters for a prepared statement.
 *
 **************************************/

	return isc_dsql_describe(user_status, stmt_handle, (USHORT) * dialect,
							 sqlda);
}


ISC_DSQL_DESCRIBE_BIND(user_status, stmt_handle, dialect, sqlda)
	 ISC_STATUS *user_status;
	 STMT *stmt_handle;
	 SLONG GDS_VAL(dialect);
	 XSQLDA *sqlda;
{
/**************************************
 *
 *	i s c _ d s q l _ d e s c r i b e _ b i n d
 *
 **************************************
 *
 * Functional description
 *	Describe input parameters for a prepared statement.
 *
 **************************************/

	return isc_dsql_describe_bind(user_status, stmt_handle,
								  (USHORT) * dialect, sqlda);
}


ISC_DSQL_EXECUTE(user_status, tra_handle, stmt_handle, dialect, sqlda)
	 ISC_STATUS *user_status;
	 TRA *tra_handle;
	 STMT *stmt_handle;
	 SLONG GDS_VAL(dialect);
	 XSQLDA *sqlda;
{
/**************************************
 *
 *	i s c _ d s q l _ e x e c u t e
 *
 **************************************
 *
 * Functional description
 *	Execute a non-SELECT dynamic SQL statement.
 *
 **************************************/

	return isc_dsql_execute(user_status, tra_handle, stmt_handle,
							(USHORT) * dialect, sqlda);
}


ISC_DSQL_EXECUTE2(user_status, tra_handle, stmt_handle, dialect,
				  in_sqlda, out_sqlda, sqlda)
	 ISC_STATUS *user_status;
	 TRA *tra_handle;
	 STMT *stmt_handle;
	 SLONG GDS_VAL(dialect);
	 XSQLDA *in_sqlda, *out_sqlda;
{
/**************************************
 *
 *      i s c _ d s q l _ e x e c u t e 2
 *
 **************************************
 *
 * Functional description
 *      Execute a non-SELECT dynamic SQL statement.
 *
 **************************************/

	return isc_dsql_execute2(user_status, tra_handle, stmt_handle,
							 (USHORT) * dialect, in_sqlda, out_sqlda);
}


ISC_DSQL_EXECUTE_M(user_status,
				   tra_handle, stmt_handle, blr_length, blr, msg_type,
				   msg_length, msg)
	 ISC_STATUS *user_status;
	 TRA *tra_handle;
	 STMT *stmt_handle;
	 SLONG GDS_VAL(blr_length), GDS_VAL(msg_type), GDS_VAL(msg_length);
	 SCHAR *blr, *msg;
{
/**************************************
 *
 *	i s c _ d s q l _ e x e c u t e _ m
 *
 **************************************
 *
 * Functional description
 *	Execute a non-SELECT dynamic SQL statement.
 *
 **************************************/

	return isc_dsql_execute_m(user_status, tra_handle, stmt_handle,
							  (USHORT) * blr_length, blr, (USHORT) * msg_type,
							  (USHORT) * msg_length, msg);
}


ISC_DSQL_EXECUTE2_M(user_status, tra_handle, stmt_handle,
					in_blr_length, in_blr, in_msg_type, in_msg_length, in_msg,
					out_blr_length, out_blr, out_msg_type, out_msg_length,
					out_msg)
	 ISC_STATUS *user_status;
	 TRA *tra_handle;
	 STMT *stmt_handle;
	 SLONG GDS_VAL(in_blr_length), GDS_VAL(in_msg_type);
	 SLONG GDS_VAL(in_msg_length), GDS_VAL(out_blr_length);
	 SLONG GDS_VAL(out_msg_type), GDS_VAL(out_msg_length);
	 SCHAR *in_blr, *in_msg, *out_blr, *out_msg;
{
/**************************************
 *
 *      i s c _ d s q l _ e x e c u t e 2 _ m
 *
 **************************************
 *
 * Functional description
 *      Execute a non-SELECT dynamic SQL statement.
 *
 **************************************/

	return isc_dsql_execute2_m(user_status, tra_handle, stmt_handle,
							   (USHORT) * in_blr_length, in_blr,
							   (USHORT) * in_msg_type,
							   (USHORT) * in_msg_length, in_msg,
							   (USHORT) * out_blr_length, out_blr,
							   (USHORT) * out_msg_type,
							   (USHORT) * out_msg_length, out_msg);
}


ISC_DSQL_EXECUTE_IMMED(user_status,
					   db_handle, tra_handle, length, string, dialect, sqlda)
	 ISC_STATUS *user_status;
	 ATT *db_handle;
	 TRA *tra_handle;
	 SLONG GDS_VAL(length);
	 SCHAR *string;
	 SLONG GDS_VAL(dialect);
	 XSQLDA *sqlda;
{
/**************************************
 *
 *	i s c _ d s q l _ e x e c u t e _ i m m e d i a t e
 *
 **************************************
 *
 * Functional description
 *	Prepare a statement for execution.
 *
 **************************************/

	return isc_dsql_execute_immediate(user_status, db_handle, tra_handle,
									  (USHORT) * length, string,
									  (USHORT) * dialect, sqlda);
}


ISC_DSQL_EXEC_IMMED2(user_status,
					 db_handle, tra_handle, length, string, dialect, in_sqlda,
					 out_sqlda)
	 ISC_STATUS *user_status;
	 ATT *db_handle;
	 TRA *tra_handle;
	 SLONG GDS_VAL(length);
	 SCHAR *string;
	 SLONG GDS_VAL(dialect);
	 XSQLDA *in_sqlda, *out_sqlda;
{
/**************************************
 *
 *      i s c _ d s q l _ e x e c _ i m m e d 2
 *
 **************************************
 *
 * Functional description
 *      Prepare a statement for execution.
 *
 **************************************/

	return isc_dsql_exec_immed2(user_status, db_handle, tra_handle,
								(USHORT) * length, string, (USHORT) * dialect,
								in_sqlda, out_sqlda);
}


ISC_DSQL_EXECUTE_IMM_M(user_status, db_handle, tra_handle,
					   length, string, dialect, blr_length, blr, msg_type,
					   msg_length, msg)
	 ISC_STATUS *user_status;
	 ATT *db_handle;
	 TRA *tra_handle;
	 SLONG GDS_VAL(length);
	 SCHAR *string;
	 SLONG GDS_VAL(dialect);
	 SLONG GDS_VAL(blr_length), GDS_VAL(msg_type), GDS_VAL(msg_length);
	 SCHAR *blr, *msg;
{
/**************************************
 *
 *	i s c _ d s q l _ e x e c u t e _ i m m e d i a t e _ m
 *
 **************************************
 *
 * Functional description
 *	Prepare a statement for execution.
 *
 **************************************/

	return isc_dsql_execute_immediate_m(user_status, db_handle, tra_handle,
										(USHORT) * length, string,
										(USHORT) * dialect,
										(USHORT) * blr_length, blr,
										(USHORT) * msg_type,
										(USHORT) * msg_length, msg);
}


ISC_DSQL_EXEC_IMMED2_M(user_status, db_handle, tra_handle,
					   length, string, dialect,
					   in_blr_length, in_blr, in_msg_type, in_msg_length,
					   in_msg, out_blr_length, out_blr, out_msg_type,
					   out_msg_length, out_msg)
	 ISC_STATUS *user_status;
	 ATT *db_handle;
	 TRA *tra_handle;
	 SLONG GDS_VAL(length);
	 SCHAR *string;
	 SLONG GDS_VAL(dialect);
	 SLONG GDS_VAL(in_blr_length), GDS_VAL(in_msg_type);
	 SLONG GDS_VAL(in_msg_length), GDS_VAL(out_blr_length);
	 SLONG GDS_VAL(out_msg_type), GDS_VAL(out_msg_length);
	 SCHAR *in_blr, *in_msg, *out_blr, *out_msg;
{
/**************************************
 *
 *      i s c _ d s q l _ e x e c _ i m m e d 2 _ m
 *
 **************************************
 *
 * Functional description
 *      Prepare a statement for execution.
 *
 **************************************/

	return isc_dsql_exec_immed2_m(user_status, db_handle, tra_handle,
								  (USHORT) * length, string,
								  (USHORT) * dialect,
								  (USHORT) * in_blr_length, in_blr,
								  (USHORT) * in_msg_type,
								  (USHORT) * in_msg_length, in_msg,
								  (USHORT) * out_blr_length, out_blr,
								  (USHORT) * out_msg_type,
								  (USHORT) * out_msg_length, out_msg);
}


ISC_DSQL_FETCH(user_status, stmt_handle, dialect, sqlda)
	 ISC_STATUS *user_status;
	 STMT *stmt_handle;
	 SLONG GDS_VAL(dialect);
	 XSQLDA *sqlda;
{
/**************************************
 *
 *	i s c _ d s q l _ f e t c h
 *
 **************************************
 *
 * Functional description
 *	Fetch next record from a dynamic SQL cursor
 *
 **************************************/

	return isc_dsql_fetch(user_status, stmt_handle, (USHORT) * dialect,
						  sqlda);
}


#ifdef SCROLLABLE_CURSORS
ISC_DSQL_FETCH2(user_status, stmt_handle, dialect, sqlda, direction, offset)
	 ISC_STATUS *user_status;
	 STMT *stmt_handle;
	 SLONG GDS_VAL(dialect);
	 XSQLDA *sqlda;
	 USHORT direction;
	 SLONG offset;
{
/**************************************
 *
 *	i s c _ d s q l _ f e t c h 2
 *
 **************************************
 *
 * Functional description
 *	Fetch next record from a dynamic SQL cursor
 *
 **************************************/

	return isc_dsql_fetch2(user_status, stmt_handle, (USHORT) * dialect,
						   sqlda, direction, offset);
}
#endif


ISC_DSQL_FETCH_M(user_status,
				 stmt_handle, blr_length, blr, msg_type, msg_length, msg)
	 ISC_STATUS *user_status;
	 STMT *stmt_handle;
	 SLONG GDS_VAL(blr_length), GDS_VAL(msg_type), GDS_VAL(msg_length);
	 SCHAR *blr, *msg;
{
/**************************************
 *
 *	i s c _ d s q l _ f e t c h _ m
 *
 **************************************
 *
 * Functional description
 *	Fetch next record from a dynamic SQL cursor
 *
 **************************************/

	return isc_dsql_fetch_m(user_status, stmt_handle, (USHORT) * blr_length,
							blr, (USHORT) * msg_type, (USHORT) * msg_length,
							msg);
}


#ifdef SCROLLABLE_CURSORS
ISC_DSQL_FETCH2_M(user_status,
				  stmt_handle, blr_length, blr, msg_type, msg_length, msg,
				  direction, offset)
	 ISC_STATUS *user_status;
	 STMT *stmt_handle;
	 SLONG GDS_VAL(blr_length), GDS_VAL(msg_type), GDS_VAL(msg_length);
	 SCHAR *blr, *msg;
	 USHORT direction;
	 SLONG offset;
{
/**************************************
 *
 *	i s c _ d s q l _ f e t c h 2 _ m
 *
 **************************************
 *
 * Functional description
 *	Fetch next record from a dynamic SQL cursor
 *
 **************************************/

	return isc_dsql_fetch2_m(user_status, stmt_handle, (USHORT) * blr_length,
							 blr, (USHORT) * msg_type, (USHORT) * msg_length,
							 msg, direction, offset);
}
#endif


ISC_DSQL_FINISH(db_handle)
	 SLONG **db_handle;
{
/**************************************
 *
 *	i s c _ d s q l _ f i n i s h
 *
 **************************************
 *
 * Functional description
 *	Clean up DSQL globals
 *
 **************************************/

	return isc_dsql_finish(db_handle);
}


ISC_DSQL_FREE(user_status, stmt_handle, option)
	 ISC_STATUS *user_status;
	 STMT *stmt_handle;
	 SLONG GDS_VAL(option);
{
/*****************************************
 *
 *	i s c _ d s q l _ f r e e _ s t a t e m e n t
 *
 *****************************************
 *
 * Functional Description
 *	release request for an sql statement
 *
 *****************************************/

	return isc_dsql_free_statement(user_status, stmt_handle,
								   (USHORT) * option);
}


ISC_DSQL_INSERT(user_status, stmt_handle, dialect, sqlda)
	 ISC_STATUS *user_status;
	 STMT *stmt_handle;
	 SLONG GDS_VAL(dialect);
	 XSQLDA *sqlda;
{
/**************************************
 *
 *      i s c _ d s q l _ i n s e r t
 *
 **************************************
 *
 * Functional description
 *      Insert next record into a dynamic SQL cursor
 *
 **************************************/

	return isc_dsql_insert(user_status, stmt_handle, (USHORT) * dialect,
						   sqlda);
}


ISC_DSQL_INSERT_M(user_status,
				  stmt_handle, blr_length, blr, msg_type, msg_length, msg)
	 ISC_STATUS *user_status;
	 STMT *stmt_handle;
	 SLONG GDS_VAL(blr_length), GDS_VAL(msg_type), GDS_VAL(msg_length);
	 SCHAR *blr, *msg;
{
/**************************************
 *
 *      i s c _ d s q l _ i n s e r t _ m
 *
 **************************************
 *
 * Functional description
 *      Insert next record into a dynamic SQL cursor
 *
 **************************************/

	return isc_dsql_insert_m(user_status, stmt_handle, (USHORT) * blr_length,
							 (USHORT) * msg_type, (USHORT) * msg_length, blr,
							 msg);
}


ISC_DSQL_PREPARE(user_status,
				 tra_handle, stmt_handle, length, string, dialect, sqlda)
	 ISC_STATUS *user_status;
	 TRA *tra_handle;
	 STMT *stmt_handle;
	 SLONG GDS_VAL(length);
	 SCHAR *string;
	 SLONG GDS_VAL(dialect);
	 XSQLDA *sqlda;
{
/**************************************
 *
 *	i s c _ d s q l _ p r e p a r e
 *
 **************************************
 *
 * Functional description
 *	Prepare a statement for execution.
 *
 **************************************/

	return isc_dsql_prepare(user_status, tra_handle, stmt_handle,
							(USHORT) * length, string, (USHORT) * dialect,
							sqlda);
}


ISC_DSQL_PREPARE_M(user_status, tra_handle, stmt_handle,
				   length, string, dialect, item_length, items, buffer_length,
				   buffer)
	 ISC_STATUS *user_status;
	 TRA *tra_handle;
	 STMT *stmt_handle;
	 SLONG GDS_VAL(length);
	 SCHAR *string;
	 SLONG GDS_VAL(dialect);
	 SLONG GDS_VAL(item_length), GDS_VAL(buffer_length);
	 SCHAR *items, *buffer;
{
/**************************************
 *
 *	i s c _ d s q l _ p r e p a r e _ m
 *
 **************************************
 *
 * Functional description
 *	Prepare a statement for execution.
 *
 **************************************/

	return isc_dsql_prepare_m(user_status, tra_handle, stmt_handle,
							  (USHORT) * length, string, (USHORT) * dialect,
							  (USHORT) * item_length, items,
							  (USHORT) * buffer_length, buffer);
}


ISC_DSQL_RELEASE(user_status, name)
	 ISC_STATUS *user_status;
	 TEXT *name;
{
/**************************************
 *
 *	i s c _ d s q l _ r e l e a s e
 *
 **************************************
 *
 * Functional description
 *	Release request for a dsql statement
 *
 **************************************/

	return isc_dsql_release(user_status, name);
}


ISC_DSQL_SET_CURSOR(user_status, stmt_handle, cursor, type)
	 ISC_STATUS *user_status;
	 STMT *stmt_handle;
	 SCHAR *cursor;
	 SLONG GDS_VAL(type);
{
/**************************************
 *
 *	i s c _ d s q l _ s e t _ c u r s o r
 *
 **************************************
 *
 * Functional description
 *	Set a cursor name for a dynamic request.
 *
 **************************************/

	return isc_dsql_set_cursor_name(user_status, stmt_handle, cursor,
									(USHORT) * type);
}


ISC_DSQL_SQL_INFO(user_status, stmt_handle, item_length, items,
				  buffer_length, buffer)
	 ISC_STATUS *user_status;
	 STMT *stmt_handle;
	 SLONG GDS_VAL(item_length), GDS_VAL(buffer_length);
	 SCHAR *items, *buffer;
{
/**************************************
 *
 *	i s c _ d s q l _ s q l _ i n f o
 *
 **************************************
 *
 * Functional description
 *	Provide information on sql statement.
 *
 **************************************/

	return isc_dsql_sql_info(user_status, stmt_handle, (USHORT) * item_length,
							 items, (USHORT) * buffer_length, buffer);
}


ISC_EMBED_DSQL_CLOSE(user_status, name)
	 ISC_STATUS *user_status;
	 SCHAR *name;
{
/**************************************
 *
 *	i s c _ e m b e d _ d s q l _ c l o s e
 *
 **************************************
 *
 * Functional description
 *	Close a dynamic SQL cursor.
 *
 **************************************/

	return isc_embed_dsql_close(user_status, name);
}


ISC_EMBED_DSQL_DECLARE(user_status, stmt_name, cursor)
	 ISC_STATUS *user_status;
	 SCHAR *stmt_name;
	 SCHAR *cursor;
{
/**************************************
 *
 *	i s c _ e m b e d _ d s q l _ d e c l a r e
 *
 **************************************
 *
 * Functional description
 *	Declare a cursor for a dynamic request.
 *
 **************************************/

	return isc_embed_dsql_declare(user_status, stmt_name, cursor);
}


ISC_EMBED_DSQL_DESCR(user_status, stmt_name, dialect, sqlda)
	 ISC_STATUS *user_status;
	 SCHAR *stmt_name;
	 SLONG GDS_VAL(dialect);
	 XSQLDA *sqlda;
{
/**************************************
 *
 *	i s c _ e m b e d _ d s q l _ d e s c r i b e
 *
 **************************************
 *
 * Functional description
 *	Describe output parameters for a prepared statement.
 *
 **************************************/

	return isc_embed_dsql_describe(user_status, stmt_name, (USHORT) * dialect,
								   sqlda);
}


ISC_EMBED_DSQL_DESCR_B(user_status, stmt_name, dialect, sqlda)
	 ISC_STATUS *user_status;
	 SCHAR *stmt_name;
	 SLONG GDS_VAL(dialect);
	 XSQLDA *sqlda;
{
/**************************************
 *
 *	i s c _ e m b e d _ d s q l _ d e s c r i b e _ b i n d
 *
 **************************************
 *
 * Functional description
 *	Describe input parameters for a prepared statement.
 *
 **************************************/

	return isc_embed_dsql_describe_bind(user_status, stmt_name,
										(USHORT) * dialect, sqlda);
}


ISC_EMBED_DSQL_EXECUTE(user_status, trans_handle, stmt_name, dialect,
					   SQLDA_PROTOTYPE)
	 ISC_STATUS *user_status;
	 SLONG **trans_handle;
	 SCHAR *stmt_name;
	 SLONG GDS_VAL(dialect);
	 XSQLDA *sqlda;
{
/**************************************
 *
 *	i s c _ e m b e d _ d s q l _ e x e c u t e
 *
 **************************************
 *
 * Functional description
 *	Execute a non-SELECT dynamic SQL statement.
 *
 **************************************/

	return isc_embed_dsql_execute(user_status, trans_handle, stmt_name,
								  (USHORT) * dialect, SQLDA_ARG);
}


ISC_EMBED_DSQL_EXECUTE2(user_status, trans_handle, stmt_name, dialect,
						in_sqlda, out_sqlda)
	 ISC_STATUS *user_status;
	 SLONG **trans_handle;
	 SCHAR *stmt_name;
	 SLONG GDS_VAL(dialect);
	 XSQLDA *in_sqlda, *out_sqlda;
{
/**************************************
 *
 *      i s c _ e m b e d _ d s q l _ e x e c u t e 2
 *
 **************************************
 *
 * Functional description
 *      Execute a non-SELECT dynamic SQL statement.
 *
 **************************************/

	return isc_embed_dsql_execute2(user_status, trans_handle, stmt_name,
								   (USHORT) * dialect, in_sqlda, out_sqlda);
}


ISC_EMBED_DSQL_EXEC_IMM(user_status, db_handle, trans_handle, length, string,
						dialect, SQLDA_PROTOTYPE)
	 ISC_STATUS *user_status;
	 SLONG **db_handle;
	 SLONG **trans_handle;
	 SLONG GDS_VAL(length);
	 SCHAR *string;
	 SLONG GDS_VAL(dialect);
	 XSQLDA *sqlda;
{
/**************************************
 *
 *	i s c _ e m b e d _ d s q l _ e x e c u t e _ i m m e d
 *
 **************************************
 *
 * Functional description
 *	Prepare a statement for execution.
 *
 **************************************/

	return isc_embed_dsql_execute_immed(user_status, db_handle, trans_handle,
										(USHORT) * length, string,
										(USHORT) * dialect, SQLDA_ARG);
}


ISC_EMBED_DSQL_EXEC_IM2(user_status, db_handle, trans_handle, length,
						string, dialect, in_sqlda, out_sqlda)
	 ISC_STATUS *user_status;
	 SLONG **db_handle;
	 SLONG **trans_handle;
	 SLONG GDS_VAL(length);
	 SCHAR *string;
	 SLONG GDS_VAL(dialect);
	 XSQLDA *in_sqlda, *out_sqlda;
{
/**************************************
 *
 *      i s c _ e m b e d _ d s q l _ e x e c _ i m m e d 2
 *
 **************************************
 *
 * Functional description
 *      Prepare a statement for execution.
 *
 **************************************/

	return isc_embed_dsql_exec_immed2(user_status, db_handle, trans_handle,
									  (USHORT) * length, string,
									  (USHORT) * dialect, in_sqlda,
									  out_sqlda);
}


ISC_EMBED_DSQL_FETCH(user_status, cursor_name, dialect, SQLDA_PROTOTYPE)
	 ISC_STATUS *user_status;
	 SCHAR *cursor_name;
	 SLONG GDS_VAL(dialect);
	 XSQLDA *sqlda;
{
/**************************************
 *
 *	i s c _ e m b e d _ d s q l _ f e t c h
 *
 **************************************
 *
 * Functional description
 *	Fetch next record from a dynamic SQL cursor
 *
 **************************************/

	return isc_embed_dsql_fetch(user_status, cursor_name, (USHORT) * dialect,
								SQLDA_ARG);
}


#ifdef SCROLLABLE_CURSORS
ISC_EMBED_DSQL_FETCH2(user_status, cursor_name, dialect, SQLDA_PROTOTYPE,
					  direction, offset)
	 ISC_STATUS *user_status;
	 SCHAR *cursor_name;
	 SLONG GDS_VAL(dialect);
	 XSQLDA *sqlda;
	 USHORT direction;
	 SLONG offset;
{
/**************************************
 *
 *	i s c _ e m b e d _ d s q l _ f e t c h 2
 *
 **************************************
 *
 * Functional description
 *	Fetch next record from a dynamic SQL cursor
 *
 **************************************/

	return isc_embed_dsql_fetch2(user_status, cursor_name, (USHORT) * dialect,
								 SQLDA_ARG, direction, offset);
}
#endif


ISC_EMBED_DSQL_INSERT(user_status, cursor_name, dialect, sqlda)
	 ISC_STATUS *user_status;
	 SCHAR *cursor_name;
	 SLONG GDS_VAL(dialect);
	 XSQLDA *sqlda;
{
/**************************************
 *
 *      i s c _ e m b e d _ d s q l _ i n s e r t
 *
 **************************************
 *
 * Functional description
 *      Insert next record into a dynamic SQL cursor
 *
 **************************************/

	return isc_embed_dsql_insert(user_status, cursor_name, (USHORT) * dialect,
								 sqlda);
}


ISC_EMBED_DSQL_LENGTH(string, length)
	 SCHAR *string;
	 USHORT *length;
{
/**************************************
 *
 *	i s c _ e m b e d _ d s q l _ l e n g t h
 *
 **************************************
 *
 * Functional description
 *	Determine length of a ';' or null terminated string
 *
 **************************************/

	return isc_embed_dsql_length(string, length);
}


ISC_EMBED_DSQL_OPEN(user_status, trans_handle, cursor_name, dialect,
					SQLDA_PROTOTYPE)
	 ISC_STATUS *user_status;
	 SLONG **trans_handle;
	 SCHAR *cursor_name;
	 SLONG GDS_VAL(dialect);
	 XSQLDA *sqlda;
{
/**************************************
 *
 *	i s c _ e m b e d _ d s q l _ o p e n
 *
 **************************************
 *
 * Functional description
 *	Open a dynamic SQL cursor.
 *
 **************************************/

	return isc_embed_dsql_open(user_status, trans_handle, cursor_name,
							   (USHORT) * dialect, SQLDA_ARG);
}


ISC_EMBED_DSQL_OPEN2(user_status, trans_handle, cursor_name, dialect,
					 in_sqlda, out_sqlda)
	 ISC_STATUS *user_status;
	 SLONG **trans_handle;
	 SCHAR *cursor_name;
	 SLONG GDS_VAL(dialect);
	 XSQLDA *in_sqlda, *out_sqlda;
{
/**************************************
 *
 *      i s c _ e m b e d _ d s q l _ o p e n 2
 *
 **************************************
 *
 * Functional description
 *      Open a dynamic SQL cursor.
 *
 **************************************/

	return isc_embed_dsql_open2(user_status, trans_handle, cursor_name,
								(USHORT) * dialect, in_sqlda, out_sqlda);
}


ISC_EMBED_DSQL_PREPARE(user_status, db_handle, trans_handle, stmt_name,
					   length, string, dialect, SQLDA_PROTOTYPE)
	 ISC_STATUS *user_status;
	 SLONG **db_handle;
	 SLONG **trans_handle;
	 SCHAR *stmt_name;
	 SLONG GDS_VAL(length);
	 SCHAR *string;
	 SLONG GDS_VAL(dialect);
	 XSQLDA *sqlda;
{
/**************************************
 *
 *	i s c _ e m b e d _ d s q l _ p r e p a r e
 *
 **************************************
 *
 * Functional description
 *	Prepare a statement for execution.
 *
 **************************************/

	return isc_embed_dsql_prepare(user_status, db_handle, trans_handle,
								  stmt_name, (USHORT) * length, string,
								  (USHORT) * dialect, SQLDA_ARG);
}


ISC_EMBED_DSQL_RELEASE(user_status, stmt_name)
	 ISC_STATUS *user_status;
	 SCHAR *stmt_name;
{
/**************************************
 *
 *	i s c _ e m b e d _ d s q l _ r e l e a s e
 *
 **************************************
 *
 * Functional description
 *	Release request for a dsql statement
 *
 **************************************/

	return isc_embed_dsql_release(user_status, stmt_name);
}


void ISC_ENCODE_DATE(times, date)
	 struct tm *times;
	 SLONG date[2];
{
/**************************************
 *
 *	i s c _ e n c o d e
 *
 **************************************
 *
 * Functional description
 *	Convert from UNIX time structure to internal date format.
 *
 **************************************/

	isc_encode_date(times, date);
}


USHORT ISC_EVENT_BLOCK_A(event_buffer, result_buffer, count, name_buffer)
	 UCHAR **event_buffer, **result_buffer;
	 SLONG GDS_VAL(count);
	 UCHAR **name_buffer;
{
/**************************************
 *
 *	i s c _ e v e n t _ b l o c k _ a 
 *
 **************************************
 *
 * Functional description
 *	Create an initialized event parameter block from a
 *	vector of input arguments. (Ada needs this)
 *	Assume all strings are 31 characters long.
 *	Return the size of the block.
 *
 **************************************/

	return isc_event_block_a(event_buffer, result_buffer, (USHORT) * count,
							 name_buffer);
}


void ISC_EVENT_COUNTS(result_vector, buffer_length, event_buffer,
					  result_buffer)
	 ULONG *result_vector;
	 SLONG GDS_VAL(buffer_length);
	 UCHAR **event_buffer, **result_buffer;
{
/**************************************
 *
 *	i s c _ e v e n t _ c o u n t s
 *
 **************************************
 *
 * Functional description
 *	Get the delta between two events in an event
 *	parameter block.  Used to update isc_events
 *	for GPRE support of events.
 *
 **************************************/

	isc_event_counts(result_vector, (SSHORT) * buffer_length, *event_buffer,
					 *result_buffer);
}


ISC_EXECUTE(user_status, trans_handle, name, sqlda)
	 ISC_STATUS *user_status;
	 TEXT *name;
	 TRA *trans_handle;
	 XSQLDA *sqlda;
{
/**************************************
 *
 *	i s c _ e x e c u t e
 *
 **************************************
 *
 * Functional description
 *	Execute a non-SELECT dynamic SQL statement.
 *
 **************************************/

	return isc_execute(user_status, trans_handle, name, sqlda);
}


ISC_EXECUTE_IMMEDIATE(user_status, db_handle, trans_handle, length, string)
	 ISC_STATUS *user_status;
	 int **db_handle, **trans_handle;
	 SLONG *length;
	 TEXT *string;
{
/**************************************
 *
 *	i s c _ e x e c u t e _ i m m e d i a t e
 *
 **************************************
 *
 * Functional description
 *	Prepare a statement for execution.
 *
 **************************************/
	USHORT len;

	len = *length;
	return isc_execute_immediate(user_status, db_handle,
								 trans_handle, &len, string);
}


ISC_FETCH(user_status, name, sqlda)
	 ISC_STATUS *user_status;
	 TEXT *name;
	 XSQLDA *sqlda;
{
/**************************************
 *
 *	i s c _ f e t c h
 *
 **************************************
 *
 * Functional description
 *	Fetch next record from a dynamic SQL cursor
 *
 **************************************/
	return isc_fetch(user_status, name, sqlda);
}


ISC_FTOF(string, length1, field, length2)
	 SCHAR *string, *field;
	 SLONG GDS_VAL(length1), GDS_VAL(length2);
{
/**************************************
 *
 *	G D S _ f t o f
 *
 **************************************
 *
 * Functional description
 *	Move a fixed length string to a fixed length string.
 *	This is typically generated by the preprocessor to
 *	move strings around.
 *
 **************************************/

	isc_ftof(string, (SSHORT) * length1, field, (SSHORT) * length2);
}


ISC_STATUS ISC_GET_SEGMENT(user_status, blob_handle, length, buffer_length,
					   buffer)
	 ISC_STATUS *user_status;
	 BLB *blob_handle;
	 SSHORT *length;
	 SLONG GDS_VAL(buffer_length);
	 SCHAR *buffer;
{
/**************************************
 *
 *	i s c _ g e t _ s e g m e n t
 *
 **************************************
 *
 * Functional description
 *	Abort a partially completed blob.
 *
 **************************************/
	ISC_STATUS status;
	SSHORT return_length;

	status = isc_get_segment(user_status, blob_handle,
							 &return_length, (SSHORT) * buffer_length,
							 buffer);
	*length = return_length;

	return status;
}


ISC_STATUS ISC_GET_SLICE(user_status, db_handle, tra_handle, array_id,
					 sdl_length, sdl, param_length, param, slice_length,
					 slice, return_length)
	 ISC_STATUS *user_status;
	 ATT *db_handle;
	 TRA *tra_handle;
	 SLONG *array_id;
	 SLONG GDS_VAL(sdl_length);
	 UCHAR *sdl;
	 SLONG GDS_VAL(param_length);
	 UCHAR *param;
	 SLONG GDS_VAL(slice_length);
	 UCHAR *slice;
	 SLONG *return_length;
{
/**************************************
 *
 *	i s c _ g e t _ s l i c e
 *
 **************************************
 *
 * Functional description
 *	Snatch a slice of an array.
 *
 **************************************/

	return isc_get_slice(user_status, db_handle, tra_handle, array_id,
						 (SSHORT) * sdl_length, sdl,
						 (SSHORT) * param_length, param,
						 *slice_length, slice, return_length);
}


ISC_OPEN(user_status, trans_handle, name, sqlda)
	 ISC_STATUS *user_status;
	 TEXT *name;
	 TRA *trans_handle;
	 XSQLDA *sqlda;
{
/**************************************
 *
 *	i s c _ o p e n
 *
 **************************************
 *
 * Functional description
 *	Open a dynamic SQL cursor.
 *
 **************************************/

	return isc_open(user_status, trans_handle, name, sqlda);
}


ISC_STATUS ISC_OPEN_BLOB(user_status, db_handle, tra_handle, blob_handle, blob_id)
	 ISC_STATUS *user_status;
	 ATT *db_handle;
	 TRA *tra_handle;
	 BLB *blob_handle;
	 SLONG *blob_id;
{
/**************************************
 *
 *	i s c _ o p e n _ b l o b
 *
 **************************************
 *
 * Functional description
 *	Open an existing blob.
 *
 **************************************/

	return isc_open_blob(user_status, db_handle, tra_handle, blob_handle,
						 blob_id);
}


ISC_STATUS ISC_OPEN_BLOB2(user_status, db_handle, tra_handle, blob_handle,
					  blob_id, bpb_length, bpb)
	 ISC_STATUS *user_status;
	 ATT *db_handle;
	 TRA *tra_handle;
	 BLB *blob_handle;
	 SLONG *blob_id;
	 SLONG GDS_VAL(bpb_length);
	 UCHAR *bpb;
{
/**************************************
 *
 *	i s c _ o p e n _ b l o b 2
 *
 **************************************
 *
 * Functional description
 *	Open an existing blob (extended edition).
 *
 **************************************/

	return isc_open_blob2(user_status, db_handle, tra_handle, blob_handle,
						  blob_id, (SSHORT) * bpb_length, bpb);
}


ISC_PREPARE(user_status, db_handle, trans_handle, name, length, string, sqlda)
	 ISC_STATUS *user_status;
	 int **db_handle, **trans_handle;
	 TEXT *name;
	 SLONG *length;
	 TEXT *string;
	 XSQLDA *sqlda;
{
/**************************************
 *
 *	i s c _ p r e p a r e
 *
 **************************************
 *
 * Functional description
 *	Prepare a dsql statement for execution.
 *
 **************************************/
	USHORT len;

	len = *length;

	return isc_prepare(user_status, db_handle, trans_handle, name,
					   &len, string, sqlda);
}


ISC_STATUS ISC_PREPARE_TRANS(user_status, tra_handle)
	 ISC_STATUS *user_status;
	 TRA *tra_handle;
{
/**************************************
 *
 *	i s c _ p r e p a r e _ t r a n s a c t i o n
 *
 **************************************
 *
 * Functional description
 *	Prepare a transaction for commit.  First 
 *	phase of a two phase commit.
 *
 **************************************/

	return isc_prepare_transaction(user_status, tra_handle);
}


ISC_STATUS ISC_PREPARE2(user_status, tra_handle, msg_length, msg)
	 ISC_STATUS *user_status;
	 TRA *tra_handle;
	 SLONG GDS_VAL(msg_length);
	 UCHAR *msg;
{
/**************************************
 *
 *	i s c _ p r e p a r e 2
 *
 **************************************
 *
 * Functional description
 *	Prepare a transaction for commit.  First phase of a two
 *	phase commit.
 *
 **************************************/

	return isc_prepare_transaction2(user_status, tra_handle,
									(SSHORT) * msg_length, msg);
}


void ISC_PRINT_SQLERROR(sqlcode, status_vector)
	 SLONG GDS_VAL(sqlcode);
	 ISC_STATUS *status_vector;
{
/**************************************
 *
 *	i s c _ p r i n t _ s q l _ e r r o r
 *
 **************************************
 *
 * Functional description
 *	Given an sqlcode, give as much info as possible.
 *      Decide whether status is worth mentioning.
 *
 **************************************/

	isc_print_sqlerror((SSHORT) * sqlcode, status_vector);
}


ISC_PRINT_STATUS(status_vector)
	 ISC_STATUS *status_vector;
{
/**************************************
 *
 *	i s c _ p r i n t _ s t a t u s
 *
 **************************************
 *
 * Functional description
 *	Print status vector.
 *
 **************************************/

	return isc_print_status(status_vector);
}


ISC_STATUS ISC_PUT_SEGMENT(user_status, blob_handle, buffer_length, buffer)
	 ISC_STATUS *user_status;
	 BLB *blob_handle;
	 SSHORT GDS_VAL(buffer_length);
	 SCHAR *buffer;
{
/**************************************
 *
 *	i s c _ p u t _ s e g m e n t
 *
 **************************************
 *
 * Functional description
 *	Store one piece of a blob
 *
 **************************************/

	return isc_put_segment(user_status, blob_handle, *buffer_length, buffer);
}


ISC_STATUS ISC_PUT_SLICE(user_status, db_handle, tra_handle, array_id,
					 sdl_length, sdl, param_length, param, slice_length,
					 slice)
	 ISC_STATUS *user_status;
	 ATT *db_handle;
	 TRA *tra_handle;
	 SLONG *array_id;
	 SLONG GDS_VAL(sdl_length);
	 UCHAR *sdl;
	 SLONG GDS_VAL(param_length);
	 UCHAR *param;
	 SLONG GDS_VAL(slice_length);
	 UCHAR *slice;
{
/**************************************
 *
 *	i s c _ p u t _ s l i c e
 *
 **************************************
 *
 * Functional description
 *	Snatch a slice of an array.
 *
 **************************************/

	return isc_put_slice(user_status, db_handle, tra_handle, array_id,
						 (SSHORT) * sdl_length, sdl,
						 (SSHORT) * param_length, param,
						 *slice_length, slice);
}


void ISC_QTOQ(quad_in, quad_out)
	 GDS__QUAD *quad_in, *quad_out;
{
/**************************************
 *
 *	i s c _ q t o q
 *
 **************************************
 *
 * Functional description
 *	Move a quad value to another quad value.  This
 *      call is generated by the preprocessor when assigning
 *      quad values in FORTRAN.
 *
 **************************************/

	isc_qtoq(quad_in, quad_out);
}


ISC_STATUS ISC_QUE_EVENTS(user_status, handle, id, length, events, ast, arg)
	 ISC_STATUS *user_status;
	 ATT *handle;
	 SLONG *id;
	 USHORT GDS_VAL(length);
	 UCHAR *events;
	 int (*ast) ();
	 SLONG arg;
{
/**************************************
 *
 *	i s c _ q u e _ e v e n t s
 *
 **************************************
 *
 * Functional description
 *	Que request for event notification.
 *
 **************************************/

	return isc_que_events(user_status, handle, id,
						  (USHORT) * length, events, ast, arg);
}


ISC_STATUS ISC_RECEIVE(user_status, req_handle, msg_type, msg_length, msg, level)
	 ISC_STATUS *user_status;
	 REQ *req_handle;
	 SLONG *msg_type, *msg_length;
	 SCHAR *msg;
	 SLONG *level;
{
/**************************************
 *
 *	i s c _ r e c e i v e
 *
 **************************************
 *
 * Functional description
 *	Get a record from the host program.
 *
 **************************************/

	return isc_receive(user_status, req_handle,
					   (SSHORT) * msg_type, (SSHORT) * msg_length, msg,
					   (SSHORT) * level);
}


ISC_STATUS ISC_RECONNECT(user_status, db_handle, tra_handle, length, id)
	 ISC_STATUS *user_status;
	 ATT *db_handle;
	 TRA *tra_handle;
	 SLONG *length;
	 UCHAR *id;
{
/**************************************
 *
 *	i s c _ r e c o n n e c t
 *
 **************************************
 *
 * Functional description
 *	Connect to a transaction in limbo.
 *
 **************************************/

	return isc_reconnect_transaction(user_status, db_handle,
									 tra_handle, (SSHORT) * length, id);
}


ISC_STATUS ISC_RELEASE_REQUEST(user_status, req_handle)
	 ISC_STATUS *user_status;
	 REQ *req_handle;
{
/**************************************
 *
 *	i s c _ r e l e a s e _ r e q u e s t
 *
 **************************************
 *
 * Functional description
 *	Release a request.
 *
 **************************************/

	return isc_release_request(user_status, req_handle);
}


ISC_STATUS ISC_REQUEST_INFO(user_status, req_handle, level, item_length, items,
						buffer_length, buffer)
	 ISC_STATUS *user_status;
	 REQ *req_handle;
	 SLONG *item_length, *buffer_length;
	 SCHAR *items, *buffer;
	 SLONG *level;
{
/**************************************
 *
 *	i s c _ r e q u e s t _ i n f o
 *
 **************************************
 *
 * Functional description
 *	Provide information on blob object.
 *
 **************************************/

	return isc_request_info(user_status, req_handle,
							(SSHORT) * level, (SSHORT) * item_length, items,
							(SSHORT) * buffer_length, buffer);
}


ISC_STATUS ISC_ROLLBACK(user_status, tra_handle)
	 ISC_STATUS *user_status;
	 TRA *tra_handle;
{
/**************************************
 *
 *	i s c _ r o l l b a c k
 *
 **************************************
 *
 * Functional description
 *	Abort a transaction.
 *
 **************************************/

	return isc_rollback_transaction(user_status, tra_handle);
}


ISC_STATUS ISC_SEEK_BLOB(user_status, blob_handle, mode, offset, result)
	 ISC_STATUS *user_status;
	 BLB *blob_handle;
	 SLONG *mode;
	 SLONG *offset;
	 SLONG *result;
{
/**************************************
 *
 *	i s c _ s e e k _ b l o b
 *
 **************************************
 *
 * Functional description
 *	Seek a blob.
 *
 **************************************/

	return isc_seek_blob(user_status, blob_handle, (SSHORT) * mode, *offset,
						 result);
}


ISC_STATUS ISC_SEND(user_status, req_handle, msg_type, msg_length, msg, level)
	 ISC_STATUS *user_status;
	 REQ *req_handle;
	 SLONG *msg_type, *msg_length;
	 SCHAR *msg;
	 SLONG *level;
{
/**************************************
 *
 *	i s c _ s e n d
 *
 **************************************
 *
 * Functional description
 *	Get a record from the host program.
 *
 **************************************/

	return isc_send(user_status, req_handle, (SSHORT) * msg_type,
					(SSHORT) * msg_length, msg, (SSHORT) * level);
}


ISC_STATUS ISC_SQLCODE(user_status)
	 ISC_STATUS *user_status;
{
/**************************************
 *
 *	g d s _  s q l c o d e
 *
 **************************************
 *
 * Functional description
 *	Translate the GDS error code to SQL error code.
 *
 **************************************/
	return isc_sqlcode(user_status);
}


ISC_STATUS ISC_START_AND_SEND(user_status, req_handle, tra_handle,
						  msg_type, msg_length, msg, level)
	 ISC_STATUS *user_status;
	 REQ *req_handle;
	 TRA *tra_handle;
	 SLONG *msg_type, *msg_length;
	 SCHAR *msg;
	 SLONG *level;
{
/**************************************
 *
 *	i s c _ s t a r t _ a n d _ s e n d
 *
 **************************************
 *
 * Functional description
 *	Get a record from the host program.
 *
 **************************************/

	return isc_start_and_send(user_status, req_handle, tra_handle,
							  (SSHORT) * msg_type, (SSHORT) * msg_length, msg,
							  (SSHORT) * level);
}


ISC_STATUS ISC_START(user_status, req_handle, tra_handle, level)
	 ISC_STATUS *user_status;
	 REQ *req_handle;
	 TRA *tra_handle;
	 SLONG *level;
{
/**************************************
 *
 *	i s c _ s t a r t
 *
 **************************************
 *
 * Functional description
 *	Get a record from the host program.
 *
 **************************************/

	return isc_start_request(user_status, req_handle, tra_handle,
							 (SSHORT) * level);
}


ISC_STATUS ISC_START_MULTIPLE(user_status, tra_handle, count, vector)
	 ISC_STATUS *user_status;
	 TRA *tra_handle;
	 SLONG GDS_VAL(count);
	 TEB *vector;
{
/**************************************
 *
 *	i s c _ s t a r t _ m u l t i p l e
 *
 **************************************
 *
 * Functional description
 *	Start a transaction.
 *
 **************************************/

	return isc_start_multiple(user_status, tra_handle, (SSHORT) * count,
							  vector);
}


ISC_STATUS ISC_START_TRANSACTION(ISC_STATUS * user_status,
							 TRA * tra_handle, SLONG GDS_VAL(count), ...)
{
/**************************************
 *
 *	i s c _ s t a r t _ t r a n s a c t i o n
 *
 **************************************
 *
 * Functional description
 *	Start a transaction.
 *
 **************************************/
	TEB tebs[16], *teb, *end;
	va_list ptr;

	teb = tebs;
	end = teb + *count;
	VA_START(ptr, count);

	for (; teb < end; teb++) {
		teb->teb_database = va_arg(ptr, ATT *);
		teb->teb_tpb_length = *(va_arg(ptr, int *));
		teb->teb_tpb = va_arg(ptr, UCHAR *);
	}

	return isc_start_multiple(user_status, tra_handle,
							  (SSHORT) * count, tebs);
}


ISC_STATUS ISC_TRANSACT_REQUEST(user_status, db_handle, tra_handle,
							blr_length, blr, in_msg_length, in_msg,
							out_msg_length, out_msg)
	 ISC_STATUS *user_status;
	 ATT *db_handle;
	 TRA *tra_handle;
	 SCHAR *blr;
	 SLONG GDS_VAL(blr_length);
	 SLONG GDS_VAL(in_msg_length), GDS_VAL(out_msg_length);
	 SCHAR *in_msg, *out_msg;
{
/**************************************
 *
 *	i s c _ t r a n s a c t _ r e q u e s t
 *
 **************************************
 *
 * Functional description
 *	Execute a procedure.
 *
 **************************************/

	return isc_transact_request(user_status, db_handle, tra_handle,
								(USHORT) * blr_length, blr,
								(USHORT) * in_msg_length, in_msg,
								(USHORT) * out_msg_length, out_msg);
}


ISC_STATUS ISC_TRANSACTION_INFO(user_status, tra_handle,
							item_length, items, buffer_length, buffer)
	 ISC_STATUS *user_status;
	 TRA *tra_handle;
	 SLONG *item_length, *buffer_length;
	 SCHAR *items, *buffer;
{
/**************************************
 *
 *	i s c _ t r a n s a c t i o n _ i n f o
 *
 **************************************
 *
 * Functional description
 *	Provide information on blob object.
 *
 **************************************/

	return isc_transaction_info(user_status, tra_handle,
								(SSHORT) * item_length, items,
								(SSHORT) * buffer_length, buffer);
}


ISC_STATUS ISC_UNWIND_REQUEST(user_status, req_handle, level)
	 ISC_STATUS *user_status;
	 REQ *req_handle;
	 SLONG *level;
{
/**************************************
 *
 *	i s c _ u n w i n d
 *
 **************************************
 *
 * Functional description
 *	Unwind a running request.  This is potentially nasty since it can be called
 *	asynchronously.
 *
 **************************************/

	isc_unwind_request(user_status, req_handle, (SSHORT) * level);
	return;
}


SLONG ISC_VAX_INTEGER(ptr, length)
	 UCHAR *ptr;
	 SLONG length;
{
/**************************************
 *
 *	i s c _ v a x _ i n t e g e r
 *
 **************************************
 *
 * Functional description
 *	Pick up (and convert) a VAX style integer of length 1, 2, or 4
 *	bytes.
 *
 **************************************/

	return isc_vax_integer(ptr, (SSHORT) length);
}


ISC_VERSION(handle, routine, user_arg)
	 int *handle;
	 int (*routine) ();
	 SCHAR *user_arg;
{
/**************************************
 *
 *	i s c _ v e r s i o n
 *
 **************************************
 *
 * Functional description
 *	Obtain and print information about a database.
 *
 **************************************/

	isc_version(handle, routine, user_arg);
}


ISC_STATUS ISC_WAIT_FOR_EVENT(user_status, handle, length, events, buffer)
	 ISC_STATUS *user_status;
	 ATT *handle;
	 SLONG length;
	 UCHAR **events, **buffer;
{
/**************************************
 *
 *	i s c _ w a i t _ f o r _ e v e n t
 *
 **************************************
 *
 * Functional description
 *	Que request for event notification.
 *
 **************************************/

	return isc_wait_for_event(user_status, (SSHORT) * handle, length, events,
							  buffer);
}



PERF_FORMAT(before, after, string, buffer, buf_len)
	 PERF *before, *after;
	 SCHAR *buffer, *string;
	 SSHORT *buf_len;
{
/**************************************
 *
 *	P E R F _ f o r m a t
 *
 **************************************
 *
 * Functional description
 *	Format a buffer with statistical stuff under control of formatting
 *	string.  Substitute in appropriate stuff.  Return the length of the
 *	formatting output.
 *
 **************************************/

	perf_format(before, after, string, buffer, buf_len);
}


PERF_GET_INFO(handle, perf)
	 int **handle;
	 PERF *perf;
{
/**************************************
 *
 *	P E R F _ g e t _ i n f o
 *
 **************************************
 *
 * Functional description
 *	Acquire timing and performance information.  Some info comes
 *	from the system and some from the database.
 *
 **************************************/

	perf_get_info(handle, perf);
}


void PERF_REPORT(before, after, buffer, buf_len)
	 PERF *before, *after;
	 SCHAR *buffer;
	 SSHORT *buf_len;
{
/**************************************
 *
 *	p e r f _ r e p o r t
 *
 **************************************
 *
 * Functional description
 *	Report a common set of parameters.
 *
 **************************************/

	perf_report(before, after, buffer, buf_len);
}

