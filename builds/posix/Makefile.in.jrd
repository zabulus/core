

# This library is free software; you can redistribute it and/or
# modify it under the terms of the GNU Lesser General Public
# License as published by the Free Software Foundation; either
# version 2.1 of the License, or (at your option) any later version.
# You may obtain a copy of the Licence at
# http://www.gnu.org/licences/lgpl.html
# 
# As a special exception this file can also be included in modules
# with other source code as long as that source code has been 
# released under an Open Source Initiative certificed licence.  
# More information about OSI certification can be found at: 
# http://www.opensource.org 
# 
# This module is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU Lesser General Public Licence for more details.
# 
# This module was created by members of the firebird development 
# team.  All individual contributions remain the Copyright (C) of 
# those individuals and all rights are reserved.  Contributors to 
# this file are either listed below or can be obtained from a CVS 
# history command.
#
#  Created by:  Mark O'Donohue <mark.odonohue@ludwig.edu.au>
#
#  Contributor(s):
# 
#
#  $Id: Makefile.in.jrd,v 1.9 2003-03-17 12:05:49 eku Exp $
#
ROOT=../..

include     $(ROOT)/src/make.platform
include     $(ROOT)/src/make.rules
include     $(ROOT)/src/make.defaults
include     $(ROOT)/src/make.shared.variables

@SET_MAKE@


# jrd has it's own rule for using gpre to use gpre boot.
# I would eventually like to set these based on a determination
# if the file GPRE_STATIC exists or not.

GPRE_FLAGS = -n -z -gds_cxx -raw -ids

#.e.c:
#	$(GPRE_BOOT) $(GPRE_FLAGS) $< $@
#
#.epp.cpp:
#	$(GPRE_BOOT) $(GPRE_FLAGS) $< $@



.PHONY: jrd_boot


# This is the very first library built it contains just enough methods
# to enable a gpre_boot program to built.

BOOT_Sources =	dsc.cpp gds.cpp isc_ipc.cpp isc.cpp dls.cpp
BOOT_Objects = $(BOOT_Sources:%.cpp=$(OBJ)/%.o)


jrd_boot : $(LIB)/jrd_boot.a

$(LIB)/jrd_boot.a:	$(BOOT_Objects)
	-$(RM) $@
	$(AR) $@ $^
	-$(RANLIB) $@
	$(CHMOD_6) $@


# Add all the jrd objects to the jrd static library.

$(LIBGDS_A) : $(GDSLIB_Objects)
	ar -q $@ $^
	-$(RANLIB) $@


# This is the first dynamic link library that we build in phase2 it still
# does not contain security objects.  Also used to produce the object files
# that the *_static programs link against.
jrdlib_dependencies: $(JRD_Objects) $(OS_SPECIFIC_Objects)



# The jrdlib_main will equate to either the libgds.$(SHRLIB_EXT) or libgds.a
# depending upon choices made in make.rules and prefix.xxx where
# xxx is plaform.

jrdlib_main : $(LIBGDS_LA)
#jrdlib_main : $(LIBGDS_SO) $(LIBGDS_A)


$(LIBGDS_SO) : $(GDSLIB_Objects)
	$(LIB_LINK) $(LIBGDS_LINK_OPTIONS)  -o $@ $^
	-$(LN) $(@F) $(LIBGDS_SO_X_LNK)
	-$(LN) $(notdir $(LIBGDS_SO_X_LNK)) $(LIBGDS_SO_LNK)

$(LIBGDS_A) : $(GDSLIB_Objects)
	$(STATICLIB_LINK) $(LIBGDS_LINK_OPTIONS)  $@ $^


#____________________________________________________________________________
#
# Everything below here is crap - well maybe that's an overstatement :-).
# It comes from the original sfx.jrd file and I've left it here for now
# for reference until I finish rewriting the super server make.


DSQL_HEAD_MISC=	$(OBJS)/dsql/array.o $(OBJS)/dsql/blob.o \
		$(OBJS)/dsql/preparse.o \
		$(OBJS)/dsql/user_dsql.o $(OBJS)/dsql/utld.o

DSQL_J_HEAD_MISC=	source/dsql/array.j source/dsql/blob.j \
		source/dsql/preparse.j \
		source/dsql/user_dsql.j source/dsql/utld.j






JRD_CLIENT_P_OBJECTS=	alt.bin cvt.bin dsc.bin dls.bin enc.bin gds.bin \
			isc.bin isc_file.bin isc_ipc.bin isc_sync.bin \
			perf.bin sch.bin sdl.bin thd.bin utl.bin \
			why.bin




# The infamous codes files
CODES_FILES=	$(OBJS)/firebird/include/gds_codes.pas \
		$(OBJS)/firebird/include/gds_codes.ftn \
		$(OBJS)/firebird/include/codes.h \
		$(OBJS)/firebird/include/iberror.h \
		$(OBJS)/firebird/include/codetext.h \
		$(OBJS)/firebird/include/msgs.h \
		$(OBJS)/firebird/include/rdb_codes.h \
		$(OBJS)/firebird/include/sql_code.h \
		$(OBJS)/firebird/include/msg_facs.h

# Temporarily removing $(BACKEND_BRIDGE_MISC) from SUPER_OBJECTS
# Also, whatever SUPER_OBJECTS includes should be forced to build under
# the 'super_server_objects' target. Currently DSQL, LOCK, REMOTE,
# WAL are included. INTL is not needed.
SUPER_OBJECTS=	$(DSQL_MISC) $(LOCK_MISC) \
		$(REMOTE_MISC) \
		$(INTL_MISC) $(WAL_MISC) $(ALICE_MISC) $(BURP_MISC) \
		$(SECURITY_MISC) $(GSTAT_MISC) $(GSEC_MISC) $(UTIL_MISC) \
		$(STDIO)

HEAD_OBJECTS= whyp.o utlp.o dls.o enc.o \
		$(JRD_MISC) $(JRD_HEAD_MISC) $(DSQL_HEAD_MISC) \
		$(MERGE_MISC) $(SECURITY_MISC)

HEAD_J_OBJECTS=	whyp.j utlp.j \
		$(JRD_J_MISC) $(JRD_J_HEAD_MISC) $(DSQL_J_HEAD_MISC) \
		$(MERGE_J_MISC)

FOOT_OBJECTS=	$(FOOT_OBJECT) $(ALLP_OBJECT)
ALLP_OBJECT=	$(OBJS)/pipe/allp.o
FOOT_OBJECT=	$(OBJS)/pipe/foot.o


#  All objects necessary to have a minimal (but functional) engine statically
# linked an executable.  Used to create gbak_static and gpre_static, amoung
# other things.
ENGINE_STATIC_OBJS= \
	$(JRD_OBJECTS) $(DSQL_MISC) \
	$(LOCK_MISC) $(REMOTE_MISC) $(BRIDGE_MISC) \
	$(INTL_MISC) $(WAL_MISC) \
	 $(WHY_O)

all:		gds.h $(GDSSHR) $(PIPE)


gds_b.a source/./interbase/lib/gds_b.a $(GDSLIB_BACKEND): \
		$(WHYBK_O) $(JRD_OBJECTS) $(OTHER_OBJECTS)
	-$(RM) gds_b.a
	$(AR) gds_b.a $(WHYBK_O) $(JRD_OBJECTS) $(OTHER_OBJECTS)
	-ranlib gds_b.a
	$(CHMOD_6) gds_b.a

gds_ss.a source/./interbase/lib/gds_ss.a $(SUPER_BACKEND): \
		gds.h $(WHYBK_O) $(JRD_OBJECTS) super_server_objects $(SUPER_OBJECTS)
	-$(RM) gds_ss.a
	$(AR) gds_ss.a $(WHYBK_O) $(JRD_OBJECTS) $(SUPER_OBJECTS)
	-ranlib gds_ss.a
	$(CHMOD_6) gds_ss.a

gds_b.lib:	$(WHYBK_O) $(JRD_OBJECTS)
	-$(RM) gds_b.lib
	$(IMPLIB) -out:gds_b.lib $(WHYBK_O) $(JRD_OBJECTS)
	$(IMPLIB) -out:gds_b.lib gds_b.lib $(OTHER_OBJECTS)
	$(TOUCH) gds_b.lib

gdsshr.a $(AIX_GDSSHR) $(AIX_PPC_GDSSHR): gds_b.a gds.bind
	ld -bE:gds.bind -bM:SRE -H1024 $(GDSLIB_LINK) $(SCREEN_LIB) -lc -o gdsshr.o
	strip -t gdsshr.o
	-$(RM) gdsshr.a
	$(AR) gdsshr.a gdsshr.o
	-ranlib gdsshr.a
	$(CHMOD_6) gdsshr.a
	$(MV) gdsshr.a $(GDSSHR)
	-$(RM) gdsshr.o
	$(TOUCH) gdsshr.a
	$(CHMOD_6) gdsshr.a

gdslib $(AP_GDSSHR) $(AX_GDSSHR): gds_b.a bind_gdslib nodebug.o
	-$(RM) gdslib
	/com/bind <bind_gdslib
	$(CHMOD_7) gdslib
	$(MV) gdslib $(GDSSHR)
	$(TOUCH) gdslib
	$(CHMOD_6) gdslib

bridge.apollo:	gdslib
	-$(RM) bridge5
	/com/bind <bind_bridge
	$(CHMOD_7) bridge5

gds.sl $(HP_GDSSHR): $(JRD_P_OBJECTS) flu.bin $(DSQL_P_MISC) $(LOCK_P_MISC) \
		$(REMOTE_P_MISC) $(WAL_P_MISC) \
		$(SECURITY_P_MISC) functions.bin gds.bind
	-$(RM) gds.sl
	ld -b $(LD_OPTS) $(JRD_P_OBJECTS) flu.bin $(DSQL_P_MISC) \
		$(LOCK_P_MISC) $(REMOTE_P_MISC) \
		$(WAL_P_MISC) \
		$(SECURITY_P_MISC) functions.bin -o gds.sl
	$(CHMOD_7) gds.sl
	$(MV) gds.sl $(GDSSHR)
	$(TOUCH) gds.sl
	$(CHMOD_6) gds.sl

# IMPORTANT!!!! - New v4 routines should NOT be added to the bridge targets
#		  These targets are provided to create the v3 bridge
#		  access method by making these targets on a V3 tree.

bridge.shared_o:	$(GDSSHR)
	-$(RM) bridge5
	ld $(BLD_OPTS) all.o blb.o blob_filter.o btr.o cch.o cmp.o \
		cvt.o dpm.o dyn.o dyn_def.o dyn_del.o \
		dyn_mod.o dyn_util.o enc.o err.o event.o \
		evl.o exe.o ext.o filters.o fun.o gds.o grant.o \
		idx.o inf.o ini.o intl.o iscb.o isc_file.o \
		jrd.o jrn.o lck.o log.o met.o mov.o nav.o \
		opt.o pag.o par.o perf.o pwd.o rse.o \
		sbm.o scl.o sdl.o sdw.o sort.o sqz.o sym.o \
		tra.o unix.o val.o vio.o flu.o functions.o \
		nodebug.o $(OBJS)/lock/lock.o $(OBJS)/dsql/all.o \
		$(OBJS)/dsql/ddl.o $(OBJS)/dsql/dsql.o $(OBJS)/dsql/err.o \
		$(OBJS)/dsql/gen.o $(OBJS)/dsql/hsh.o $(OBJS)/dsql/make.o \
		$(OBJS)/dsql/met.o $(OBJS)/dsql/mov.o $(OBJS)/dsql/parse.o \
		$(OBJS)/dsql/pass1.o $(BsLsD_LIBS) -o bridge5
	$(CHMOD_7) bridge5

bridge.shared_bin:	$(GDSSHR)
	-$(RM) bridge5
	ld $(BLD_OPTS) all.bin blb.bin blob_filter.bin btr.bin cch.bin cmp.bin \
		cvt.bin dpm.bin dyn.bin dyn_def.bin dyn_del.bin \
		dyn_mod.bin dyn_util.bin enc.bin err.bin event.bin \
		evl.bin exe.bin ext.bin filters.bin fun.bin gds.bin grant.bin \
		idx.bin inf.bin ini.bin intl.bin iscb.bin isc_file.bin \
		jrd.bin jrn.bin lck.bin log.bin met.bin mov.bin nav.bin \
		opt.bin pag.bin par.bin perf.bin pwd.bin rse.bin \
		sbm.bin scl.bin sdl.bin sdw.bin sort.bin sqz.bin sym.bin \
		tra.bin unix.bin val.bin vio.bin flu.bin functions.bin \
		nodebug.bin $(OBJS)/lock/lock.bin $(OBJS)/dsql/all.bin \
		$(OBJS)/dsql/ddl.bin $(OBJS)/dsql/dsql.bin $(OBJS)/dsql/err.bin \
		$(OBJS)/dsql/gen.bin $(OBJS)/dsql/hsh.bin $(OBJS)/dsql/make.bin \
		$(OBJS)/dsql/met.bin $(OBJS)/dsql/mov.bin $(OBJS)/dsql/parse.bin \
		$(OBJS)/dsql/pass1.bin $(BLD_LIBS) -o bridge5
	$(CHMOD_7) bridge5

gds_s.a $(IMP_GDSSHR) $(SCO_GDSSHR): \
		$(JRD_P_OBJECTS) flu.bin $(IMP_FUNCSHR) \
		$(SCO_FUNCSHR) $(DSQL_P_MISC) \
		$(LOCK_P_MISC) $(REMOTE_P_MISC) $(SECURITY_P_MISC) \
		$(INTL_P_MISC) $(WAL_P_MISC) gds_s.bind
	-$(RM) gds_s.a source/interbase/lib/gds_s
	mkshlib -q -s gds_s.bind -h gds_s.a -t $(GDSSHR)
	$(CHMOD_7) source/interbase/lib/gds_s
	$(CHMOD_6) gds_s.a
	$(MV) gds_s.a source/interbase/lib/gds_s.a
	$(TOUCH) gds_s.a
	$(CHMOD_6) gds_s.a

gdsf_s.a $(IMP_FUNCSHR) $(SCO_FUNCSHR):	functions.bin \
		shrfinit.bin gdsf_s.bind
	-$(RM) gdsf_s.a source/interbase/lib/gdsf_s
	mkshlib -s gdsf_s.bind -h gdsf_s.a -t $(FUNCSHR)
	$(CHMOD_7) source/interbase/lib/gdsf_s
	$(CHMOD_6) gdsf_s.a
	$(MV) gdsf_s.a source/interbase/lib/gdsf_s.a
	$(TOUCH) gdsf_s.a
	$(CHMOD_6) gdsf_s.a

gdslib.$(SHRLIB_EXT).1.0 $(SUN_GDSSHR):	$(JRD_P_OBJECTS) flu.bin $(CSI_P_MISC) \
		$(DSQL_P_MISC) $(LOCK_P_MISC) $(REMOTE_P_MISC) $(SECURITY_P_MISC) \
		$(WAL_P_MISC) functions.bin gdslib.$(SHRLIB_EXT).0.1
	-$(RM) gdslib.$(SHRLIB_EXT).1.0
	ld -assert pure-text $(JRD_P_OBJECTS) flu.bin $(CSI_P_MISC) \
		$(DSQL_P_MISC) $(LOCK_P_MISC) $(REMOTE_P_MISC) $(SECURITY_P_MISC) \
		$(WAL_P_MISC) functions.bin -o gdslib.$(SHRLIB_EXT).1.0
	$(CHMOD_6) gdslib.$(SHRLIB_EXT).1.0
	$(MV) gdslib.$(SHRLIB_EXT).1.0 $(GDSSHR)
	$(TOUCH) gdslib.$(SHRLIB_EXT).1.0
	$(CHMOD_6) gdslib.$(SHRLIB_EXT).1.0

# If you really need this and can't do this via a define of NON_DL_COMPATIBLE
# when building flu.cpp then this should work.
#JRD_P_OBJECTS := $(subst flu.bin, flu_non_dl.bin, $JRD_P_OBJECTS)

#gdslib.$(SHRLIB_EXT).0.1:	$(JRD_P_OBJECTS) flu_non_dl.bin $(CSI_P_MISC) $(DSQL_P_MISC) \
#		$(LOCK_P_MISC) $(REMOTE_P_MISC) $(WAL_P_MISC) \
#		$(SECURITY_P_MISC) \
#		gdsflib.$(SHRLIB_EXT).0.0
#	-$(RM) gdslib.$(SHRLIB_EXT).0.1
#	ld -assert pure-text $(JRD_P_OBJECTS) flu_non_dl.bin $(CSI_P_MISC) \
#		$(DSQL_P_MISC) $(LOCK_P_MISC) $(REMOTE_P_MISC) $(SECURITY_P_MISC) \
#		$(WAL_P_MISC) -lgdsflib -o gdslib.$(SHRLIB_EXT).0.1
#	$(CHMOD_6) gdslib.$(SHRLIB_EXT).0.1
#	$(MV) gdslib.$(SHRLIB_EXT).0.1 source/interbase/lib
#	$(TOUCH) gdslib.$(SHRLIB_EXT).0.1
#	$(CHMOD_6) gdslib.$(SHRLIB_EXT).0.1

gdsflib.$(SHRLIB_EXT).0.0 $(SUN_FUNCSHR):	functions.bin
	-$(RM) gdsflib.$(SHRLIB_EXT).0.0
	ld -assert pure-text functions.bin -o gdsflib.$(SHRLIB_EXT).0.0
	$(CHMOD_6) gdsflib.$(SHRLIB_EXT).0.0
	$(MV) gdsflib.$(SHRLIB_EXT).0.0 $(SUN_FUNCSHR)
	$(TOUCH) gdsflib.$(SHRLIB_EXT).0.0
	$(CHMOD_6) gdsflib.$(SHRLIB_EXT).0.0

gds.$(SHRLIB_EXT).o $(SGI_GDSSHR) $(DECOSF_GDSSHR) : \
		$(WHY_O) $(JRD_OBJECTS) $(DSQL_MISC) $(LOCK_MISC) \
		$(REMOTE_MISC) $(BRIDGE_MISC) \
		$(INTL_MISC) $(WAL_MISC) $(FUNCTIONS)  $(SECURITY_MISC)
	-$(RM) gds.$(SHRLIB_EXT).o
	ld $(LD_OPTS) libgds.$(SHRLIB_EXT).0 $(ZDEFS) $(WHY_O) $(JRD_OBJECTS) \
		$(DSQL_MISC) $(LOCK_MISC) $(REMOTE_MISC) $(BRIDGE_MISC) \
		$(INTL_MISC) $(WAL_MISC) $(FUNCTIONS) $(SECURITY_MISC) \
		$(GDSF_LIB) $(LD_LIBS) -o gds.$(SHRLIB_EXT).0
	$(CHMOD_6) gds.$(SHRLIB_EXT).0
	$(MV) gds.$(SHRLIB_EXT).0 $(GDSSHR)
	$(TOUCH) gds.$(SHRLIB_EXT).o
	$(CHMOD_6) gds.$(SHRLIB_EXT).o

# For SCO_EV and LINUX the FUNCTIONS is part of JRD_OBJECTS.
gds.$(SHRLIB_EXT).O $(SCO_EV_GDSSHR): \
	$(WHY_O) $(JRD_OBJECTS) $(DSQL_MISC) $(LOCK_MISC) \
	$(REMOTE_MISC) $(BRIDGE_MISC) \
	$(INTL_MISC) $(WAL_MISC)  $(SECURITY_MISC)
	-$(RM) gds.$(SHRLIB_EXT).O
	ld $(LD_OPTS) libgds.$(SHRLIB_EXT).0 $(ZDEFS) $(WHY_O) $(JRD_OBJECTS) \
		$(DSQL_MISC) $(LOCK_MISC) $(REMOTE_MISC) $(BRIDGE_MISC) \
		$(INTL_MISC) $(WAL_MISC) $(SECURITY_MISC) \
		$(GDSF_LIB) $(LD_LIBS) -o gds.$(SHRLIB_EXT).0
	$(CHMOD_6) gds.$(SHRLIB_EXT).0
	$(MV) gds.$(SHRLIB_EXT).0 $(GDSSHR)
	$(TOUCH) gds.$(SHRLIB_EXT).O
	$(CHMOD_6) gds.$(SHRLIB_EXT).O

libgds.$(SHRLIB_EXT) gds.$(SHRLIB_EXT).linux: \
		$(JRD_P_OBJECTS) flu.bin $(CSI_P_MISC) $(DSQL_P_MISC) \
		$(LOCK_P_MISC) $(REMOTE_P_MISC) $(SECURITY_P_MISC) \
		$(INTL_P_MISC) $(WAL_P_MISC) \
		$(FUNCTIONS)
	-$(RM) gds.$(SHRLIB_EXT)
	ld $(LD_OPTS) $(ZDEFS) $(JRD_P_OBJECTS) flu.bin \
		$(CSI_P_MISC) $(DSQL_P_MISC) $(LOCK_P_MISC) \
		$(REMOTE_P_MISC) $(SECURITY_P_MISC) $(INTL_P_MISC) \
		$(WAL_P_MISC) $(FUNCTIONS) $(GDSF_LIB) \
		$(LD_LIBS) -o libgds.$(SHRLIB_EXT)
	$(CHMOD_6) libgds.$(SHRLIB_EXT)
	$(MV) libgds.$(SHRLIB_EXT) $(GDSSHR_DEST)
	$(TOUCH) libgds.$(SHRLIB_EXT)
	$(CHMOD_6) libgds.$(SHRLIB_EXT)

gds.$(SHRLIB_EXT).0 $(DG_GDSSHR) $(DG_X86_GDSSHR) $(UNIXWARE_GDSSHR) $(NCR3000_GDSSHR): \
		$(JRD_P_OBJECTS) flu.bin $(CSI_P_MISC) $(DSQL_P_MISC) \
		$(LOCK_P_MISC) $(REMOTE_P_MISC) $(SECURITY_P_MISC) \
		$(INTL_P_MISC) $(WAL_P_MISC) \
		$(FUNCTIONS)
	-$(RM) gds.$(SHRLIB_EXT).0
	ld $(LD_OPTS) libgds.$(SHRLIB_EXT).0 $(ZDEFS) $(JRD_P_OBJECTS) flu.bin \
		$(CSI_P_MISC) $(DSQL_P_MISC) $(LOCK_P_MISC) \
		$(REMOTE_P_MISC) $(SECURITY_P_MISC) $(INTL_P_MISC) \
		$(WAL_P_MISC) $(FUNCTIONS) $(GDSF_LIB) \
		$(LD_LIBS) -o gds.$(SHRLIB_EXT).0
	$(CHMOD_6) gds.$(SHRLIB_EXT).0
	$(MV) gds.$(SHRLIB_EXT).0 $(GDSSHR)
	$(TOUCH) gds.$(SHRLIB_EXT).0
	$(CHMOD_6) gds.$(SHRLIB_EXT).0

# For the Darwin port
gds.dylib: $(DO_FORCE) \
		$(JRD_P_OBJECTS) flu.bin $(CSI_P_MISC) $(DSQL_P_MISC) \
		$(LOCK_P_MISC) $(REMOTE_P_MISC) $(SECURITY_P_MISC) \
		$(INTL_P_MISC) $(WAL_P_MISC) \
		$(FUNCTIONS)

	-$(RM) gds.dylib
	libtool -dynamic -o gds.dylib -current_version $(FW_VERS) \
		-compatibility_version $(FW_COMPAT_VERS) \
		-install_name $(FW_NAME)/Versions/A/$(FBFW_PREFIX) \
		$(ZDEFS) $(JRD_P_OBJECTS) flu.bin \
		$(CSI_P_MISC) $(DSQL_P_MISC) $(LOCK_P_MISC) \
		$(REMOTE_P_MISC) $(SECURITY_P_MISC) $(INTL_P_MISC) \
		$(WAL_P_MISC) $(FUNCTIONS) $(GDSF_LIB) \
		$(LD_LIBS) -framework System -framework CoreFoundation
	$(CHMOD_6) gds.dylib
	$(MV) gds.dylib $(GDSSHR_DEST)
	$(TOUCH) gds.dylib
	$(CHMOD_6) gds.dylib


# Solaris has two Shared libraries - the traditional style one
# is called gdsmt.$(SHRLIB_EXT).0, as it requires v3.3 -> v4.0 customers
# to recompile and relink.
# In v4.0 we add a "gds.$(SHRLIB_EXT).0" library which is really a pipe
# client library.  This is so existing 3.3 customers are
# isolated from Solaris problems involving threads & signals.
gds.$(SHRLIB_EXT).solaris $(SOL_GDSSHR):  gdsmt.$(SHRLIB_EXT).0 gdspipe.$(SHRLIB_EXT).0

gdsmt.$(SHRLIB_EXT).0: \
		$(JRD_P_OBJECTS) flu.bin $(CSI_P_MISC) $(DSQL_P_MISC) \
		$(LOCK_P_MISC) \
		$(REMOTE_P_MISC) $(SECURITY_P_MISC) \
		$(INTL_P_MISC) $(WAL_P_MISC) \
		$(FUNCTIONS)
	-$(RM) gdsmt.$(SHRLIB_EXT).0
	ld $(LD_OPTS) libgdsmt.$(SHRLIB_EXT).0 $(ZDEFS) $(JRD_P_OBJECTS) flu.bin \
		$(CSI_P_MISC) $(DSQL_P_MISC) $(LOCK_P_MISC) \
		$(REMOTE_P_MISC) $(SECURITY_P_MISC) \
		$(INTL_P_MISC) $(WAL_P_MISC) $(FUNCTIONS) \
		$(GDSF_LIB) $(LD_LIBS) -o gdsmt.$(SHRLIB_EXT).0
	$(CHMOD_6) gdsmt.$(SHRLIB_EXT).0
	$(MV) gdsmt.$(SHRLIB_EXT).0 $(GDSSHR)
	$(TOUCH) gdsmt.$(SHRLIB_EXT).0
	$(CHMOD_6) gdsmt.$(SHRLIB_EXT).0

gdsf.$(SHRLIB_EXT) $(DG_FUNCSHR) $(DG_X86_FUNCSHR):	functions.bin
	-$(RM) gdsf.$(SHRLIB_EXT)
	ld -G functions.bin -o gdsf.$(SHRLIB_EXT)
	$(CHMOD_6) gdsf.$(SHRLIB_EXT)
	$(MV) gdsf.$(SHRLIB_EXT) $(FUNCSHR)
	$(TOUCH) gdsf.$(SHRLIB_EXT)
	$(CHMOD_6) gdsf.$(SHRLIB_EXT)

gdsshr_ss.dll:	$(WIN_NT_SS_GDSSHR)
	$(TOUCH) gdsshr_ss.dll

gdsshr.dll:	$(WIN_NT_GDSSHR)
	$(TOUCH) gdsshr.dll

gds32_nt_ms.dll: $(WHY_O) $(JRD_OBJECTS) gdsalias.o
	-$(RM) gds32.dll gds32.lib
	$(IMPLIB) -out:gds_temp.lib $(WHY_O) $(JRD_OBJECTS)
	$(IMPLIB) -out:gds_temp.lib gds_temp.lib $(DSQL_MISC) $(LOCK_MISC) $(REMOTE_MISC) $(WAL_MISC) \
	$(SECURITY_MISC)
	$(IMPLIB) -out:gds32.lib -def:gds.bind gds_temp.lib
	$(LINK) $(LD_OPTS) -out:gds32.dll -dll -entry:_CRT_INIT$(DLLENTRY) gds_temp.lib gds32.exp $(CONLIBSDLL) $(WSOCKLIB) $(ADVAPILIB) $(MPRLIB)
	$(RM) gds_temp.lib
	$(RM) gds32.exp
	$(MV) gds32.lib gds32_ms.lib
	$(RM) gds32.lib
	implib gds32.lib gds32.dll
	tlib gds32.lib +- gdsalias.o
	$(MV) gds32.lib source\interbase\lib
	$(MV) gds32_ms.lib source\interbase\lib
	$(MV) gds32.dll source/interbase/bin
	$(RM) gds32.dll gds32.lib gds32_ms.lib
	$(TOUCH) gds32_nt_ms.dll

gds32_nt_ms_ss.dll: $(WHY_O) $(JRD_OBJECTS) gdsalias.o
	-$(RM) gds32_ss.dll gds32_ss.lib gds32mss.lib
	$(IMPLIB) -out:gds_temp_ss.lib $(WHY_O) $(JRD_OBJECTS)
	$(IMPLIB) -out:gds_temp_ss.lib gds_temp_ss.lib $(DSQL_MISC) $(LOCK_MISC) $(REMOTE_MISC) $(WAL_MISC) \
	$(SECURITY_MISC)
	$(IMPLIB) -out:gds32_ss.lib -def:gds.bind gds_temp_ss.lib
	$(LINK) $(LD_OPTS) -out:gds32_ss.dll -dll -entry:_CRT_INIT$(DLLENTRY) gds_temp_ss.lib gds32_ss.exp $(CONLIBSDLL) $(WSOCKLIB) $(ADVAPILIB) $(MPRLIB)
	$(RM) gds_temp_ss.lib
	$(RM) gds32_ss.exp
	$(MV) gds32_ss.lib gds32mss.lib
	$(RM) gds32_ss.lib
	implib gds32_ss.lib gds32_ss.dll
	tlib gds32_ss.lib +- gdsalias.o
	$(MV) gds32_ss.dll source/interbase/bin
	$(RM) gds32.dll
	$(TOUCH) gds32_nt_ms_ss.dll

gdsalias.o:	gdsalias.asm
	tasm32 gdsalias.asm

gds32_nt_bc4.dll: $(WHY_O) $(JRD_OBJECTS)
	-$(RM) gds32.dll gds32.lib tmp.bind
	sed -e 's/DATA READ WRITE/DATA MULTIPLE/' -e 's/LIBRARY gds32/LIBRARY gds32 INITINSTANCE/' gds.bind > tmp.bind
	$(LINK) -Tpd -ap -c $(LD_OPTS) -w-inq -x /Lc:\bc4\lib c0d32 @gds.rsp,gds32.dll,,import32 cw32mt,tmp.bind
	implib gds32.lib gds32.dll
	$(MV) gds32.lib source\interbase\lib
	$(MV) gds32.dll source/interbase/bin
	$(RM) gds32.dll gds32.lib tmp.bind
	$(TOUCH) gds32_nt_bc4.dll

gds32_os2_bc4.dll: $(WHY_O) $(JRD_OBJECTS)
	-$(RM) gds32.dll gds32.lib tmp.bind
	sed -e 's/DATA READ WRITE/DATA MULTIPLE NONSHARED/' -e 's/LIBRARY gds32/LIBRARY gds32 INITINSTANCE/' -e 's/\ \ \ \ /\ \ \ \ _/' gds.bind > tmp.bind
	$(LINK) -Tod -ap -c $(LD_OPTS) -x /Lc:\bcos2\lib;c:\tcpip\lib c02d @gds.rsp,gds32.dll,,os2 c2mt so32dll tcp32dll,tmp.bind
	implib gds32.lib gds32.dll
	$(MV) gds32.lib ..\interbase\lib
	$(MV) gds32.dll ..\interbase\bin
	$(RM) gds32.dll gds32.lib tmp.bind
	$(TOUCH) gds32_os2_bc4.dll

gds32_os2_ibm.dll: $(WHY_O) $(JRD_OBJECTS)
	-$(RM) gds32.dll gds32.lib bind.tmp
	sed -e 's/DATA READ WRITE/DATA MULTIPLE NONSHARED/' -e 's/LIBRARY gds32/LIBRARY gds32 INITINSTANCE/' gds.bind > bind.tmp
	$(LINK) $(LD_OPTS) @gds.rsp,gds32.dll,,so32dll tcp32dll,bind.tmp
	c:\toolkt21\os2bin\implib gds32.lib gds32.dll
	$(MV) gds32.lib ..\interbase\lib
	$(MV) gds32.dll ..\interbase\bin
	$(RM) gds32.dll gds32.lib bind.tmp
	$(TOUCH) gds32_os2_ibm.dll

event_print:	print.o $(GDSLIB_BACKEND)
	$(LD) $(LINK_OPTS) -g print.o -o event_print $(GDSLIB_LINK)

event_print.exe:	print.o
	$(LD) $(DEBUG_LINK_OPTS) $(O_EXE_SWITCH)event_print print.o $(GDSLIB_LINK)

gds.a:		$(HEAD_OBJECTS) $(NOLINK_MACHINES)
	-$(RM) gds.a
	$(AR) gds.a $(HEAD_OBJECTS)
	-ranlib gds.a
	$(CHMOD_6) gds.a
	$(MV) gds.a $(HEAD_LIB)
	$(TOUCH) gds.a
	$(CHMOD_6) gds.a

# Solaris specific shared library that invokes a pipe-server interface
# to isolate clients that might use signals from threads.
# Note that its internal library name is libgds.$(SHRLIB_EXT) for compatibility
# with existing applications.
gdspipe.$(SHRLIB_EXT).0:	$(HEAD_J_OBJECTS)
	-$(RM) gdspipe.$(SHRLIB_EXT).0
	-$(RM) gds.$(SHRLIB_EXT).0
	ld $(LD_OPTS) libgds.$(SHRLIB_EXT).0 $(HEAD_J_OBJECTS) $(LD_LIBS_J) \
		-o gds.$(SHRLIB_EXT).0
	$(CHMOD_6) gds.$(SHRLIB_EXT).0
	$(MV) gds.$(SHRLIB_EXT).0 $(PIPE_GDSSHR)
	$(TOUCH) gdspipe.$(SHRLIB_EXT).0
	$(CHMOD_6) gdspipe.$(SHRLIB_EXT).0

# The Solaris version of gds.a uses the .j objects as they have
# been compiled in non-Thread mode.  The .j objects are PIC code
# which isn't optimal, but will function fine.
gds.a.solaris:	$(HEAD_J_OBJECTS)
	-$(RM) gds.a.solaris
	$(AR) gds.a $(HEAD_J_OBJECTS)
	-ranlib gds.a
	$(CHMOD_6) gds.a
	$(MV) gds.a $(HEAD_LIB)
	$(TOUCH) gds.a.solaris
	$(CHMOD_6) gds.a.solaris

# JMB MERGE_MISC (merge.o) is already in the shlib with REMOTE_P_OBJECTS.
# allp.bin already in the shared library. ($(ALLP_OBJECT))
# So don't link in with executable.
gds_pipe:	$(FOOT_OBJECTS) $(WHYPS_O) $(GDSSHR) \
		$(GDSLIB_BACKEND) $(NOLINK_MACHINES)
	-$(RM) gds_pipe gdsshr_pipe
	$(LD) $(LINK_OPTS) $(FOOT_OBJECT) \
		$(T_SWITCH) $(T_SWITCH) \
		$(WHYPS_O) -o gds_pipe $(SERVER_LINK)
	$(CHMOD_7) gds_pipe
	$(MV) gds_pipe $(FOOT)
	$(TOUCH) gds_pipe
	$(CHMOD_6) gds_pipe

bridge.unix:	gds_pipe
	-$(RM) gds_pipe5
	$(LD) $(LINK_OPTS) $(FOOT_OBJECTS) -o gds_pipe5 $(GDSLIB_LINK)
	$(CHMOD_7) gds_pipe5

gds_pipe.a:	$(FOOT_OBJECTS) $(NOLINK_MACHINES)
	-$(RM) gds_pipe.a
	$(AR) gds_pipe.a $(FOOT_OBJECTS)
	-ranlib gds_pipe.a
	$(CHMOD_6) gds_pipe.a
	$(MV) gds_pipe.a $(FOOT_LIB)
	$(TOUCH) gds_pipe.a
	$(CHMOD_6) gds_pipe.a


includes.msg:	$(OBJS)/msgs/indicator.incl
	-$(RM) includes.msg
	$(TOUCH) includes.msg
	$(CHMOD_6) includes.msg

super_server_objects: force
	$(CD) $(OBJS)/dsql && $(MAKE) CFLAGS="$(CFLAGS)" SYSTEM="$(SYSTEM)" dsql_objects
	$(CD) $(OBJS)/lock && $(MAKE) CFLAGS="$(CFLAGS)" SYSTEM="$(SYSTEM)" lock
	$(CD) $(OBJS)/remote && $(MAKE) CFLAGS="$(CFLAGS)" SYSTEM="$(SYSTEM)" rem_objects
	$(CD) $(OBJS)/wail && $(MAKE) CFLAGS="$(CFLAGS)" SYSTEM="$(SYSTEM)" wal_objects

super_client_objects:	$(JRD_CLIENT_P_OBJECTS)
	-$(RM) super_client_objects
	$(TOUCH) super_client_objects
	$(CHMOD_6) super_client_objects

debug_objects:	grammar.o dbg.o dbt.o dmp.o

nolink_machines: source/pipe/allp.c source/pipe/foot.c source/pipe/head.c
	$(CP) $? .
	-$(RM) nolink_machines
	$(TOUCH) nolink_machines
	$(CHMOD_6) nolink_machines

run_codes: $(CODES_FILES)
#       We should be compiling and running codes here, but we will do that
#	later!!!
#        -$(SH) '$(CMP) $(OBJS)/jrd/iberror.h $(OBJS)/firebird/include/iberror.h; if [ $$? != 0 ]; then $(CP) $(SOURCE)/jrd/iberror.h $(OBJS)/firebird/include/iberror.h; fi'

$(CODES_FILES):
	touch $@
	-$(CP) $(SOURCE)/jrd/gen/$(@F) $@



#____________________________________________________________________________
#
# Rebuild the codes generates in the src/jrd/boot_codes directory
# this target updates the values stored in the source path if they are
# different to the newly generated entries.
#
# There are also blrtable.h and ids.h which are generated as well.
# Regeneration is a manual thing, and you will need to

generated_headers: ensureRebuild rebuild_codes ../include/gen/blrtable.h ../include/gen/ids.h

ensureRebuild:
	touch codes.epp
	touch blrtable.cpp
	touch relations.h

rebuild_codes: codes
	./codes $(ROOT)/src/include/gen


codes:		codes.o $(STDIO) $(LIBGDS_DEP)
	-$(RM) codes
	echo "Hello"
	$(EXE_LINK) $(LINK_OPTS) $(LIBGDS_LINK) $(CXX_INCLUDE_DIRS) $^ -o $@ $(LINK_LIBS)
#	$(EXE_LINK) $(LINK_OPTIONS) $(LIBGDS_LINK) $(CXX_INCLUDE_DIRS) -o codes $^
	$(CHMOD_7) codes


../include/gen/blrtable.h:	blrtable.cpp $(STDIO)
	$(EXE_LINK) $(LINK_OPTIONS $(CXX_INCLUDE_DIRS) $(VERSION_FLAG) $(LINK_OPTS) blrtable.cpp $(STDIO) $(LD_LIBS) -o blrtable
	-./blrtable > $@
	-$(RM) blrtable

../include/gen/ids.h:	ids.m relations.h
	m4 $< > ../include/gen/ids.h


# Security requires a database to compile so it cannot be used until
# after gpre_static and gbak have been built.  The alt.cpp file has a
# -DPHASE_1_NO_SECURITY macro that disables compilaton of security
# components.  So the early _boot and _static builds use the boot one and
# the later ones rely on the complete alt.o.  This is controlled by the
# makefile building a different jrd/alt_use_sec.h at

# BTW: Ann (and I think Jim as well) believe that the security
# database has no business being applied at this level, and should be
# removed or moved -  MOD 22-7-2001

# The file alt.cpp can be built in two versions BOOT and normal, where
# boot does not use the security database and the normal build does.
# We build a different header file from alt_use_sec.h.pre in the boot and
# the post boot stages of the build.

build_alt_use_boot: alt_use_sec.h.pre
	sed '/^#undef PHASE_1_BUILD_NO_SECURITY_DB/s/undef/define/' < $^ > alt_use_sec.h

build_alt_use_main: alt_use_sec.h.pre
	cp $^ alt_use_sec.h


# The GPRE options passed in ar edifferent to the default ones so we have a
# special rule.

# Some of these you have to wonderabout, since here are a number of files
# that use DATABASE FILENAME = 'ODS.RDB' but ODS.RDB does not exsit
# For that reason all the .epp files in this directory are compiled
# with the following options.
# fun.epp they allow you to compile without having a database present.
# The db file ODS.RDB (as used in fun.epp doesn't exist, and was not part
# of the original 6.0 build).



#$(SRC)/codes.cpp:	$(SRC)/codes.epp
codes.cpp:	$(SRC)/codes.epp  msg.fdb
	$(GPRE) -n -manual -raw -string $< $@


msg.fdb:
	ln -fs $(SRC_ROOT)/refDatabases/msg.fdb msg.fdb

#$(SRC)/fun.cpp: $(SRC)/fun.epp
#	$(GPRE) -n -gds -raw -ids $< $@


#____________________________________________________________________________

# These guys are the results of compiling files with different macros
# defined and outputting them to differently named .o files.


# BACKEND

whybk.o:	why.cpp
	$(CC) -c $(CFLAGS) $(VERSION_FLAG) -DBACKEND $< -o $@

# Special compiles of modules to omit parts not needed for pipe access


utlp.o:		utl.cpp
	$(CXX) -c $(CFLAGS) $(CXX_INCLUDE_DIRS) $(VERSION_FLAG) -DPIPE_CLIENT $< -o $@
utlp.j:		utl.o
	$(CXX) -c $(PIC_J_CFLAGS) $(CXX_INCLUDE_DIRS) $(VERSION_FLAG) -DPIPE_CLIENT $< -o $@
whyp.o:		why.cpp
	$(CC) -c $(CFLAGS) $(VERSION_FLAG) -DPIPE_CLIENT $< -o $@
whyp.j:		why.o
	$(CC) -c $(PIC_J_CFLAGS) $(VERSION_FLAG) -DPIPE_CLIENT $< -o $@

# whyps.o is used for machines that have a gds_pipe executable with the
# full backend linked in.  It omits an interface to the V3 bridge, which
# is included with the pipe client and not needed in the pipe server.
whyps.o:	why.o
	-$(RM) whyps.cpp
	$(CP) why.cpp whyps.cpp
	$(CC) -c $(CFLAGS) $(VERSION_FLAG) -DPIPE_SERVER_YVALUE whyps.cpp

# SHARED BRIDGE

iscb.o:		isc.cpp
	$(CXX) -c $(CFLAGS) $(CXX_INCLUDE_DIRS) $(VERSION_FLAG) -DBRIDGE $< -o $@

iscb.bin:	isc.cpp
	$(CXX) -c $(PIC_FLAGS) $(CXX_INCLUDE_DIRS) $(VERSION_FLAG) -DBRIDGE $< -o $@


# This is the one where dyn_def.epp produced dyn_def.cpp and then the sed
# script is run to remove a component of it.  This is pretty ugly, and even
# if we have to live with it, the makefile should be changed to make the
# dependencies clearer.

$(SRC)/dyn_def.cpp : $(SRC)/dyn_def.epp $(SRC)/dyn_def.sed
	$(GPRE_BOOT) $(GPRE_FLAGS) $< $(GEN_SRC)/dyn_deffoo.cpp
	sed -f $(SRC)/dyn_def.sed $(GEN_SRC)/dyn_deffoo.cpp > $@

# This was the old dependancies.
#$(BIN)/dyn_def.o: $(SRC)/dyn_def.cpp $(SRC)/dyn_def.sed
#	sed -f dyn_def.sed $< > dyn_deffoo.cpp
#	$(CXX) -c $(CFLAGS) $(CXX_INCLUDE_DIRS) $(VERSION_FLAG) dyn_deffoo.cpp
#	$(MV) dyn_deffoo.o dyn_def.bin
#	-$(RM) dyn_deffoo.cpp dyn_deffoo.o


flu_non_dl.bin:	flu.cpp
	$(CXX) -c $(PIC_FLAGS) $(CXX_INCLUDE_DIRS) $(VERSION_FLAG) -DNON_DL_COMPATIBLE -c $< -o flu_non_dl.cpp
	$(MV) flu_non_dl.o flu_non_dl.bin
	-$(RM) flu_non_dl.cpp

AllObjects = $(BOOT_Objects) $(JRD_Objects) $(OS_SPECIFIC_Objects)

Dependencies = $(AllObjects:.o=.d)

FORCE:

-include $(Dependencies)
